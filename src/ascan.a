-- A lexical scanner generated by aflex
with text_io; use text_io;
with ascan_dfa; use ascan_dfa; 
with ascan_io; use ascan_io; 
--# line 1 "../ascan.l"
-- Copyright (c) 1990 Regents of the University of California.
-- All rights reserved.
--
-- This software was developed by John Self of the Arcadia project
-- at the University of California, Irvine.
--
-- Redistribution and use in source and binary forms are permitted
-- provided that the above copyright notice and this paragraph are
-- duplicated in all such forms and that any documentation,
-- advertising materials, and other materials related to such
-- distribution and use acknowledge that the software was developed
-- by the University of California, Irvine.  The name of the
-- University may not be used to endorse or promote products derived
-- from this software without specific prior written permission.
-- THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
-- IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
-- WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
-- TITLE scanner specification file
-- AUTHOR: John Self (UCI)
-- DESCRIPTION regular expressions and actions matching tokens
--             that aflex expects to find in its input.
-- NOTES input to aflex (NOT alex.)  It uses exclusive start conditions
--       and case insensitive scanner generation available only in aflex
--       (or flex if you use C.)
--       generate scanner using the command 'aflex -is ascan.l'
-- $Header: C:/CVSROOT/afay/aflex/src/ascan.a,v 1.4 2004/10/21 20:48:23 Grands Exp $ 
--
-- 2004/10/16 Thierry Bernier
-- + Add "%unit" to support Ada-95 parent/child units
-- + Less -gnatwa warnings
--%unit Scanner
--UNAME		{NAME}("."{NAME})*
--# line 53 "../ascan.l"


with misc_defs, misc, sym, parse_tokens, int_io;
with tstring, ascan_dfa, ascan_io, external_file_manager;
use misc_defs, parse_tokens, tstring;
use ascan_dfa, ascan_io, external_file_manager;

package scanner is
    call_yylex : boolean := false;
    function get_token return Token;
end scanner;

package body scanner is

beglin : boolean := false;
i, bracelevel: integer;

function get_token return Token is
    toktype : Token;
    didadef, indented_code : boolean;
    cclval : integer;
    nmdefptr : vstring;
    nmdef, tmpbuf : vstring;

procedure ACTION_ECHO is
begin
    text_io.put( temp_action_file, yytext(1..YYLength) );
end ACTION_ECHO;

procedure MARK_END_OF_PROLOG is
begin
     text_io.put( temp_action_file, "%%%% end of prolog" );
     text_io.new_line( temp_action_file );
end MARK_END_OF_PROLOG;

procedure PUT_BACK_STRING(str : vstring; start : integer) is
begin
	for i in reverse start+1..tstring.len(str) loop
	    unput( CHAR(str,i) );
	end loop;
end PUT_BACK_STRING;

function check_yylex_here return boolean is
begin
	return ( (yytext'length >= 2) and then
			((yytext(1) = '#') and (yytext(2) = '#')));
end check_yylex_here;

function YYLex return Token is
subtype short is integer range -32768..32767;
    yy_act : integer;
    yy_c : short;

-- returned upon end-of-file
YY_END_TOK : constant integer := 0;
YY_END_OF_BUFFER : constant := 83;
subtype yy_state_type is integer;
yy_current_state : yy_state_type;
INITIAL : constant := 0;
SECT2 : constant := 1;
SECT2PROLOG : constant := 2;
SECT3 : constant := 3;
PICKUPDEF : constant := 4;
SC : constant := 5;
CARETISBOL : constant := 6;
NUM : constant := 7;
QUOTE : constant := 8;
FIRSTCCL : constant := 9;
CCL : constant := 10;
ACTION : constant := 11;
RECOVER : constant := 12;
BRACEERROR : constant := 13;
ACTION_STRING : constant := 14;
yy_accept : constant array(0..210) of short :=
    (   0,
        0,    0,    0,    0,    0,    0,   81,   81,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
       83,   14,    7,   13,   11,    1,   12,   14,   14,   14,
       10,   40,   32,   33,   26,   40,   39,   24,   40,   40,
       40,   32,   22,   40,   40,   25,   82,   20,   81,   81,
       16,   15,   17,   46,   82,   42,   43,   45,   47,   61,
       62,   59,   58,   60,   48,   50,   49,   48,   54,   53,
       54,   54,   56,   56,   56,   57,   67,   72,   71,   73,
       67,   73,   68,   65,   66,   82,   18,   64,   63,   74,

       76,   77,   78,    7,   13,   11,    1,   12,    0,    0,
        2,    0,    8,    4,    6,    5,    0,   10,   32,   33,
        0,   29,    0,    0,    0,   79,   79,   28,   27,   28,
        0,   32,   22,    0,    0,   36,    0,    0,   20,   19,
       81,   81,   16,   15,   44,   45,   58,   80,   80,   51,
       52,   55,   67,    0,   70,    0,   67,   68,    0,   18,
       74,   75,    0,    8,    0,    0,    0,    3,    0,   30,
        0,   37,    0,   79,   28,   28,   38,    0,    0,    0,
       36,    0,   31,   80,   67,   69,    0,    0,    9,    0,
        0,    0,    0,    0,    0,    0,    0,    6,    0,    0,

        0,   23,    0,   23,    0,   23,    4,    0,   35,    0
    ) ;

yy_ec : constant array(CHARACTER'FIRST..CHARACTER'LAST) of short :=
    (   0,
        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
        1,    4,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    5,    1,    6,    7,    8,    9,    1,   10,   11,
       11,   11,   11,   12,   13,   11,   14,   15,   15,   15,
       15,   15,   15,   15,   15,   15,   15,    1,    1,   16,
        1,   17,   11,    1,   23,   22,   22,   22,   24,   25,
       22,   22,   26,   22,   22,   22,   22,   27,   28,   22,
       22,   29,   30,   31,   32,   22,   22,   33,   22,   22,
       18,   19,   20,   21,   22,    1,   23,   22,   22,   22,

       24,   25,   22,   22,   26,   22,   22,   22,   22,   27,
       28,   22,   22,   29,   30,   31,   32,   22,   22,   33,
       22,   22,   34,   35,   36,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,

        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1
    ) ;

yy_meta : constant array(0..36) of short :=
    (   0,
        1,    2,    3,    2,    2,    4,    1,    1,    1,    5,
        1,    1,    6,    5,    6,    1,    1,    1,    7,    8,
        1,    9,    9,    9,    9,    9,    9,    9,    9,    9,
        9,    9,    9,    5,    1,   10
    ) ;

yy_base : constant array(0..253) of short :=
    (   0,
        0,   36,   71,  105,  386,  385,  384,  383,   89,   93,
      140,    0,  364,  363,  100,  174,   80,   98,  175,  178,
      182,  187,  210,    0,  380,  379,   97,   99,  119,  244,
      381,  874,  125,  874,    0,  249,  874,  377,  239,  366,
        0,  874,  253,  874,  874,  129,  874,  362,  357,  360,
      274,  306,  874,  365,  360,  874,  369,    0,  368,  874,
        0,   76,  874,  874,  874,  874,  349,    0,  874,  874,
      874,  874,  349,  874,  874,  874,  874,  348,  874,  874,
      335,  336,  874,    0,  333,  874,    0,  874,  874,  173,
      334,  874,    0,  874,  874,  343,  874,  874,  874,    0,

      874,  874,    0,  262,  874,    0,  271,  874,  332,  340,
      874,  335,    0,  308,  311,  874,  334,    0,  277,  874,
      333,  874,  311,  160,  167,  874,  319,    0,  874,  329,
      320,  364,  874,  319,  190,    0,  328,  327,    0,  874,
      326,  874,    0,  281,  874,    0,  313,  874,  312,  874,
      874,  874,    0,  249,  874,    0,  399,    0,  323,  874,
        0,  874,  322,    0,  301,  297,  319,  874,  318,  874,
      292,  874,  189,  303,    0,    0,  874,  304,  257,  274,
        0,  313,  874,  300,    0,  874,  435,  311,  874,  284,
      262,  253,  275,  258,  246,  202,  167,  874,  167,  272,

      134,  874,  117,  874,   85,  874,  874,   67,  874,  874,
      470,  480,  490,  500,  510,  520,  530,  540,  550,  560,
      570,  575,  584,  594,  599,  608,  618,  628,  638,  648,
      658,  668,  678,  683,  692,  702,  712,  722,  730,  735,
      744,  754,  764,  774,  784,  794,  804,  813,  823,  833,
      843,  853,  863
    ) ;

yy_def : constant array(0..253) of short :=
    (   0,
      210,  210,  211,  211,  212,  212,  213,  213,  214,  214,
      210,   11,  215,  215,  216,  216,  217,  217,  218,  218,
      219,  219,  210,   23,  220,  220,  215,  215,  221,  221,
      210,  210,  210,  210,  222,  210,  210,  223,  224,  210,
      225,  210,  210,  210,  210,  210,  210,  210,  226,  227,
      228,  229,  210,  210,  210,  210,  230,  231,  232,  210,
      233,  210,  210,  210,  210,  210,  210,  234,  210,  210,
      210,  210,  210,  210,  210,  210,  210,  227,  210,  210,
      235,  236,  210,  237,  227,  210,  238,  210,  210,  239,
      238,  210,  240,  210,  210,  241,  210,  210,  210,  242,

      210,  210,  243,  210,  210,  222,  210,  210,  210,  223,
      210,  210,  244,  210,  210,  210,  245,  225,  210,  210,
      246,  210,  210,  226,  226,  210,  210,  247,  210,  247,
      210,  229,  210,  210,  246,  248,  249,  230,  231,  210,
      232,  210,  233,  210,  210,  234,  210,  210,  210,  210,
      210,  210,  238,  239,  210,  239,  210,  240,  241,  210,
      242,  210,  250,  244,  210,  210,  245,  210,  246,  210,
      210,  210,  226,  210,  247,  130,  210,  210,  249,  246,
      248,  249,  210,  210,  157,  210,  157,  250,  210,  210,
      210,  210,  226,  251,  252,  253,  210,  210,  210,  226,

      251,  210,  252,  210,  253,  210,  210,  210,  210,    0,
      210,  210,  210,  210,  210,  210,  210,  210,  210,  210,
      210,  210,  210,  210,  210,  210,  210,  210,  210,  210,
      210,  210,  210,  210,  210,  210,  210,  210,  210,  210,
      210,  210,  210,  210,  210,  210,  210,  210,  210,  210,
      210,  210,  210
    ) ;

yy_nxt : constant array(0..910) of short :=
    (   0,
       32,   33,   34,   33,   33,   32,   32,   32,   32,   32,
       32,   32,   32,   32,   32,   32,   32,   32,   32,   32,
       32,   35,   35,   35,   35,   35,   35,   35,   35,   35,
       35,   35,   35,   32,   32,   32,   32,   36,   37,   36,
       36,   32,   38,   32,   39,   32,   32,   32,   40,   32,
       32,   32,   32,   32,   32,   32,   32,   41,   41,   41,
       41,   41,   41,   41,   41,   41,   41,   41,   41,   32,
       32,   32,   43,   44,   43,   43,   45,  144,   46,  144,
      144,   47,   76,  209,   47,   77,   48,  206,   49,   50,
       62,   63,   62,   62,   62,   63,   62,   62,   78,   98,

       76,   98,   71,   77,   51,   47,   52,   53,   52,   52,
       45,   72,   46,   54,   73,   47,   78,   55,   47,  204,
       48,  101,   49,   50,  102,   56,  104,  105,  104,  104,
      122,  122,   99,  122,   99,   74,  202,  103,   51,   47,
       64,   64,   65,   64,   64,   64,   64,   64,   64,   64,
       64,   66,   64,   64,   64,   64,   67,   64,   64,   64,
       64,   68,   68,   68,   68,   68,   68,   68,   68,   68,
       68,   68,   68,   64,   64,   64,   71,   65,  125,  172,
       65,  173,  155,  208,   65,   72,  124,   80,   73,   65,
       80,  156,  170,   81,   84,   82,   81,  207,   82,   84,

       85,   86,  180,  193,  206,   85,   86,  125,  172,   74,
       87,   87,   88,   87,   87,   89,   87,   87,   87,   90,
       87,   87,   91,   92,   87,   87,   87,   87,   87,   87,
       87,   93,   93,   93,   93,   93,   93,   93,   93,   93,
       93,   93,   93,   94,   87,   95,  101,  113,  204,  102,
      107,  108,  107,  107,  119,  120,  119,  119,  155,  183,
      202,  109,  103,  104,  105,  104,  104,  156,  114,  195,
      115,  116,  107,  108,  107,  107,  170,  199,  119,  120,
      119,  119,  144,  109,  144,  144,  196,  121,  129,  200,
      125,  172,  198,  125,  172,  130,  130,  130,  130,  130,

      130,  130,  130,  130,  130,  130,  130,  132,  133,  132,
      132,  121,  197,  189,  148,  183,  194,  126,  134,  192,
      170,  168,  191,  190,  189,  160,  184,  147,  142,  139,
      183,  179,  178,  174,  171,  170,  168,  166,  165,  163,
      135,  176,  111,  176,  117,  160,  157,  127,  151,  149,
      176,  176,  176,  176,  176,  176,  176,  176,  176,  176,
      176,  176,  127,  147,  177,  132,  133,  132,  132,  145,
      142,  139,  137,  136,  127,  125,  134,  123,  117,  111,
      210,   97,   97,   69,   69,   60,   60,   58,   58,  210,
      210,  210,  210,  210,  210,  210,  210,  210,  135,  185,

      185,  186,  185,  185,  187,  185,  185,  185,  187,  185,
      185,  185,  187,  185,  185,  185,  185,  185,  185,  185,
      187,  187,  187,  187,  187,  187,  187,  187,  187,  187,
      187,  187,  187,  185,  187,  187,  187,  210,  187,  187,
      210,  187,  187,  187,  210,  187,  187,  187,  210,  187,
      187,  187,  187,  187,  187,  187,  210,  210,  210,  210,
      210,  210,  210,  210,  210,  210,  210,  210,  210,  187,
       42,   42,   42,   42,   42,   42,   42,   42,   42,   42,
       57,   57,   57,   57,   57,   57,   57,   57,   57,   57,
       59,   59,   59,   59,   59,   59,   59,   59,   59,   59,

       61,   61,   61,   61,   61,   61,   61,   61,   61,   61,
       65,   65,   65,   65,   65,   65,   65,   65,   65,   65,
       70,   70,   70,   70,   70,   70,   70,   70,   70,   70,
       75,   75,   75,   75,   75,   75,   75,   75,   75,   75,
       79,   79,   79,   79,   79,   79,   79,   79,   79,   79,
       83,   83,   83,   83,   83,   83,   83,   83,   83,   83,
       96,   96,   96,   96,   96,   96,   96,   96,   96,   96,
      100,  100,  100,  100,  100,  100,  100,  100,  100,  100,
      106,  210,  210,  106,  110,  110,  110,  110,  110,  110,
      110,  110,  110,  110,  112,  112,  112,  112,  112,  112,

      112,  112,  112,  112,  118,  210,  210,  118,  124,  124,
      210,  124,  124,  124,  124,  210,  124,  124,  126,  126,
      210,  126,  126,  126,  126,  126,  126,  126,  128,  128,
      210,  128,  128,  128,  128,  128,  128,  128,  131,  131,
      131,  131,  131,  131,  131,  131,  131,  131,  138,  138,
      138,  138,  138,  138,  138,  138,  138,  138,  140,  210,
      210,  140,  140,  140,  140,  140,  140,  140,  141,  141,
      141,  141,  141,  141,  141,  141,  141,  141,  143,  143,
      210,  143,  143,  143,  143,  143,  143,  143,  146,  210,
      210,  146,  148,  148,  210,  148,  148,  148,  148,  148,

      148,  148,  150,  150,  210,  150,  150,  150,  150,  150,
      150,  150,  152,  152,  210,  152,  152,  152,  152,  210,
      152,  152,  153,  153,  210,  210,  210,  153,  153,  153,
      154,  154,  210,  154,  154,  154,  154,  154,  154,  154,
      158,  210,  210,  158,  159,  159,  159,  159,  159,  159,
      159,  159,  159,  159,  161,  161,  210,  210,  161,  161,
      210,  161,  161,  161,  162,  162,  210,  162,  162,  162,
      162,  162,  162,  162,  164,  164,  210,  164,  164,  164,
      164,  164,  164,  164,  167,  167,  167,  167,  167,  167,
      167,  167,  167,  167,  169,  169,  169,  169,  169,  169,

      169,  169,  169,  169,  175,  175,  210,  175,  175,  175,
      175,  175,  175,  181,  181,  210,  181,  181,  181,  181,
      181,  181,  181,  182,  182,  182,  182,  182,  182,  182,
      182,  182,  182,  188,  188,  188,  188,  188,  188,  188,
      188,  188,  188,  201,  201,  201,  201,  201,  201,  201,
      201,  201,  201,  203,  203,  203,  203,  203,  203,  203,
      203,  203,  203,  205,  205,  205,  205,  205,  205,  205,
      205,  205,  205,   31,  210,  210,  210,  210,  210,  210,
      210,  210,  210,  210,  210,  210,  210,  210,  210,  210,
      210,  210,  210,  210,  210,  210,  210,  210,  210,  210,

      210,  210,  210,  210,  210,  210,  210,  210,  210,  210
    ) ;

yy_chk : constant array(0..910) of short :=
    (   0,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    2,    2,    2,    2,
        2,    2,    2,    2,    2,    2,    2,    2,    2,    2,
        2,    2,    2,    2,    2,    2,    2,    2,    2,    2,
        2,    2,    2,    2,    2,    2,    2,    2,    2,    2,
        2,    2,    3,    3,    3,    3,    3,   62,    3,   62,
       62,    3,   17,  208,    3,   17,    3,  205,    3,    3,
        9,    9,    9,    9,   10,   10,   10,   10,   17,   27,

       18,   28,   15,   18,    3,    3,    4,    4,    4,    4,
        4,   15,    4,    4,   15,    4,   18,    4,    4,  203,
        4,   29,    4,    4,   29,    4,   33,   33,   33,   33,
       46,   46,   27,   46,   28,   15,  201,   29,    4,    4,
       11,   11,   11,   11,   11,   11,   11,   11,   11,   11,
       11,   11,   11,   11,   11,   11,   11,   11,   11,   11,
       11,   11,   11,   11,   11,   11,   11,   11,   11,   11,
       11,   11,   11,   11,   11,   11,   16,   19,  124,  124,
       20,  125,   90,  199,   21,   16,  125,   19,   16,   22,
       20,   90,  135,   19,   21,   19,   20,  197,   20,   22,

       21,   21,  135,  173,  196,   22,   22,  173,  173,   16,
       23,   23,   23,   23,   23,   23,   23,   23,   23,   23,
       23,   23,   23,   23,   23,   23,   23,   23,   23,   23,
       23,   23,   23,   23,   23,   23,   23,   23,   23,   23,
       23,   23,   23,   23,   23,   23,   30,   39,  195,   30,
       36,   36,   36,   36,   43,   43,   43,   43,  154,  179,
      194,   36,   30,  104,  104,  104,  104,  154,   39,  179,
       39,   39,  107,  107,  107,  107,  180,  192,  119,  119,
      119,  119,  144,  107,  144,  144,  180,   43,   51,  193,
      200,  200,  191,  193,  193,   51,   51,   51,   51,   51,

       51,   51,   51,   51,   51,   51,   51,   52,   52,   52,
       52,  119,  190,  188,  184,  182,  178,  174,   52,  171,
      169,  167,  166,  165,  163,  159,  149,  147,  141,  138,
      137,  134,  131,  127,  123,  121,  117,  115,  114,  112,
       52,  130,  110,  130,  109,   96,   91,   85,   82,   81,
      130,  130,  130,  130,  130,  130,  130,  130,  130,  130,
      130,  130,   78,   73,  130,  132,  132,  132,  132,   67,
       59,   57,   55,   54,   50,   49,  132,   48,   40,   38,
       31,   26,   25,   14,   13,    8,    7,    6,    5,    0,
        0,    0,    0,    0,    0,    0,    0,    0,  132,  157,

      157,  157,  157,  157,  157,  157,  157,  157,  157,  157,
      157,  157,  157,  157,  157,  157,  157,  157,  157,  157,
      157,  157,  157,  157,  157,  157,  157,  157,  157,  157,
      157,  157,  157,  157,  157,  187,  187,    0,  187,  187,
        0,  187,  187,  187,    0,  187,  187,  187,    0,  187,
      187,  187,  187,  187,  187,  187,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,  187,
      211,  211,  211,  211,  211,  211,  211,  211,  211,  211,
      212,  212,  212,  212,  212,  212,  212,  212,  212,  212,
      213,  213,  213,  213,  213,  213,  213,  213,  213,  213,

      214,  214,  214,  214,  214,  214,  214,  214,  214,  214,
      215,  215,  215,  215,  215,  215,  215,  215,  215,  215,
      216,  216,  216,  216,  216,  216,  216,  216,  216,  216,
      217,  217,  217,  217,  217,  217,  217,  217,  217,  217,
      218,  218,  218,  218,  218,  218,  218,  218,  218,  218,
      219,  219,  219,  219,  219,  219,  219,  219,  219,  219,
      220,  220,  220,  220,  220,  220,  220,  220,  220,  220,
      221,  221,  221,  221,  221,  221,  221,  221,  221,  221,
      222,    0,    0,  222,  223,  223,  223,  223,  223,  223,
      223,  223,  223,  223,  224,  224,  224,  224,  224,  224,

      224,  224,  224,  224,  225,    0,    0,  225,  226,  226,
        0,  226,  226,  226,  226,    0,  226,  226,  227,  227,
        0,  227,  227,  227,  227,  227,  227,  227,  228,  228,
        0,  228,  228,  228,  228,  228,  228,  228,  229,  229,
      229,  229,  229,  229,  229,  229,  229,  229,  230,  230,
      230,  230,  230,  230,  230,  230,  230,  230,  231,    0,
        0,  231,  231,  231,  231,  231,  231,  231,  232,  232,
      232,  232,  232,  232,  232,  232,  232,  232,  233,  233,
        0,  233,  233,  233,  233,  233,  233,  233,  234,    0,
        0,  234,  235,  235,    0,  235,  235,  235,  235,  235,

      235,  235,  236,  236,    0,  236,  236,  236,  236,  236,
      236,  236,  237,  237,    0,  237,  237,  237,  237,    0,
      237,  237,  238,  238,    0,    0,    0,  238,  238,  238,
      239,  239,    0,  239,  239,  239,  239,  239,  239,  239,
      240,    0,    0,  240,  241,  241,  241,  241,  241,  241,
      241,  241,  241,  241,  242,  242,    0,    0,  242,  242,
        0,  242,  242,  242,  243,  243,    0,  243,  243,  243,
      243,  243,  243,  243,  244,  244,    0,  244,  244,  244,
      244,  244,  244,  244,  245,  245,  245,  245,  245,  245,
      245,  245,  245,  245,  246,  246,  246,  246,  246,  246,

      246,  246,  246,  246,  247,  247,    0,  247,  247,  247,
      247,  247,  247,  248,  248,    0,  248,  248,  248,  248,
      248,  248,  248,  249,  249,  249,  249,  249,  249,  249,
      249,  249,  249,  250,  250,  250,  250,  250,  250,  250,
      250,  250,  250,  251,  251,  251,  251,  251,  251,  251,
      251,  251,  251,  252,  252,  252,  252,  252,  252,  252,
      252,  252,  252,  253,  253,  253,  253,  253,  253,  253,
      253,  253,  253,  210,  210,  210,  210,  210,  210,  210,
      210,  210,  210,  210,  210,  210,  210,  210,  210,  210,
      210,  210,  210,  210,  210,  210,  210,  210,  210,  210,

      210,  210,  210,  210,  210,  210,  210,  210,  210,  210
    ) ;


-- copy whatever the last rule matched to the standard output

procedure ECHO is
begin
   if (text_io.is_open(user_output_file)) then
     text_io.put( user_output_file, yytext );
   else
     text_io.put( yytext );
   end if;
end ECHO;

-- enter a start condition.
-- Using procedure requires a () after the ENTER, but makes everything
-- much neater.

procedure ENTER( state : integer ) is
begin
     yy_start := 1 + 2 * state;
end ENTER;

-- action number for EOF rule of a given start state
function YY_STATE_EOF(state : integer) return integer is
begin
     return YY_END_OF_BUFFER + state + 1;
end YY_STATE_EOF;

-- return all but the first 'n' matched characters back to the input stream
procedure yyless(n : integer) is
begin
        yy_ch_buf(yy_cp) := yy_hold_char; -- undo effects of setting up yytext
        yy_cp := yy_bp + n;
        yy_c_buf_p := yy_cp;
        YY_DO_BEFORE_ACTION; -- set up yytext again
end yyless;

-- redefine this if you have something you want each time.
procedure YY_USER_ACTION is
begin
        null;
end;

-- yy_get_previous_state - get the state just before the EOB char was reached

function yy_get_previous_state return yy_state_type is
    yy_current_state : yy_state_type;
    yy_c : short;
    yy_bp : integer := yytext_ptr;
begin
    yy_current_state := yy_start;
    if ( yy_ch_buf(yy_bp-1) = ASCII.LF ) then
	yy_current_state := yy_current_state + 1;
    end if;

    for yy_cp in yytext_ptr..yy_c_buf_p - 1 loop
	yy_c := yy_ec(yy_ch_buf(yy_cp));
	if ( yy_accept(yy_current_state) /= 0 ) then
	    yy_last_accepting_state := yy_current_state;
	    yy_last_accepting_cpos := yy_cp;
	end if;
	while ( yy_chk(yy_base(yy_current_state) + yy_c) /= yy_current_state ) loop
	    yy_current_state := yy_def(yy_current_state);
	    if ( yy_current_state >= 211 ) then
		yy_c := yy_meta(yy_c);
	    end if;
	end loop;
	yy_current_state := yy_nxt(yy_base(yy_current_state) + yy_c);
    end loop;

    return yy_current_state;
end yy_get_previous_state;

procedure yyrestart( input_file : file_type ) is
begin
   open_input(text_io.name(input_file));
end yyrestart;

begin -- of YYLex
<<new_file>>
        -- this is where we enter upon encountering an end-of-file and
        -- yywrap() indicating that we should continue processing

    if ( yy_init ) then
        if ( yy_start = 0 ) then
            yy_start := 1;      -- first start state
        end if;

        -- we put in the '\n' and start reading from [1] so that an
        -- initial match-at-newline will be true.

        yy_ch_buf(0) := ASCII.LF;
        yy_n_chars := 1;

        -- we always need two end-of-buffer characters.  The first causes
        -- a transition to the end-of-buffer state.  The second causes
        -- a jam in that state.

        yy_ch_buf(yy_n_chars) := YY_END_OF_BUFFER_CHAR;
        yy_ch_buf(yy_n_chars + 1) := YY_END_OF_BUFFER_CHAR;

        yy_eof_has_been_seen := false;

        yytext_ptr := 1;
        yy_c_buf_p := yytext_ptr;
        yy_hold_char := yy_ch_buf(yy_c_buf_p);
        yy_init := false;
    end if; -- yy_init

    loop                -- loops until end-of-file is reached


        yy_cp := yy_c_buf_p;

        -- support of yytext
        yy_ch_buf(yy_cp) := yy_hold_char;

        -- yy_bp points to the position in yy_ch_buf of the start of the
        -- current run.
	yy_bp := yy_cp;
	yy_current_state := yy_start;
	if ( yy_ch_buf(yy_bp-1) = ASCII.LF ) then
	    yy_current_state := yy_current_state + 1;
	end if;
	loop
		yy_c := yy_ec(yy_ch_buf(yy_cp));
		if ( yy_accept(yy_current_state) /= 0 ) then
		    yy_last_accepting_state := yy_current_state;
		    yy_last_accepting_cpos := yy_cp;
		end if;
		while ( yy_chk(yy_base(yy_current_state) + yy_c) /= yy_current_state ) loop
		    yy_current_state := yy_def(yy_current_state);
		    if ( yy_current_state >= 211 ) then
			yy_c := yy_meta(yy_c);
		    end if;
		end loop;
		yy_current_state := yy_nxt(yy_base(yy_current_state) + yy_c);
	    yy_cp := yy_cp + 1;
if ( yy_current_state = 210 ) then
    exit;
end if;
	end loop;
	yy_cp := yy_last_accepting_cpos;
	yy_current_state := yy_last_accepting_state;

<<next_action>>
	    yy_act := yy_accept(yy_current_state);
            YY_DO_BEFORE_ACTION;
            YY_USER_ACTION;

        if aflex_debug then  -- output acceptance info. for (-d) debug mode
            text_io.put( Standard_Error, "--accepting rule #" );
            text_io.put( Standard_Error, INTEGER'IMAGE(yy_act) );
            text_io.put_line( Standard_Error, "(""" & yytext & """)");
        end if;


<<do_action>>   -- this label is used only to access EOF actions
            case yy_act is
		when 0 => -- must backtrack
		-- undo the effects of YY_DO_BEFORE_ACTION
		yy_ch_buf(yy_cp) := yy_hold_char;
		yy_cp := yy_last_accepting_cpos;
		yy_current_state := yy_last_accepting_state;
		goto next_action;



when 1 => 
--# line 55 "../ascan.l"
 indented_code := true; 

when 2 => 
--# line 56 "../ascan.l"
 linenum := linenum + 1; ECHO;
				-- treat as a comment;
			

when 3 => 
--# line 59 "../ascan.l"
 linenum := linenum + 1; ECHO; 

when 4 => 
--# line 60 "../ascan.l"
 return SCDECL; 

when 5 => 
--# line 61 "../ascan.l"
 return XSCDECL; 

when 6 => 
--# line 62 "../ascan.l"
 return USCDECL; 

when 7 => 
--# line 64 "../ascan.l"
 return WHITESPACE; 

when 8 => 
--# line 66 "../ascan.l"

			sectnum := 2;
			misc.line_directive_out;
			ENTER(SECT2PROLOG);
			return SECTEND;
			

when 9 => 
--# line 73 "../ascan.l"

			text_io.put( Standard_Error, "old-style lex command at line " );
			int_io.put( Standard_Error, linenum );
			text_io.put( Standard_Error, " ignored:" );
			text_io.new_line( Standard_Error );
			text_io.put( Standard_Error, ASCII.HT );
			text_io.put( Standard_Error, yytext(1..YYLength) );
			linenum := linenum + 1;
			

when 10 => 
--# line 83 "../ascan.l"

			nmstr := vstr(yytext(1..YYLength));
			didadef := false;
			ENTER(PICKUPDEF);
			

--{UNAME}			{ nmstr := vstr(yytext(1..YYLength));
--			  return UNAME;
--			}
when 11 => 
--# line 93 "../ascan.l"
 nmstr := vstr(yytext(1..YYLength));
			  return NAME;
			

when 12 => 
--# line 96 "../ascan.l"
 linenum := linenum + 1;
			  -- allows blank lines in section 1;
			

when 13 => 
--# line 99 "../ascan.l"
 linenum := linenum + 1; return Newline; 

when 14 => 
--# line 100 "../ascan.l"
 misc.synerr( "illegal character" );ENTER(RECOVER);

when 15 => 
--# line 102 "../ascan.l"
 null;
			  -- separates name and definition;
			

when 16 => 
--# line 106 "../ascan.l"

			nmdef := vstr(yytext(1..YYLength));

			i := tstring.len( nmdef );
			while ( i >= tstring.first ) loop
			    if ( (CHAR(nmdef,i) /= ' ') and
				 (CHAR(nmdef,i) /= ASCII.HT) ) then
				exit;
			    end if;
			    i := i - 1;
			end loop;

                        sym.ndinstal( nmstr,
				tstring.slice(nmdef, tstring.first, i) );
			didadef := true;
			

when 17 => 
--# line 123 "../ascan.l"

			if not didadef then
			    misc.synerr( "incomplete name definition" );
			end if;
			ENTER(0);
			linenum := linenum + 1;
			

when 18 => 
--# line 131 "../ascan.l"
 linenum := linenum + 1;
			  ENTER(0);
			  nmstr := vstr(yytext(1..YYLength));
			  return NAME;
			

when 19 => 
yy_ch_buf(yy_cp) := yy_hold_char; -- undo effects of setting up yytext
yy_cp := yy_cp - 1;
yy_c_buf_p := yy_cp;
YY_DO_BEFORE_ACTION; -- set up yytext again
--# line 137 "../ascan.l"

			linenum := linenum + 1;
			ACTION_ECHO;
			MARK_END_OF_PROLOG;
			ENTER(SECT2);
			

when 20 => 
--# line 144 "../ascan.l"
 linenum := linenum + 1; ACTION_ECHO; 

when YY_END_OF_BUFFER +SECT2PROLOG + 1 
 =>
--# line 146 "../ascan.l"
 MARK_END_OF_PROLOG;
			  return End_Of_Input;
			

when 22 => 
--# line 150 "../ascan.l"
 linenum := linenum + 1;
			  -- allow blank lines in sect2;

			-- this rule matches indented lines which
			-- are not comments.
when 23 => 
--# line 155 "../ascan.l"

			misc.synerr("indented code found outside of action");
			linenum := linenum + 1;
			

when 24 => 
--# line 160 "../ascan.l"
 ENTER(SC); return ( '<' ); 

when 25 => 
--# line 161 "../ascan.l"
 return ( '^' );  

when 26 => 
--# line 162 "../ascan.l"
 ENTER(QUOTE); return ( '"' ); 

when 27 => 
yy_ch_buf(yy_cp) := yy_hold_char; -- undo effects of setting up yytext
 yy_cp := yy_bp + 1;
yy_c_buf_p := yy_cp;
YY_DO_BEFORE_ACTION; -- set up yytext again
--# line 163 "../ascan.l"
 ENTER(NUM); return ( '{' ); 

when 28 => 
--# line 164 "../ascan.l"
 ENTER(BRACEERROR); 

when 29 => 
yy_ch_buf(yy_cp) := yy_hold_char; -- undo effects of setting up yytext
 yy_cp := yy_bp + 1;
yy_c_buf_p := yy_cp;
YY_DO_BEFORE_ACTION; -- set up yytext again
--# line 165 "../ascan.l"
 return '$'; 

when 30 => 
--# line 167 "../ascan.l"
 continued_action := true;
			  linenum := linenum + 1;
			  return Newline;
			

when 31 => 
--# line 172 "../ascan.l"
 linenum := linenum + 1; ACTION_ECHO; 

when 32 => 
--# line 174 "../ascan.l"

			-- this rule is separate from the one below because
			-- otherwise we get variable trailing context, so
			-- we can't build the scanner using -f,F

			bracelevel := 0;
			continued_action := false;
			ENTER(ACTION);
			return Newline;
			

when 33 => 
yy_ch_buf(yy_cp) := yy_hold_char; -- undo effects of setting up yytext
yy_cp := yy_cp - 1;
yy_c_buf_p := yy_cp;
YY_DO_BEFORE_ACTION; -- set up yytext again
--# line 185 "../ascan.l"

			bracelevel := 0;
			continued_action := false;
			ENTER(ACTION);
			return Newline;
			

when 34 => 
--# line 192 "../ascan.l"
 linenum := linenum + 1; return Newline; 

when 35 => 
--# line 194 "../ascan.l"
 return EOF_OP; 

when 36 => 
--# line 196 "../ascan.l"

			sectnum := 3;
			ENTER(SECT3);
			return End_Of_Input;
			-- to stop the parser
			

when 37 => 
--# line 203 "../ascan.l"


			nmstr := vstr(yytext(1..YYLength));

			-- check to see if we've already encountered this ccl
                        cclval := sym.ccllookup( nmstr );
			if ( cclval /= 0 ) then
			    yylval := cclval;
			    cclreuse := cclreuse + 1;
			    return PREVCCL;
			else
			    -- we fudge a bit.  We know that this ccl will
			    -- soon be numbered as lastccl + 1 by cclinit
			    sym.cclinstal( nmstr, lastccl + 1 );

			    -- push back everything but the leading bracket
			    -- so the ccl can be rescanned

			    PUT_BACK_STRING(nmstr, 1);

			    ENTER(FIRSTCCL);
			    return '[';
			end if;
			

when 38 => 
--# line 228 "../ascan.l"

			nmstr := vstr(yytext(1..YYLength));
			-- chop leading and trailing brace
			tmpbuf := slice(vstr(yytext(1..YYLength)),
								2, YYLength-1);

			nmdefptr := sym.ndlookup( tmpbuf );
			if ( nmdefptr = NUL ) then
			    misc.synerr( "undefined {name}" );
			else
			    -- push back name surrounded by ()'s
			    unput(')');
			    PUT_BACK_STRING(nmdefptr, 0);
			    unput('(');
			end if;
			

when 39 => 
--# line 245 "../ascan.l"
 tmpbuf := vstr(yytext(1..YYLength));
			  case tstring.CHAR(tmpbuf,1) is
				when '/' => return '/';
				when '|' => return '|';
				when '*' => return '*';
				when '+' => return '+';
				when '?' => return '?';
				when '.' => return '.';
				when '(' => return '(';
				when ')' => return ')';
				when others =>
					misc.aflexerror("error in aflex case");
			  end case;
			

when 40 => 
--# line 259 "../ascan.l"
 tmpbuf := vstr(yytext(1..YYLength));
			  yylval := CHARACTER'POS(CHAR(tmpbuf,1));
			  return CHAR;
			

when 41 => 
--# line 263 "../ascan.l"
 linenum := linenum + 1; return Newline; 

when 42 => 
--# line 266 "../ascan.l"
 return ( ',' ); 

when 43 => 
--# line 267 "../ascan.l"
 ENTER(SECT2); return ( '>' ); 

when 44 => 
yy_ch_buf(yy_cp) := yy_hold_char; -- undo effects of setting up yytext
 yy_cp := yy_bp + 1;
yy_c_buf_p := yy_cp;
YY_DO_BEFORE_ACTION; -- set up yytext again
--# line 268 "../ascan.l"
 ENTER(CARETISBOL); return ( '>' ); 

when 45 => 
--# line 269 "../ascan.l"
 nmstr := vstr(yytext(1..YYLength));
			  return NAME;
			

when 46 => 
--# line 272 "../ascan.l"
 misc.synerr( "bad start condition name" ); 

when 47 => 
--# line 274 "../ascan.l"
 ENTER(SECT2); return '^'; 

when 48 => 
--# line 277 "../ascan.l"
 tmpbuf := vstr(yytext(1..YYLength));
			  yylval := CHARACTER'POS(CHAR(tmpbuf,1));
			  return CHAR;
			

when 49 => 
--# line 281 "../ascan.l"
 ENTER(SECT2); return '"'; 

when 50 => 
--# line 283 "../ascan.l"

			misc.synerr( "missing quote" );
			ENTER(SECT2);
			linenum := linenum + 1;
			return '"';
			

when 51 => 
yy_ch_buf(yy_cp) := yy_hold_char; -- undo effects of setting up yytext
 yy_cp := yy_bp + 1;
yy_c_buf_p := yy_cp;
YY_DO_BEFORE_ACTION; -- set up yytext again
--# line 291 "../ascan.l"
 ENTER(CCL); return '^'; 

when 52 => 
yy_ch_buf(yy_cp) := yy_hold_char; -- undo effects of setting up yytext
 yy_cp := yy_bp + 1;
yy_c_buf_p := yy_cp;
YY_DO_BEFORE_ACTION; -- set up yytext again
--# line 292 "../ascan.l"
 return '^'; 

when 53 => 
--# line 293 "../ascan.l"
 ENTER(CCL); yylval := CHARACTER'POS('-'); return ( CHAR ); 

when 54 => 
--# line 294 "../ascan.l"
 ENTER(CCL);
			  tmpbuf := vstr(yytext(1..YYLength));
			  yylval := CHARACTER'POS(CHAR(tmpbuf,1));
			  return CHAR;
			

when 55 => 
yy_ch_buf(yy_cp) := yy_hold_char; -- undo effects of setting up yytext
 yy_cp := yy_bp + 1;
yy_c_buf_p := yy_cp;
YY_DO_BEFORE_ACTION; -- set up yytext again
--# line 300 "../ascan.l"
 return '-'; 

when 56 => 
--# line 301 "../ascan.l"
 tmpbuf := vstr(yytext(1..YYLength));
			  yylval := CHARACTER'POS(CHAR(tmpbuf,1));
			  return CHAR;
			

when 57 => 
--# line 305 "../ascan.l"
 ENTER(SECT2); return ']'; 

when 58 => 
--# line 308 "../ascan.l"

			yylval := misc.myctoi( vstr(yytext(1..YYLength)) );
			return NUMBER;
			

when 59 => 
--# line 313 "../ascan.l"
 return ','; 

when 60 => 
--# line 314 "../ascan.l"
 ENTER(SECT2); return '}'; 

when 61 => 
--# line 316 "../ascan.l"

			misc.synerr( "bad character inside {}'s" );
			ENTER(SECT2);
			return '}';
			

when 62 => 
--# line 322 "../ascan.l"

			misc.synerr( "missing }" );
			ENTER(SECT2);
			linenum := linenum + 1;
			return '}';
			

when 63 => 
--# line 330 "../ascan.l"
 misc.synerr( "bad name in {}'s" ); ENTER(SECT2); 

when 64 => 
--# line 331 "../ascan.l"
 misc.synerr( "missing }" );
			  linenum := linenum + 1;
			  ENTER(SECT2);
			

when 65 => 
--# line 336 "../ascan.l"
 bracelevel := bracelevel + 1; 

when 66 => 
--# line 337 "../ascan.l"
 bracelevel := bracelevel - 1; 

when 67 => 
--# line 338 "../ascan.l"
 ACTION_ECHO; 

when 68 => 
--# line 339 "../ascan.l"
 ACTION_ECHO; 

when 69 => 
--# line 340 "../ascan.l"
 linenum := linenum + 1; ACTION_ECHO; 

when 70 => 
--# line 341 "../ascan.l"
 ACTION_ECHO;
				  -- character constant;
			

when 71 => 
--# line 345 "../ascan.l"
 ACTION_ECHO; ENTER(ACTION_STRING); 

when 72 => 
--# line 347 "../ascan.l"

			linenum := linenum + 1;
			ACTION_ECHO;
			if bracelevel = 0 then
			    text_io.new_line ( temp_action_file );
			    ENTER(SECT2);
	                end if;
			

when 73 => 
--# line 355 "../ascan.l"
 ACTION_ECHO; 

when 74 => 
--# line 357 "../ascan.l"
 ACTION_ECHO; 

when 75 => 
--# line 358 "../ascan.l"
 ACTION_ECHO; 

when 76 => 
--# line 359 "../ascan.l"
 linenum := linenum + 1; ACTION_ECHO; 

when 77 => 
--# line 360 "../ascan.l"
 ACTION_ECHO; ENTER(ACTION); 

when 78 => 
--# line 361 "../ascan.l"
 ACTION_ECHO; 

when 79 => 
--# line 364 "../ascan.l"

			yylval := CHARACTER'POS(misc.myesc( vstr(yytext(1..YYLength)) ));
			return ( CHAR );
			

when 80 => 
--# line 369 "../ascan.l"

			yylval := CHARACTER'POS(misc.myesc( vstr(yytext(1..YYLength)) ));
			ENTER(CCL);
			return CHAR;
			

when 81 => 
--# line 376 "../ascan.l"
 if check_yylex_here then
				return End_Of_Input;
			  else
				ECHO;
			  end if;
			

when 82 => 
--# line 382 "../ascan.l"
raise AFLEX_SCANNER_JAMMED;
when YY_END_OF_BUFFER + INITIAL + 1 |
YY_END_OF_BUFFER + SECT2 + 1 |
YY_END_OF_BUFFER + SECT3 + 1 |
YY_END_OF_BUFFER + PICKUPDEF + 1 |
YY_END_OF_BUFFER + SC + 1 |
YY_END_OF_BUFFER + CARETISBOL + 1 |
YY_END_OF_BUFFER + NUM + 1 |
YY_END_OF_BUFFER + QUOTE + 1 |
YY_END_OF_BUFFER + FIRSTCCL + 1 |
YY_END_OF_BUFFER + CCL + 1 |
YY_END_OF_BUFFER + ACTION + 1 |
YY_END_OF_BUFFER + RECOVER + 1 |
YY_END_OF_BUFFER + BRACEERROR + 1 |
YY_END_OF_BUFFER + ACTION_STRING + 1 => 
    return End_Of_Input;
                when YY_END_OF_BUFFER =>
                    -- undo the effects of YY_DO_BEFORE_ACTION
                    yy_ch_buf(yy_cp) := yy_hold_char;

                    yytext_ptr := yy_bp;

                    case yy_get_next_buffer is
                        when EOB_ACT_END_OF_FILE =>
                            begin
                            if ( yywrap ) then
                                -- note: because we've taken care in
                                -- yy_get_next_buffer() to have set up yytext,
                                -- we can now set up yy_c_buf_p so that if some
                                -- total hoser (like aflex itself) wants
                                -- to call the scanner after we return the
                                -- End_Of_Input, it'll still work - another
                                -- End_Of_Input will get returned.

                                yy_c_buf_p := yytext_ptr;

                                yy_act := YY_STATE_EOF((yy_start - 1) / 2);

                                goto do_action;
                            else
                                --  start processing a new file
                                yy_init := true;
                                goto new_file;
                            end if;
                            end;
                        when EOB_ACT_RESTART_SCAN =>
                            yy_c_buf_p := yytext_ptr;
                            yy_hold_char := yy_ch_buf(yy_c_buf_p);
                        when EOB_ACT_LAST_MATCH =>
                            yy_c_buf_p := yy_n_chars;
                            yy_current_state := yy_get_previous_state;

                            yy_cp := yy_c_buf_p;
                            yy_bp := yytext_ptr;
                            goto next_action;
                        when others => null;
                        end case; -- case yy_get_next_buffer()
                when others =>
                    text_io.put( "action # " );
                    text_io.put( INTEGER'IMAGE(yy_act) );
                    text_io.new_line;
                    raise AFLEX_INTERNAL_ERROR;
            end case; -- case (yy_act)
        end loop; -- end of loop waiting for end of file
end YYLex;
--# line 382 "../ascan.l"
begin
    if (call_yylex) then
    	toktype := YYLex;
    	call_yylex := false;
    	return toktype;
    end if;

    if ( eofseen ) then
	toktype := End_Of_Input;
    else
	toktype := YYLex;
    end if;
-- this tracing code allows easy tracing of aflex runs
if (trace) then
text_io.new_line(Standard_Error);
text_io.put(Standard_Error, "toktype = :" );
text_io.put(Standard_Error, Token'image(toktype));
text_io.put_line(Standard_Error, ":" );
end if;

    if ( toktype = End_Of_Input ) then
	eofseen := true;

	if sectnum = 1 then
	    misc.synerr(  "unexpected EOF" );
	    sectnum := 2;
	    toktype := SECTEND;
	else
	    if ( sectnum = 2 ) then
	    	sectnum := 3;
	    	toktype := SECTEND;
	    end if;
    	end if;
    end if;
    
    if trace then
	if beglin then
	    int_io.put( Standard_Error, num_rules + 1 );
	    text_io.put( Standard_Error, ASCII.HT );
	    beglin := false;
    	end if;

	case toktype is
	    when '<' | '>'|'^'|'$'|'"'|'['|']'|'{'|'}'|'|'|'('|
    	    	 ')'|'-'|'/'|'?'|'.'|'*'|'+'|',' =>
		text_io.put( Standard_Error, Token'image(toktype) );

	    when NEWLINE =>
		text_io.new_line(Standard_Error);
		if ( sectnum = 2 ) then
		    beglin := true;
    	    	end if;

	    when SCDECL =>
		text_io.put( Standard_Error, "%s" );

	    when XSCDECL =>
   		text_io.put( Standard_Error, "%x" );

	    when WHITESPACE =>
       		text_io.put( Standard_Error, " " );

	    when SECTEND =>
       		text_io.put_line( Standard_Error, "%%" );	   

		-- we set beglin to be true so we'll start
		-- writing out numbers as we echo rules.  aflexscan() has
		-- already assigned sectnum

		if ( sectnum = 2 ) then
		    beglin := true;
    	    	end if;

	    when NAME =>
		text_io.put( Standard_Error, ''' );
		text_io.put( Standard_Error, YYText);
		text_io.put( Standard_Error, ''' );

	    when CHAR =>
	    	if ( (yylval < CHARACTER'POS(' ')) or
		     (yylval = CHARACTER'POS(ASCII.DEL)) ) then
		    text_io.put( Standard_Error, '\' );
		    int_io.put( Standard_Error, yylval );
    		    text_io.put( Standard_Error, '\' );
		else
		    text_io.put( Standard_Error, Token'image(toktype) );
    	    	end if;

	    when NUMBER =>
    	    	int_io.put( Standard_Error, yylval );

	    when PREVCCL =>
		text_io.put( Standard_Error, '[' );
   	    	int_io.put( Standard_Error, yylval );
		text_io.put( Standard_Error, ']' );		

    	    when End_Of_Input =>
    	    	text_io.put( Standard_Error, "End Marker" );

	    when others =>
	    	text_io.put( Standard_Error, "Something weird:" );
		text_io.put_line( Standard_Error, Token'image(toktype));
    	end case;
    end if;
	    
    return toktype;

end get_token;
end scanner;

