-- Copyright (c) 1990 Regents of the University of California.
-- All rights reserved.
--
-- This software was developed by John Self of the Arcadia project
-- at the University of California, Irvine.
--
-- Redistribution and use in source and binary forms are permitted
-- provided that the above copyright notice and this paragraph are
-- duplicated in all such forms and that any documentation,
-- advertising materials, and other materials related to such
-- distribution and use acknowledge that the software was developed
-- by the University of California, Irvine.  The name of the
-- University may not be used to endorse or promote products derived
-- from this software without specific prior written permission.
-- THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
-- IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
-- WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.

-- TITLE skeleton manager
-- AUTHOR: John Self (UCI)
-- DESCRIPTION outputs skeleton sections when called by gen.
-- NOTES allows use of internal or external skeleton
-- $Header: /dc/uc/self/arcadia/aflex/ada/src/RCS/skeleton_managerB.a,v 1.19 1992/12/29 22:46:15 self Exp self $

with Misc, Misc_Defs, Text_Io, File_String;
package body Skeleton_Manager is
   use File_String; -- to save having to type FILE_STRING 177 times
   Use_External_Skeleton : Boolean := False;
   -- are we using an external skelfile?
   Current_Line : Integer := 1;
   type File_Array is array (Positive range <>) of File_String.Vstring;

   Skel_Template : access File_Array;

   procedure Initialize (Use_Text_Io : in Boolean) is
      function Get_Text_Io return String is
      begin
         if Use_Text_Io then
            return "with Text_IO; use Text_IO;";
         else
            return "";
         end if;
      end Get_Text_Io;
   begin
      Skel_Template :=
        new File_Array'
          (
      -- START OF SKELETON
      -- START OF S1
      Vstr
             ("--  Warning: This lexical scanner is automatically generated by AFLEX."),
           Vstr
             ("--           It is useless to modify it. Change the "".Y"" & "".L"" files instead."),
           Vstr (Get_Text_Io),
           Vstr ("%% user's code up to the double pound goes right here"),
-- BEGIN S2

           Vstr ("   function YYLex return Token is"),
           Vstr ("      subtype Short is Integer range -32768 .. 32767;"),
           Vstr ("      yy_act : Integer;"), Vstr ("      yy_c   : Short;"),
           Vstr (""), Vstr ("      --  returned upon end-of-file"),
           Vstr ("      YY_END_TOK : constant Integer := 0;"),
           Vstr ("%% tables get generated here."),
-- BEGIN S3
      Vstr (""),
           Vstr
             ("      --  copy whatever the last rule matched to the standard output"),
           Vstr (""), Vstr ("-- ECHO CODES :"),
           Vstr ("      procedure ECHO is"), Vstr ("      begin"),
           Vstr ("         if Text_IO.Is_Open (user_output_file) then"),
           Vstr ("            Text_IO.Put (user_output_file, YYText);"),
           Vstr ("         else"), Vstr ("            Text_IO.Put (YYText);"),
           Vstr ("         end if;"), Vstr ("      end ECHO;"),
           Vstr ("-- END OF ECHO CODES."), Vstr (""),
           Vstr ("      --  enter a start condition."),
           Vstr
             ("      --  Using procedure requires a () after the ENTER, but makes everything"),
           Vstr ("      --  much neater."), Vstr (""),
           Vstr ("      procedure ENTER (state : Integer) is"),
           Vstr ("      begin"), Vstr ("         yy_start := 1 + 2 * state;"),
           Vstr ("      end ENTER;"), Vstr (""),
           Vstr
             ("      --  action number for EOF rule of a given start state"),
           Vstr
             ("      function YY_STATE_EOF (state : Integer) return Integer is"),
           Vstr ("      begin"),
           Vstr ("         return YY_END_OF_BUFFER + state + 1;"),
           Vstr ("      end YY_STATE_EOF;"), Vstr (""),
           Vstr
             ("      --  return all but the first 'n' matched characters back to the input stream"),
           Vstr ("      procedure yyless (n : Integer) is"),
           Vstr ("      begin"),
           Vstr
             ("         yy_ch_buf (yy_cp) := yy_hold_char; --  undo effects of setting up yytext"),
           Vstr ("         yy_cp := yy_bp + n;"),
           Vstr ("         yy_c_buf_p := yy_cp;"),
           Vstr ("         YY_DO_BEFORE_ACTION; -- set up yytext again"),
           Vstr ("      end yyless;"), Vstr (""),
           Vstr
             ("      --  redefine this if you have something you want each time."),
           Vstr ("      procedure YY_USER_ACTION is"), Vstr ("      begin"),
           Vstr ("         null;"), Vstr ("      end YY_USER_ACTION;"),
           Vstr (""),
           Vstr
             ("      --  yy_get_previous_state - get the state just before the EOB char was reached"),
           Vstr (""),
           Vstr
             ("      function yy_get_previous_state return yy_state_type is"),
           Vstr ("         yy_current_state : yy_state_type;"),
           Vstr ("         yy_c : Short;"),
           Vstr ("%% a local declaration of yy_bp goes here if bol_needed"),
           Vstr ("      begin"),
           Vstr
             ("%% code to get the start state into yy_current_state goes here"),
-- BEGIN S3A

           Vstr (""),
           Vstr ("         for yy_cp in yytext_ptr .. yy_c_buf_p - 1 loop"),
           Vstr ("%% code to find the next state goes here"),
-- BEGIN S4

           Vstr ("         end loop;"), Vstr (""),
           Vstr ("         return yy_current_state;"),
           Vstr ("      end yy_get_previous_state;"), Vstr (""),
           Vstr ("      procedure yyrestart (input_file : File_Type) is"),
           Vstr ("      begin"),
           Vstr ("         Open_Input (Text_IO.Name (input_file));"),
           Vstr ("      end yyrestart;"), Vstr (""),
           Vstr ("   begin -- of YYLex"), Vstr ("      <<new_file>>"),
           Vstr
             ("      --  this is where we enter upon encountering an end-of-file and"),
           Vstr
             ("      --  yyWrap () indicating that we should continue processing"),
           Vstr (""), Vstr ("      if yy_init then"),
           Vstr ("         if yy_start = 0 then"),
           Vstr ("            yy_start := 1;      -- first start state"),
           Vstr ("         end if;"), Vstr (""),
           Vstr
             ("         --  we put in the '\n' and start reading from [1] so that an"),
           Vstr ("         --  initial match-at-newline will be true."),
           Vstr (""), Vstr ("         yy_ch_buf (0) := ASCII.LF;"),
           Vstr ("         yy_n_chars := 1;"), Vstr (""),
           Vstr
             ("         --  we always need two end-of-buffer characters. The first causes"),
           Vstr
             ("         --  a transition to the end-of-buffer state. The second causes"),
           Vstr ("         --  a jam in that state."), Vstr (""),
           Vstr ("         yy_ch_buf (yy_n_chars) := YY_END_OF_BUFFER_CHAR;"),
           Vstr
             ("         yy_ch_buf (yy_n_chars + 1) := YY_END_OF_BUFFER_CHAR;"),
           Vstr (""), Vstr ("         yy_eof_has_been_seen := False;"),
           Vstr (""), Vstr ("         yytext_ptr := 1;"),
           Vstr ("         yy_c_buf_p := yytext_ptr;"),
           Vstr ("         yy_hold_char := yy_ch_buf (yy_c_buf_p);"),
           Vstr ("         yy_init := False;"), Vstr ("-- UMASS CODES :"),
           Vstr ("         --   Initialization"),
           Vstr ("         tok_begin_line := 1;"),
           Vstr ("         tok_end_line := 1;"),
           Vstr ("         tok_begin_col := 0;"),
           Vstr ("         tok_end_col := 0;"),
           Vstr ("         token_at_end_of_line := False;"),
           Vstr ("         line_number_of_saved_tok_line1 := 0;"),
           Vstr ("         line_number_of_saved_tok_line2 := 0;"),
           Vstr ("-- END OF UMASS CODES."), Vstr ("      end if; -- yy_init"),
           Vstr (""),
           Vstr
             ("      loop                -- loops until end-of-file is reached"),
           Vstr (""), Vstr ("-- UMASS CODES :"),
           Vstr
             ("         --    if last matched token is end_of_line, we must"),
           Vstr
             ("         --    update the token_end_line and reset tok_end_col."),
           Vstr ("         if Token_At_End_Of_Line then"),
           Vstr ("            Tok_End_Line := Tok_End_Line + 1;"),
           Vstr ("            Tok_End_Col := 0;"),
           Vstr ("            Token_At_End_Of_Line := False;"),
           Vstr ("         end if;"), Vstr ("-- END OF UMASS CODES."),
           Vstr (""), Vstr ("         yy_cp := yy_c_buf_p;"), Vstr (""),
           Vstr ("         --  support of yytext"),
           Vstr ("         yy_ch_buf (yy_cp) := yy_hold_char;"), Vstr (""),
           Vstr
             ("         --  yy_bp points to the position in yy_ch_buf of the start of the"),
           Vstr ("         --  current run."), Vstr ("%%"),
-- BEGIN S5
      Vstr (""),
           Vstr ("   <<next_action>>"),
           Vstr ("%% call to gen_find_action goes here"),
-- BEGIN S6

           Vstr ("         YY_DO_BEFORE_ACTION;"),
           Vstr ("         YY_USER_ACTION;"), Vstr (""),
           Vstr
             ("         if aflex_debug then  -- output acceptance info. for (-d) debug mode"),
           Vstr
             ("            Text_IO.Put (Standard_Error, ""  -- Aflex.YYLex accept rule #"");"),
           Vstr
             ("            Text_IO.Put (Standard_Error, Integer'Image (yy_act));"),
           Vstr
             ("            Text_IO.Put_Line (Standard_Error, ""("""""" & YYText & """""")"");"),
           Vstr ("         end if;"), Vstr (""), Vstr ("-- UMASS CODES :"),
           Vstr
             ("         --   Update tok_begin_line, tok_end_line, tok_begin_col and tok_end_col"),
           Vstr ("         --   after matching the token."),
           Vstr
             ("         if yy_act /= YY_END_OF_BUFFER and then yy_act /= 0 then"),
           Vstr
             ("            -- Token are matched only when yy_act is not yy_end_of_buffer or 0."),
           Vstr ("            Tok_Begin_Line := Tok_End_Line;"),
           Vstr ("            Tok_Begin_Col := Tok_End_Col + 1;"),
           Vstr
             ("            Tok_End_Col := Tok_Begin_Col + yy_cp - yy_bp - 1;"),
           Vstr ("            if yy_ch_buf ( yy_bp ) = ASCII.LF then"),
           Vstr ("               Token_At_End_Of_Line := True;"),
           Vstr ("            end if;"), Vstr ("         end if;"),
           Vstr ("-- END OF UMASS CODES."), Vstr (""),
           Vstr
             ("   <<do_action>>   -- this label is used only to access EOF actions"),
           Vstr ("         case yy_act is"), Vstr ("%% actions go here"),
-- BEGIN S7

           Vstr ("         when YY_END_OF_BUFFER =>"),
           Vstr ("            --  undo the effects of YY_DO_BEFORE_ACTION"),
           Vstr ("            yy_ch_buf (yy_cp) := yy_hold_char;"), Vstr (""),
           Vstr ("            yytext_ptr := yy_bp;"), Vstr (""),
           Vstr ("            case yy_get_next_buffer is"),
           Vstr ("               when EOB_ACT_END_OF_FILE =>"),
-- VSTR("                            begin"),

           Vstr ("                  if yyWrap then"),
           Vstr ("                     --  note: because we've taken care in"),
           Vstr
             ("                     --  yy_get_next_buffer() to have set up yytext,"),
           Vstr
             ("                     --  we can now set up yy_c_buf_p so that if some"),
           Vstr
             ("                     --  total hoser (like aflex itself) wants"),
           Vstr
             ("                     --  to call the scanner after we return the"),
           Vstr
             ("                     --  End_Of_Input, it'll still work - another"),
           Vstr ("                     --  End_Of_Input will get returned."),
           Vstr (""), Vstr ("                     yy_c_buf_p := yytext_ptr;"),
           Vstr (""),
           Vstr
             ("                     yy_act := YY_STATE_EOF ((yy_start - 1) / 2);"),
           Vstr (""), Vstr ("                     goto do_action;"),
           Vstr ("                  else"),
           Vstr ("                     --  start processing a new file"),
           Vstr ("                     yy_init := True;"),
           Vstr ("                     goto new_file;"),
           Vstr ("                  end if;"),
-- VSTR("                            end;"),
      Vstr (""),
           Vstr ("               when EOB_ACT_RESTART_SCAN =>"),
           Vstr ("                  yy_c_buf_p := yytext_ptr;"),
           Vstr ("                  yy_hold_char := yy_ch_buf (yy_c_buf_p);"),
           Vstr (""), Vstr ("               when EOB_ACT_LAST_MATCH =>"),
           Vstr ("                  yy_c_buf_p := yy_n_chars;"),
           Vstr
             ("                  yy_current_state := yy_get_previous_state;"),
           Vstr ("                  yy_cp := yy_c_buf_p;"),
           Vstr ("                  yy_bp := yytext_ptr;"),
           Vstr ("                  goto next_action;"),
           Vstr ("            end case; --  case yy_get_next_buffer()"),
           Vstr (""), Vstr ("         when others =>"),
           Vstr ("            Text_IO.Put (""action # "");"),
           Vstr ("            Text_IO.Put (Integer'Image (yy_act));"),
           Vstr ("            Text_IO.New_Line;"),
           Vstr ("            raise AFLEX_INTERNAL_ERROR;"),
           Vstr ("         end case; --  case (yy_act)"),
           Vstr ("      end loop; --  end of loop waiting for end of file"),
           Vstr ("   end YYLex;"), Vstr ("%%"),
           Vstr ("ERROR tried to output beyond end of skeleton file")
-- END OF SKELETON
         );
   end Initialize;

   -- set_external_skeleton
   --
   -- DESCRIPTION
   -- sets flag so we know to use an external skelfile

   procedure Set_External_Skeleton is
   begin
      Use_External_Skeleton := True;
   end Set_External_Skeleton;

   procedure Get_Internal (Buffer : in out File_String.Vstring) is
   begin
      Buffer       := Skel_Template (Current_Line);
      Current_Line := Current_Line + 1;
   end Get_Internal;

   procedure Get_External (Buffer : in out File_String.Vstring) is
   begin
      File_String.Get_Line (Misc_Defs.Skelfile, Buffer);
   end Get_External;

   -- end_of_skeleton
   --
   -- DESCRIPTION
   -- returns true if there are no more lines left to output in the skeleton

   function End_Of_Skeleton return Boolean is
   begin
      if Use_External_Skeleton then

         -- we're using an external skelfile
         return Text_Io.End_Of_File (Misc_Defs.Skelfile);
      else

         -- internal skeleton
         return Current_Line > Skel_Template'Last;
      end if;
   end End_Of_Skeleton;

   procedure Get_File_Line (Buffer : in out File_String.Vstring) is
   begin
      if Use_External_Skeleton then
         Get_External (Buffer);
      else
         Get_Internal (Buffer);
      end if;
   end Get_File_Line;

   -- skelout - write out one section of the skeleton file
   --
   -- DESCRIPTION
   --    Either outputs internal skeleton, or from a file with "%%" dividers
   --    if a skeleton file is specified by the user.
   --    Copies from skelfile to stdout until a line beginning with "%%" or
   --    EOF is found.

   procedure Skelout is
      Buf : File_String.Vstring;
      -- UMASS CODES :
      Umass_Codes : Boolean := False;
      -- Indicates whether or not current line of the template
      -- is the Umass codes.
      -- END OF UMASS CODES.
      Echo_Codes  : Boolean := False;
      Ignore_Line : Boolean := False;
      YYLex_Name  : constant String := Misc.Get_YYLex_Name;
   begin
      while not End_Of_Skeleton loop
         Get_File_Line (Buf);
         if
           ((File_String.Len (Buf) >= 2)
            and then
            ((File_String.Char (Buf, 1) = '%') and
             (File_String.Char (Buf, 2) = '%')))
         then
            exit;
         else
            -- UMASS CODES :
            --   In the template, the codes between "-- UMASS CODES : " and
            --   "-- END OF UMASS CODES." are specific to be used by Ayacc
            --   extension. Ayacc extension has more power in error recovery.
      --   So we generate those codes only when Ayacc_Extension_Flag is True.
            if File_String.Str (Buf) = "-- UMASS CODES :" then
               Umass_Codes := True;
               Ignore_Line := True;
            elsif File_String.Str (Buf) = "-- ECHO CODES :" then
               Echo_Codes  := True;
               Ignore_Line := True;
            end if;

            if Umass_Codes and not Misc_Defs.Ayacc_Extension_Flag then
               Ignore_Line := True;
            end if;
            if Echo_Codes and Misc_Defs.Spprdflt then
               Ignore_Line := True;
            end if;

            if File_String.Str (Buf) = "-- END OF UMASS CODES." then
               Umass_Codes := False;
               Ignore_Line := True;
            end if;

            if File_String.Str (Buf) = "-- END OF ECHO CODES." then
               Echo_Codes  := False;
               Ignore_Line := True;
            end if;

            if not Ignore_Line then
               if YYLex_Name'Length = 0 then
                  File_String.Put_Line (Buf);
               elsif File_String.Str (Buf) = "   function YYLex return Token is" then
                  File_String.Put_Line (File_String.Vstr (Misc.Get_YYLex_Declaration));
               elsif File_String.Str (Buf) = "   end YYLex;" then
                  File_String.Put_Line (File_String.Vstr ("   end " & YYLex_Name & ";"));
               else
                  File_String.Put_Line (Buf);
               end if;
            end if;
            Ignore_Line := False;
         end if;
      end loop;
   end Skelout;

end Skeleton_Manager;
