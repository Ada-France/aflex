
pragma Warnings (Off);
with Ada.Text_Io;
with misc_defs, misc, sym, parse_tokens, int_io;
with tstring, ascan_dfa, ascan_io;
with Template_Manager;
use misc_defs, parse_tokens, tstring;
use ascan_dfa, ascan_io;
package body scanner is

   use Ada;
   use Ada.Text_IO;

   beglin : Boolean := False;
   i, bracelevel: Integer;
   Code_Block_File   : Ada.Text_IO.File_Type;
   Code_Block_Start  : Natural;
   Code_Block_Active : Boolean := False;

   procedure Open_Code_Block (Name : in String) is
   begin
      Code_Block_Start := YYlineno + 1;
      Code_Block_Active := True;
      Ada.Text_IO.Open (Code_Block_File, Ada.Text_IO.Append_File, Name);

   exception
      when Name_Error =>
         Ada.Text_IO.Create (Code_Block_File, Ada.Text_IO.Append_File, Name);
   end Open_Code_Block;

   function get_token return Token is
      toktype : Token;
      didadef, indented_code : Boolean;
      cclval : Integer;
      nmdefptr : vstring;
      nmdef, tmpbuf : vstring;

      procedure ACTION_ECHO is
      begin
         Ada.Text_IO.Put (temp_action_file, yytext(1 .. YYLength));
      end ACTION_ECHO;

      procedure MARK_END_OF_PROLOG is
      begin
         Ada.Text_IO.Put (temp_action_file, "%%%% end of prolog");
         Ada.Text_IO.New_Line (temp_action_file);
      end MARK_END_OF_PROLOG;

      procedure PUT_BACK_STRING(str : vstring; start : Integer) is
      begin
         for i in reverse start + 1 .. tstring.len (str) loop
            unput (CHAR (str, i));
         end loop;
      end PUT_BACK_STRING;

      function check_yylex_here return Boolean is
      begin
         return ( (yytext'length >= 2) and then
                ((yytext(1) = '#') and (yytext(2) = '#')));
      end check_yylex_here;


   function YYLex return Token is
      subtype Short is Integer range -32768 .. 32767;

      --  returned upon end-of-file
      YY_END_TOK : constant Integer := 0;
      subtype yy_state_type is Integer;
      YY_END_OF_BUFFER : constant := 98;
      INITIAL : constant := 0;
      SECT2 : constant := 1;
      SECT2PROLOG : constant := 2;
      SECT3 : constant := 3;
      PICKUPDEF : constant := 4;
      SC : constant := 5;
      CARETISBOL : constant := 6;
      NUM : constant := 7;
      QUOTE : constant := 8;
      FIRSTCCL : constant := 9;
      CCL : constant := 10;
      ACTION : constant := 11;
      RECOVER : constant := 12;
      BRACEERROR : constant := 13;
      CODEBLOCK_MATCH_BRACE : constant := 14;
      ACTION_STRING : constant := 15;
      YYDECL_STRING : constant := 16;
      yy_accept : constant array (0 .. 277) of Short :=
          (0,
        0,    0,    0,    0,    0,    0,   91,   91,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,   24,   24,   98,   23,   10,   22,   20,    1,
       21,   23,   23,   23,   18,   50,   42,   43,   36,   50,
       49,   34,   50,   50,   50,   42,   32,   50,   50,   35,
       97,   30,   91,   91,   26,   25,   27,   56,   97,   52,
       53,   55,   57,   71,   72,   69,   68,   70,   58,   60,
       59,   58,   64,   63,   64,   64,   66,   66,   66,   67,
       77,   82,   81,   83,   77,   83,   78,   75,   76,   97,

       28,   74,   73,   95,   94,   97,   95,   93,   92,   84,
       86,   87,   88,   24,   10,   22,   20,    0,    0,    1,
       21,    0,    0,    2,    0,   15,    0,    7,    4,    6,
        5,    0,    0,   18,   42,   43,    0,   39,    0,    0,
        0,   89,   89,   38,   37,   38,    0,   42,   32,    0,
        0,   46,    0,    0,   30,   29,   91,   91,   26,   25,
       54,   55,   68,   90,   90,   61,   62,   65,   77,    0,
       80,    0,   77,   78,    0,   28,   95,   94,   84,   85,
       24,   19,   11,    0,   15,    0,    0,    0,   16,    0,
        0,    0,    0,    0,    3,    0,   40,    0,   47,    0,

       89,   38,   38,   48,    0,    0,    0,   46,    0,   41,
       90,   77,   79,    0,   19,    0,   17,    0,   16,   16,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,   16,    0,    0,    6,    0,    0,    0,
        0,    0,    0,    0,    0,   33,    0,   33,    0,   33,
        0,    4,    0,    0,    0,    9,    0,    0,    7,    0,
        0,    0,    0,   45,    0,    8,    0,   12,    0,   14,
        0,   12,   14,    0,   13,   13,    0
       );

      yy_ec : constant array (ASCII.NUL .. Character'Last) of Short := (0,
        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
        1,    4,    5,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    6,    1,    7,    8,    9,   10,    1,   11,   12,
       12,   12,   12,   13,   14,   15,   16,   17,   17,   17,
       17,   17,   17,   17,   17,   17,   17,    1,    1,   18,
       19,   20,   12,    1,   26,   27,   28,   29,   30,   31,
       27,   27,   32,   27,   27,   33,   27,   34,   35,   36,
       27,   37,   38,   39,   40,   41,   42,   43,   44,   27,
       21,   22,   23,   24,   25,    1,   26,   27,   28,   29,

       30,   31,   27,   27,   32,   27,   27,   33,   27,   34,
       35,   36,   27,   37,   38,   39,   40,   41,   42,   43,
       44,   27,   45,   46,   47,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,

        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1, others => 1

       );

      yy_meta : constant array (0 .. 47) of Short :=
          (0,
        1,    2,    3,    2,    4,    2,    5,    1,    1,    1,
        6,    1,    1,    7,    8,    6,    7,    1,    9,    1,
        4,   10,   11,    1,   12,   13,   13,   13,   13,   13,
       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
       13,   13,   13,   13,   14,    1,   15
       );

      yy_base : constant array (0 .. 325) of Short :=
          (0,
        0,   47,   93,  138,  789,  788,  787,  786,  114,  119,
      184,    0,  764,  763,  116,  229,  121,  124,  152,  155,
      158,  230,  276,    0,  783,  782,  104,  110,  321,  322,
      127,  232,  781,  780,  773, 1478,  234, 1478,   91,  245,
     1478,  768,  369,  754,  117, 1478,  415, 1478, 1478,  162,
     1478,  741,  736,  740,  461,  507, 1478,  746,  738, 1478,
      745,    0,  742, 1478,    0,  169, 1478, 1478, 1478, 1478,
      720,    0, 1478, 1478, 1478, 1478,  724, 1478, 1478, 1478,
     1478,  723, 1478, 1478,  722,  724, 1478,    0,  718, 1478,
        0, 1478, 1478,   90,  675, 1478,    0, 1478, 1478,  682,

     1478, 1478, 1478,    0, 1478,  679, 1478, 1478, 1478,    0,
     1478, 1478,    0,    0,  254, 1478,  163,    0,  662,  259,
     1478,  664,  673, 1478,  669,    0,  510,  513,  131,  235,
      228,  230,  671,  253,  520, 1478,  670, 1478,  640,   81,
      311, 1478,  651,    0, 1478,  553,  640,  525, 1478,  585,
      326,    0,  595,  559,    0, 1478,  558, 1478,    0,  329,
     1478,    0,  543, 1478,  542, 1478, 1478, 1478,    0,  319,
     1478,    0,  600,    0,  543, 1478,    0, 1478,    0, 1478,
        0,  522,  519,  522,    0,  528,  646,  239,  344,  326,
      414,  416,  417,  441, 1478,  439, 1478,  401, 1478,  330,

      416,    0,    0, 1478,  416,  335,  421,    0,  426, 1478,
      411,    0, 1478,  691,  345,  348, 1478,  653,  352,  355,
      419,  514,  421,  512,  527,  532,  428,  538,  308,  409,
      267,  264,  252,  435,  529,  645,  536,  647,  541,  652,
      681,  654,  230,  314,  240, 1478,  132, 1478,  123, 1478,
      688,  666,  710,  714,  713,  671,  715,   78,  717,  719,
      724,  725,  730, 1478,  727,  760,  763,  443,  770,  539,
      775,  550,  659,  776,  660,  665, 1478,  821,  836,  851,
      866,  881,  896,  911,  926,  941,  956,  971,  986, 1001,
     1010, 1023, 1032, 1045, 1060, 1075, 1090, 1105, 1120, 1135,

     1144, 1157, 1172, 1187, 1202, 1213, 1222, 1235, 1250, 1263,
     1278, 1293,  351, 1308, 1322, 1336, 1351, 1366, 1380, 1395,
     1404, 1417, 1432, 1447, 1462
       );

      yy_def : constant array (0 .. 325) of Short :=
          (0,
      277,  277,  278,  278,  279,  279,  280,  280,  281,  281,
      277,   11,  282,  282,  283,  283,  284,  284,  285,  285,
      286,  286,  277,   23,  287,  287,  282,  282,  288,  288,
      289,  289,  290,  290,  277,  277,  277,  277,  291,  277,
      277,  292,  277,  277,  293,  277,  277,  277,  277,  277,
      277,  277,  294,  295,  277,  296,  277,  277,  277,  277,
      297,  298,  299,  277,  300,  277,  277,  277,  277,  277,
      277,  301,  277,  277,  277,  277,  277,  277,  277,  277,
      277,  295,  277,  277,  302,  303,  277,  304,  295,  277,
      305,  277,  277,  306,  305,  277,  307,  277,  277,  308,

      277,  277,  277,  309,  277,  277,  277,  277,  277,  310,
      277,  277,  311,  312,  277,  277,  291,  313,  277,  277,
      277,  277,  292,  277,  277,  314,  315,  315,  128,  128,
      128,  128,  316,  293,  277,  277,  317,  277,  277,  294,
      294,  277,  277,  318,  277,  318,  277,  296,  277,  277,
      317,  319,  320,  297,  298,  277,  299,  277,  300,  277,
      277,  301,  277,  277,  277,  277,  277,  277,  305,  306,
      277,  306,  277,  307,  308,  277,  309,  277,  310,  277,
      312,  321,  277,  322,  314,  277,  322,  128,  277,  128,
      128,  128,  128,  316,  277,  317,  277,  277,  277,  294,

      277,  318,  146,  277,  277,  320,  317,  319,  320,  277,
      277,  173,  277,  173,  321,  322,  277,  322,  322,  277,
      128,  128,  128,  128,  128,  128,  128,  128,  277,  294,
      323,  324,  325,  322,  128,  128,  128,  128,  128,  128,
      128,  128,  277,  294,  323,  277,  324,  277,  325,  277,
      128,  128,  128,  128,  128,  128,  128,  277,  128,  128,
      128,  315,  315,  277,  128,  277,  277,  277,  277,  277,
      315,  277,  277,  277,  277,  277,    0,  277,  277,  277,
      277,  277,  277,  277,  277,  277,  277,  277,  277,  277,
      277,  277,  277,  277,  277,  277,  277,  277,  277,  277,

      277,  277,  277,  277,  277,  277,  277,  277,  277,  277,
      277,  277,  277,  277,  277,  277,  277,  277,  277,  277,
      277,  277,  277,  277,  277
       );

      yy_nxt : constant array (0 .. 1525) of Short :=
          (0,
       36,   37,   38,   37,   36,   37,   36,   36,   36,   36,
       36,   36,   36,   36,   36,   36,   36,   36,   36,   36,
       36,   36,   36,   36,   39,   39,   39,   39,   39,   39,
       39,   39,   39,   39,   39,   39,   39,   39,   39,   39,
       39,   39,   39,   39,   36,   36,   36,   36,   40,   41,
       40,   36,   40,   36,   42,   36,   43,   36,   36,   36,
       44,   36,   36,   36,   36,   36,   36,   36,   36,   36,
       36,   45,   45,   45,   45,   45,   45,   45,   45,   45,
       45,   45,   45,   45,   45,   45,   45,   45,   45,   45,
       45,   36,   36,   36,   47,   48,   47,  264,   47,   49,

      171,   50,  141,  199,   51,  118,  102,   51,   51,  119,
       52,  172,  102,   53,   54,   66,   67,   66,   75,   66,
       66,   67,   66,   80,   66,  250,   80,   81,   76,  111,
       81,  118,   77,  112,  248,  119,  186,   55,   51,   56,
       57,   56,   82,   56,   49,   82,   50,   58,  113,   51,
      103,   59,   51,   51,   69,   52,  103,   69,   53,   54,
       69,   60,   78,  138,  138,   84,  188,  138,   84,  191,
      160,   88,  160,   85,  160,   86,   85,  118,   86,   89,
       90,  119,   55,   51,   68,   68,   69,   68,   68,   68,
       68,   68,   68,   68,   68,   68,   70,   68,   68,   68,

       68,   68,   68,   71,   68,   68,   68,   68,   72,   72,
       72,   72,   72,   72,   72,   72,   72,   72,   72,   72,
       72,   72,   72,   72,   72,   72,   72,   72,   68,   68,
       68,   75,   69,  186,  111,  115,  116,  115,  112,  115,
      186,   76,  246,   88,  186,   77,  120,  121,  120,  258,
      120,   89,   90,  113,  250,  115,  116,  115,  122,  115,
      120,  121,  120,  188,  120,  188,  248,  118,  192,  246,
      188,  119,  122,  193,  188,   78,   91,   91,   92,   91,
       91,   91,   93,   91,   91,   91,   94,   91,   91,   95,
       91,   96,   91,   91,   91,   91,   91,   91,   91,   91,

       97,   97,   97,   97,   97,   97,   97,   97,   97,   97,
       97,   97,   97,   97,   97,   97,   97,   97,   97,   97,
       98,   91,   99,  105,  105,  106,  106,  200,  197,  171,
      160,  186,  160,  140,  160,  141,  199,  210,  243,  207,
      172,  107,  107,  107,  107,  220,  230,  220,  232,  220,
      217,  141,  199,  234,  217,  234,  220,  234,  220,  118,
      220,  188,  182,  182,  221,  108,  108,  109,  109,  125,
      125,  125,  125,  125,  125,  125,  125,  125,  126,  125,
      125,  125,  125,  125,  125,  125,  125,  125,  125,  125,
      125,  125,  125,  125,  127,  127,  127,  127,  127,  127,

      127,  127,  127,  128,  127,  127,  129,  127,  130,  127,
      127,  131,  132,  125,  125,  125,  135,  136,  135,  186,
      135,  186,  186,  197,  186,  244,  186,  164,  210,  231,
      141,  199,  142,  186,  233,  229,  234,  217,  234,  222,
      234,  197,  224,  195,  272,  225,  272,  223,  272,  188,
      235,  188,  188,  241,  188,  226,  188,  227,  228,  237,
      137,  144,  144,  188,  144,  144,  144,  144,  144,  144,
      144,  144,  144,  144,  144,  144,  144,  145,  144,  144,
      144,  144,  144,  144,  144,  146,  146,  146,  146,  146,
      146,  146,  146,  146,  146,  146,  146,  146,  146,  146,

      146,  146,  146,  146,  146,  144,  144,  144,  148,  149,
      148,  186,  148,  186,  186,  187,  186,  186,  187,  186,
      150,  135,  136,  135,  217,  135,  148,  149,  148,  186,
      148,  186,  186,  186,  186,  183,  118,  186,  150,  238,
      273,  186,  273,  186,  273,  176,  186,  188,  190,  188,
      236,  272,  151,  272,  189,  272,  239,  189,  211,  163,
      158,  155,  188,  251,  188,  137,  203,  188,  254,  203,
      151,  188,  189,  188,  242,  240,  188,  203,  203,  203,
      203,  203,  203,  203,  203,  203,  203,  203,  203,  203,
      203,  203,  203,  203,  203,  203,  203,  210,  206,  204,

      212,  212,  213,  212,  212,  212,  214,  212,  212,  212,
      214,  212,  212,  212,  212,  214,  212,  212,  212,  212,
      212,  212,  212,  212,  214,  214,  214,  214,  214,  214,
      214,  214,  214,  214,  214,  214,  214,  214,  214,  214,
      214,  214,  214,  214,  214,  212,  214,  218,  217,  218,
      186,  218,  186,  205,  218,  217,  218,  186,  218,  186,
      273,  276,  273,  276,  273,  276,  276,  201,  276,  198,
      276,  186,  197,  195,  184,  124,  186,  133,  183,  257,
      188,  178,  188,  252,  176,  253,  186,  255,  173,  188,
      219,  214,  214,  186,  214,  214,  214,  219,  214,  214,

      214,  188,  214,  214,  214,  214,  188,  214,  214,  214,
      214,  214,  214,  214,  214,  186,  188,  256,  186,  186,
      186,  259,  186,  188,  186,  266,  267,  266,  267,  266,
      267,  269,  186,  269,  143,  269,  214,  167,  165,  143,
      163,  260,  262,  161,  158,  188,  261,  155,  188,  188,
      263,  153,  188,  265,  188,  152,  143,  141,  139,  188,
      271,  266,  188,  266,  267,  266,  267,  133,  267,  268,
      124,  269,  277,  269,  270,  269,  274,  274,  274,  274,
      274,  274,   69,   69,  101,  101,   73,   73,   64,   64,
       62,   62,  277,  277,  277,  277,  277,  277,  277,  277,

      277,  277,  277,  277,  189,  277,  277,  268,  277,  277,
      277,  277,  277,  277,  270,  277,  277,  277,  277,  275,
      275,   46,   46,   46,   46,   46,   46,   46,   46,   46,
       46,   46,   46,   46,   46,   46,   61,   61,   61,   61,
       61,   61,   61,   61,   61,   61,   61,   61,   61,   61,
       61,   63,   63,   63,   63,   63,   63,   63,   63,   63,
       63,   63,   63,   63,   63,   63,   65,   65,   65,   65,
       65,   65,   65,   65,   65,   65,   65,   65,   65,   65,
       65,   69,   69,   69,   69,   69,   69,   69,   69,   69,
       69,   69,   69,   69,   69,   69,   74,   74,   74,   74,

       74,   74,   74,   74,   74,   74,   74,   74,   74,   74,
       74,   79,   79,   79,   79,   79,   79,   79,   79,   79,
       79,   79,   79,   79,   79,   79,   83,   83,   83,   83,
       83,   83,   83,   83,   83,   83,   83,   83,   83,   83,
       83,   87,   87,   87,   87,   87,   87,   87,   87,   87,
       87,   87,   87,   87,   87,   87,  100,  100,  100,  100,
      100,  100,  100,  100,  100,  100,  100,  100,  100,  100,
      100,  104,  104,  104,  104,  104,  104,  104,  104,  104,
      104,  104,  104,  104,  104,  104,  110,  110,  110,  110,
      110,  110,  110,  110,  110,  110,  110,  110,  110,  110,

      110,  114,  114,  114,  114,  114,  114,  114,  114,  114,
      114,  114,  114,  114,  114,  114,  117,  117,  117,  277,
      277,  117,  117,  123,  123,  123,  123,  123,  123,  123,
      123,  123,  123,  123,  123,  123,  123,  123,  134,  134,
      134,  277,  277,  134,  134,  140,  140,  277,  140,  140,
      140,  140,  140,  140,  140,  277,  140,  140,  140,  140,
      142,  142,  277,  142,  142,  142,  142,  142,  142,  142,
      142,  142,  142,  142,  142,  147,  147,  147,  147,  147,
      147,  147,  147,  147,  147,  147,  147,  147,  147,  147,
      154,  154,  154,  154,  154,  154,  154,  154,  154,  154,

      154,  154,  154,  154,  154,  156,  277,  277,  156,  156,
      156,  156,  156,  156,  156,  156,  156,  156,  156,  156,
      157,  157,  157,  157,  157,  157,  157,  157,  157,  157,
      157,  157,  157,  157,  157,  159,  159,  277,  159,  159,
      159,  159,  159,  159,  159,  159,  159,  159,  159,  159,
      162,  277,  277,  277,  277,  162,  162,  164,  164,  277,
      164,  164,  164,  164,  164,  164,  164,  164,  164,  164,
      164,  164,  166,  166,  277,  166,  166,  166,  166,  166,
      166,  166,  166,  166,  166,  166,  166,  168,  168,  277,
      168,  168,  168,  168,  168,  168,  168,  277,  168,  168,

      168,  168,  169,  169,  277,  169,  277,  277,  169,  169,
      169,  169,  169,  170,  170,  277,  170,  170,  170,  170,
      170,  170,  170,  170,  170,  170,  170,  170,  174,  277,
      277,  277,  277,  174,  174,  175,  175,  175,  175,  175,
      175,  175,  175,  175,  175,  175,  175,  175,  175,  175,
      177,  177,  277,  277,  177,  177,  177,  177,  177,  177,
      277,  177,  177,  179,  179,  277,  179,  277,  179,  179,
      179,  179,  277,  179,  179,  179,  179,  179,  180,  180,
      277,  180,  180,  180,  180,  180,  180,  180,  180,  180,
      180,  180,  180,  181,  181,  277,  181,  181,  181,  181,

      181,  181,  181,  181,  181,  181,  181,  181,  185,  185,
      277,  185,  185,  185,  185,  185,  185,  185,  185,  185,
      185,  185,  185,  188,  277,  277,  277,  277,  277,  277,
      277,  277,  277,  277,  188,  188,  194,  194,  194,  194,
      194,  194,  194,  194,  194,  194,  194,  194,  194,  194,
      194,  196,  196,  196,  196,  196,  196,  196,  196,  196,
      196,  196,  196,  196,  196,  196,  202,  202,  277,  202,
      202,  202,  202,  202,  202,  202,  202,  202,  202,  202,
      208,  208,  277,  208,  208,  208,  208,  208,  208,  208,
      208,  208,  208,  208,  208,  209,  209,  209,  209,  209,

      209,  209,  209,  209,  209,  209,  209,  209,  209,  209,
      215,  215,  277,  277,  277,  215,  215,  216,  216,  216,
      216,  216,  216,  216,  216,  216,  216,  216,  216,  216,
      216,  216,  245,  245,  245,  245,  245,  245,  245,  245,
      245,  245,  245,  245,  245,  245,  245,  247,  247,  247,
      247,  247,  247,  247,  247,  247,  247,  247,  247,  247,
      247,  247,  249,  249,  249,  249,  249,  249,  249,  249,
      249,  249,  249,  249,  249,  249,  249,   35,  277,  277,
      277,  277,  277,  277,  277,  277,  277,  277,  277,  277,
      277,  277,  277,  277,  277,  277,  277,  277,  277,  277,

      277,  277,  277,  277,  277,  277,  277,  277,  277,  277,
      277,  277,  277,  277,  277,  277,  277,  277,  277,  277,
      277,  277,  277,  277,  277
       );

      yy_chk : constant array (0 .. 1525) of Short :=
          (0,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    2,    2,    2,
        2,    2,    2,    2,    2,    2,    2,    2,    2,    2,
        2,    2,    2,    2,    2,    2,    2,    2,    2,    2,
        2,    2,    2,    2,    2,    2,    2,    2,    2,    2,
        2,    2,    2,    2,    2,    2,    2,    2,    2,    2,
        2,    2,    2,    2,    3,    3,    3,  258,    3,    3,

       94,    3,  140,  140,    3,   39,   27,    3,    3,   39,
        3,   94,   28,    3,    3,    9,    9,    9,   15,    9,
       10,   10,   10,   17,   10,  249,   18,   17,   15,   31,
       18,   45,   15,   31,  247,   45,  129,    3,    3,    4,
        4,    4,   17,    4,    4,   18,    4,    4,   31,    4,
       27,    4,    4,    4,   19,    4,   28,   20,    4,    4,
       21,    4,   15,   50,   50,   19,  129,   50,   20,  129,
       66,   21,   66,   19,   66,   19,   20,  117,   20,   21,
       21,  117,    4,    4,   11,   11,   11,   11,   11,   11,
       11,   11,   11,   11,   11,   11,   11,   11,   11,   11,

       11,   11,   11,   11,   11,   11,   11,   11,   11,   11,
       11,   11,   11,   11,   11,   11,   11,   11,   11,   11,
       11,   11,   11,   11,   11,   11,   11,   11,   11,   11,
       11,   16,   22,  131,   32,   37,   37,   37,   32,   37,
      130,   16,  245,   22,  188,   16,   40,   40,   40,  243,
       40,   22,   22,   32,  233,  115,  115,  115,   40,  115,
      120,  120,  120,  131,  120,  132,  232,  134,  130,  231,
      130,  134,  120,  132,  188,   16,   23,   23,   23,   23,
       23,   23,   23,   23,   23,   23,   23,   23,   23,   23,
       23,   23,   23,   23,   23,   23,   23,   23,   23,   23,

       23,   23,   23,   23,   23,   23,   23,   23,   23,   23,
       23,   23,   23,   23,   23,   23,   23,   23,   23,   23,
       23,   23,   23,   29,   30,   29,   30,  141,  151,  170,
      160,  190,  160,  141,  160,  244,  244,  206,  229,  151,
      170,   29,   30,   29,   30,  189,  200,  189,  206,  189,
      216,  200,  200,  219,  219,  219,  220,  219,  220,  215,
      220,  190,  313,  313,  190,   29,   30,   29,   30,   43,
       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,

       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
       43,   43,   43,   43,   43,   43,   47,   47,   47,  191,
       47,  192,  193,  207,  221,  230,  223,  211,  209,  205,
      230,  230,  201,  227,  207,  198,  234,  234,  234,  191,
      234,  196,  193,  194,  268,  193,  268,  192,  268,  191,
      221,  192,  193,  227,  221,  193,  223,  193,  193,  223,
       47,   55,   55,  227,   55,   55,   55,   55,   55,   55,
       55,   55,   55,   55,   55,   55,   55,   55,   55,   55,
       55,   55,   55,   55,   55,   55,   55,   55,   55,   55,
       55,   55,   55,   55,   55,   55,   55,   55,   55,   55,

       55,   55,   55,   55,   55,   55,   55,   55,   56,   56,
       56,  127,   56,  127,  128,  127,  128,  224,  128,  222,
       56,  135,  135,  135,  184,  135,  148,  148,  148,  186,
      148,  186,  225,  186,  235,  183,  182,  226,  148,  224,
      270,  237,  270,  228,  270,  175,  239,  224,  128,  222,
      222,  272,   56,  272,  127,  272,  225,  128,  165,  163,
      157,  154,  225,  235,  235,  135,  146,  226,  239,  146,
      148,  237,  186,  228,  228,  226,  239,  146,  146,  146,
      146,  146,  146,  146,  146,  146,  146,  146,  146,  146,
      146,  146,  146,  146,  146,  146,  146,  153,  150,  146,

      173,  173,  173,  173,  173,  173,  173,  173,  173,  173,
      173,  173,  173,  173,  173,  173,  173,  173,  173,  173,
      173,  173,  173,  173,  173,  173,  173,  173,  173,  173,
      173,  173,  173,  173,  173,  173,  173,  173,  173,  173,
      173,  173,  173,  173,  173,  173,  173,  187,  187,  187,
      236,  187,  238,  147,  218,  218,  218,  240,  218,  242,
      273,  275,  273,  275,  273,  275,  276,  143,  276,  139,
      276,  252,  137,  133,  125,  123,  256,  122,  119,  242,
      236,  106,  238,  236,  100,  238,  241,  240,   95,  242,
      187,  214,  214,  251,  214,  214,  214,  218,  214,  214,

      214,  252,  214,  214,  214,  214,  256,  214,  214,  214,
      214,  214,  214,  214,  214,  253,  241,  241,  255,  254,
      257,  251,  259,  251,  260,  261,  262,  261,  262,  261,
      262,  263,  265,  263,   89,  263,  214,   86,   85,   82,
       77,  253,  255,   71,   63,  253,  254,   61,  255,  254,
      257,   59,  259,  260,  260,   58,   54,   53,   52,  261,
      265,  266,  265,  266,  267,  266,  267,   44,  267,  262,
       42,  269,   35,  269,  263,  269,  271,  274,  271,  274,
      271,  274,   34,   33,   26,   25,   14,   13,    8,    7,
        6,    5,    0,    0,    0,    0,    0,    0,    0,    0,

        0,    0,    0,    0,  266,    0,    0,  267,    0,    0,
        0,    0,    0,    0,  269,    0,    0,    0,    0,  271,
      274,  278,  278,  278,  278,  278,  278,  278,  278,  278,
      278,  278,  278,  278,  278,  278,  279,  279,  279,  279,
      279,  279,  279,  279,  279,  279,  279,  279,  279,  279,
      279,  280,  280,  280,  280,  280,  280,  280,  280,  280,
      280,  280,  280,  280,  280,  280,  281,  281,  281,  281,
      281,  281,  281,  281,  281,  281,  281,  281,  281,  281,
      281,  282,  282,  282,  282,  282,  282,  282,  282,  282,
      282,  282,  282,  282,  282,  282,  283,  283,  283,  283,

      283,  283,  283,  283,  283,  283,  283,  283,  283,  283,
      283,  284,  284,  284,  284,  284,  284,  284,  284,  284,
      284,  284,  284,  284,  284,  284,  285,  285,  285,  285,
      285,  285,  285,  285,  285,  285,  285,  285,  285,  285,
      285,  286,  286,  286,  286,  286,  286,  286,  286,  286,
      286,  286,  286,  286,  286,  286,  287,  287,  287,  287,
      287,  287,  287,  287,  287,  287,  287,  287,  287,  287,
      287,  288,  288,  288,  288,  288,  288,  288,  288,  288,
      288,  288,  288,  288,  288,  288,  289,  289,  289,  289,
      289,  289,  289,  289,  289,  289,  289,  289,  289,  289,

      289,  290,  290,  290,  290,  290,  290,  290,  290,  290,
      290,  290,  290,  290,  290,  290,  291,  291,  291,    0,
        0,  291,  291,  292,  292,  292,  292,  292,  292,  292,
      292,  292,  292,  292,  292,  292,  292,  292,  293,  293,
      293,    0,    0,  293,  293,  294,  294,    0,  294,  294,
      294,  294,  294,  294,  294,    0,  294,  294,  294,  294,
      295,  295,    0,  295,  295,  295,  295,  295,  295,  295,
      295,  295,  295,  295,  295,  296,  296,  296,  296,  296,
      296,  296,  296,  296,  296,  296,  296,  296,  296,  296,
      297,  297,  297,  297,  297,  297,  297,  297,  297,  297,

      297,  297,  297,  297,  297,  298,    0,    0,  298,  298,
      298,  298,  298,  298,  298,  298,  298,  298,  298,  298,
      299,  299,  299,  299,  299,  299,  299,  299,  299,  299,
      299,  299,  299,  299,  299,  300,  300,    0,  300,  300,
      300,  300,  300,  300,  300,  300,  300,  300,  300,  300,
      301,    0,    0,    0,    0,  301,  301,  302,  302,    0,
      302,  302,  302,  302,  302,  302,  302,  302,  302,  302,
      302,  302,  303,  303,    0,  303,  303,  303,  303,  303,
      303,  303,  303,  303,  303,  303,  303,  304,  304,    0,
      304,  304,  304,  304,  304,  304,  304,    0,  304,  304,

      304,  304,  305,  305,    0,  305,    0,    0,  305,  305,
      305,  305,  305,  306,  306,    0,  306,  306,  306,  306,
      306,  306,  306,  306,  306,  306,  306,  306,  307,    0,
        0,    0,    0,  307,  307,  308,  308,  308,  308,  308,
      308,  308,  308,  308,  308,  308,  308,  308,  308,  308,
      309,  309,    0,    0,  309,  309,  309,  309,  309,  309,
        0,  309,  309,  310,  310,    0,  310,    0,  310,  310,
      310,  310,    0,  310,  310,  310,  310,  310,  311,  311,
        0,  311,  311,  311,  311,  311,  311,  311,  311,  311,
      311,  311,  311,  312,  312,    0,  312,  312,  312,  312,

      312,  312,  312,  312,  312,  312,  312,  312,  314,  314,
        0,  314,  314,  314,  314,  314,  314,  314,  314,  314,
      314,  314,  314,  315,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,  315,  315,  316,  316,  316,  316,
      316,  316,  316,  316,  316,  316,  316,  316,  316,  316,
      316,  317,  317,  317,  317,  317,  317,  317,  317,  317,
      317,  317,  317,  317,  317,  317,  318,  318,    0,  318,
      318,  318,  318,  318,  318,  318,  318,  318,  318,  318,
      319,  319,    0,  319,  319,  319,  319,  319,  319,  319,
      319,  319,  319,  319,  319,  320,  320,  320,  320,  320,

      320,  320,  320,  320,  320,  320,  320,  320,  320,  320,
      321,  321,    0,    0,    0,  321,  321,  322,  322,  322,
      322,  322,  322,  322,  322,  322,  322,  322,  322,  322,
      322,  322,  323,  323,  323,  323,  323,  323,  323,  323,
      323,  323,  323,  323,  323,  323,  323,  324,  324,  324,
      324,  324,  324,  324,  324,  324,  324,  324,  324,  324,
      324,  324,  325,  325,  325,  325,  325,  325,  325,  325,
      325,  325,  325,  325,  325,  325,  325,  277,  277,  277,
      277,  277,  277,  277,  277,  277,  277,  277,  277,  277,
      277,  277,  277,  277,  277,  277,  277,  277,  277,  277,

      277,  277,  277,  277,  277,  277,  277,  277,  277,  277,
      277,  277,  277,  277,  277,  277,  277,  277,  277,  277,
      277,  277,  277,  277,  277
       );

      yy_act : Integer;
      yy_c   : Short;
      yy_current_state : yy_state_type;

      --  copy whatever the last rule matched to the standard output
      procedure ECHO is
      begin
         if Ada.Text_IO.Is_Open (user_output_file) then
            Ada.Text_IO.Put (user_output_file, YYText);
         else
            Ada.Text_IO.Put (YYText);
         end if;
      end ECHO;

      --  enter a start condition.
      --  Using procedure requires a () after the ENTER, but makes everything
      --  much neater.

      procedure ENTER (state : Integer) is
      begin
         yy_start := 1 + 2 * state;
      end ENTER;

      --  action number for EOF rule of a given start state
      function YY_STATE_EOF (state : Integer) return Integer is
      begin
         return YY_END_OF_BUFFER + state + 1;
      end YY_STATE_EOF;

      --  return all but the first 'n' matched characters back to the input stream
      procedure yyless (n : Integer) is
      begin
         yy_ch_buf (yy_cp) := yy_hold_char; --  undo effects of setting up yytext
         yy_cp := yy_bp + n;
         yy_c_buf_p := yy_cp;
         YY_DO_BEFORE_ACTION; -- set up yytext again
      end yyless;

      --  yy_get_previous_state - get the state just before the EOB char was reached

      function yy_get_previous_state return yy_state_type is
         yy_current_state : yy_state_type;
         yy_c : Short;
         yy_bp : constant Integer := yytext_ptr;
      begin
         yy_current_state := yy_start;
         if yy_ch_buf (yy_bp - 1) = ASCII.LF then
            yy_current_state := yy_current_state + 1;
         end if;

         for yy_cp in yytext_ptr .. yy_c_buf_p - 1 loop
            yy_c := yy_ec (yy_ch_buf (yy_cp));
            if yy_accept (yy_current_state) /= 0 then
               yy_last_accepting_state := yy_current_state;
               yy_last_accepting_cpos := yy_cp;
               yy_last_yylineno := yylineno;
               yy_last_yylinecol := yylinecol;
            end if;
            while yy_chk (yy_base (yy_current_state) + yy_c) /= yy_current_state loop
               yy_current_state := yy_def (yy_current_state);
               if yy_current_state >= 278 then
                  yy_c := yy_meta (yy_c);
               end if;
            end loop;
            yy_current_state := yy_nxt (yy_base (yy_current_state) + yy_c);
         end loop;

         return yy_current_state;
      end yy_get_previous_state;

      procedure yyrestart (input_file : File_Type) is
      begin
         Open_Input (Ada.Text_IO.Name (input_file));
      end yyrestart;

   begin -- of YYLex
      <<new_file>>
      --  this is where we enter upon encountering an end-of-file and
      --  yyWrap () indicating that we should continue processing

      if yy_init then
         if yy_start = 0 then
            yy_start := 1;      -- first start state
         end if;

         --  we put in the '\n' and start reading from [1] so that an
         --  initial match-at-newline will be true.

         yy_ch_buf (0) := ASCII.LF;
         yy_n_chars := 1;

         --  we always need two end-of-buffer characters. The first causes
         --  a transition to the end-of-buffer state. The second causes
         --  a jam in that state.

         yy_ch_buf (yy_n_chars) := YY_END_OF_BUFFER_CHAR;
         yy_ch_buf (yy_n_chars + 1) := YY_END_OF_BUFFER_CHAR;

         yy_eof_has_been_seen := False;

         yytext_ptr := 1;
         yy_c_buf_p := yytext_ptr;
         yy_hold_char := yy_ch_buf (yy_c_buf_p);
         yy_init := False;
      end if; -- yy_init

      loop                -- loops until end-of-file is reached

         yy_cp := yy_c_buf_p;

         --  support of yytext
         yy_ch_buf (yy_cp) := yy_hold_char;

         --  yy_bp points to the position in yy_ch_buf of the start of the
         --  current run.
         yy_bp := yy_cp;
         yy_current_state := yy_start;
         if yy_ch_buf (yy_bp - 1) = ASCII.LF then
            yy_current_state := yy_current_state + 1;
         end if;
         loop
               yy_c := yy_ec (yy_ch_buf (yy_cp));
               if yy_accept (yy_current_state) /= 0 then
                  yy_last_accepting_state := yy_current_state;
                  yy_last_accepting_cpos := yy_cp;
                  yy_last_yylineno := yylineno;
                  yy_last_yylinecol := yylinecol;
               end if;
               while yy_chk (yy_base (yy_current_state) + yy_c) /= yy_current_state loop
                  yy_current_state := yy_def (yy_current_state);
                  if yy_current_state >= 278 then
                     yy_c := yy_meta (yy_c);
                  end if;
               end loop;
               yy_current_state := yy_nxt (yy_base (yy_current_state) + yy_c);
            if yy_ch_buf (yy_cp) = ASCII.LF then
               yylineno := yylineno + 1;
               yylinecol := 1;
            else
               yylinecol := yylinecol + 1;
            end if;
            yy_cp := yy_cp + 1;
            if yy_current_state = 277 then
                exit;
            end if;
         end loop;
         yy_cp := yy_last_accepting_cpos;
         yy_current_state := yy_last_accepting_state;
         yylineno := yy_last_yylineno;
         yylinecol := yy_last_yylinecol;

   <<next_action>>
         yy_act := yy_accept (yy_current_state);
         YY_DO_BEFORE_ACTION;

         if aflex_debug then  -- output acceptance info. for (-d) debug mode
            Ada.Text_IO.Put (Standard_Error, "  -- Aflex.YYLex accept rule #");
            Ada.Text_IO.Put (Standard_Error, Integer'Image (yy_act));
            Ada.Text_IO.Put_Line (Standard_Error, "(""" & YYText & """)");
         end if;

   <<do_action>>   -- this label is used only to access EOF actions
         case yy_act is

            when 0 => -- must backtrack
            -- undo the effects of YY_DO_BEFORE_ACTION
            yy_ch_buf (yy_cp) := yy_hold_char;
            yy_cp := yy_last_accepting_cpos;
            yylineno := yy_last_yylineno;
            yylinecol := yy_last_yylinecol;
            yy_current_state := yy_last_accepting_state;
            goto next_action;



         when 1 =>
--# line 64 "ascan.l"
             indented_code := True; 

         when 2 =>
--# line 65 "ascan.l"
             linenum := linenum + 1; ECHO;
                -- treat as a comment;
            

         when 3 =>
--# line 68 "ascan.l"
             linenum := linenum + 1; ECHO; 

         when 4 =>
--# line 69 "ascan.l"
             return SCDECL; 

         when 5 =>
--# line 70 "ascan.l"
             return XSCDECL; 

         when 6 =>
--# line 71 "ascan.l"
             return USCDECL; 

         when 7 =>
--# line 72 "ascan.l"
             return OPTDECL; 

         when 8 =>
--# line 73 "ascan.l"
             ENTER(YYDECL_STRING); return YYDECL; 

         when 9 =>
--# line 74 "ascan.l"
             return YYVAR; 

         when 10 =>
--# line 76 "ascan.l"
             return WHITESPACE; 

         when 11 =>
--# line 77 "ascan.l"
             nmstr := vstr(yytext(1..YYLength)); return OPTVAR; 

         when 12 =>
--# line 78 "ascan.l"
            
                  Open_Code_Block (Template_Manager.Get_Filename (Template_Manager.YYTYPE_CODE));
                  ENTER(CODEBLOCK_MATCH_BRACE);


         when 13 =>
--# line 82 "ascan.l"
            
                  Open_Code_Block (Template_Manager.Get_Filename (Template_Manager.YYACTION_CODE));
                  ENTER(CODEBLOCK_MATCH_BRACE);


         when 14 =>
--# line 86 "ascan.l"
            
                  Open_Code_Block (Template_Manager.Get_Filename (Template_Manager.YYWRAP_CODE));
                  ENTER(CODEBLOCK_MATCH_BRACE);


         when 15 =>
--# line 91 "ascan.l"
            
            sectnum := 2;
            misc.line_directive_out;
            ENTER(SECT2PROLOG);
            return SECTEND;
            

         when 16 =>
--# line 98 "ascan.l"
            
               misc.synerr ("unrecognized code block");
               ENTER(CODEBLOCK_MATCH_BRACE);
            

         when 17 =>
--# line 103 "ascan.l"
            
            Ada.Text_IO.Put( Standard_Error, "old-style lex command at line " );
            int_io.put( Standard_Error, linenum );
            Ada.Text_IO.Put( Standard_Error, " ignored:" );
            text_io.new_line( Standard_Error );
            Ada.Text_IO.Put( Standard_Error, ASCII.HT );
            Ada.Text_IO.Put( Standard_Error, yytext(1..YYLength) );
            linenum := linenum + 1;
            

         when 18 =>
--# line 113 "ascan.l"
            
            nmstr := vstr(yytext(1..YYLength));
            didadef := False;
            ENTER(PICKUPDEF);
            

         when 19 =>
--# line 119 "ascan.l"
             nmstr := vstr(yytext(1..YYLength));
              return UNAME;
            

         when 20 =>
--# line 123 "ascan.l"
             nmstr := vstr(yytext(1..YYLength));
              return NAME;
            

         when 21 =>
--# line 126 "ascan.l"
             linenum := linenum + 1;
              -- allows blank lines in section 1;
            

         when 22 =>
--# line 129 "ascan.l"
             linenum := linenum + 1; return Newline; 

         when 23 =>
--# line 130 "ascan.l"
             misc.synerr( "illegal character" );ENTER(RECOVER);

         when 24 =>
--# line 131 "ascan.l"
            
               nmstr := vstr(yytext(1..YYLength));
               ENTER(0);
               return NAME;
            

         when 25 =>
--# line 136 "ascan.l"
             null;
              -- separates name and definition;
            

         when 26 =>
--# line 140 "ascan.l"
            
            nmdef := vstr(yytext(1..YYLength));

            i := tstring.len( nmdef );
            while ( i >= tstring.first ) loop
                if ( (CHAR(nmdef,i) /= ' ') and
                 (CHAR(nmdef,i) /= ASCII.HT) ) then
                exit;
                end if;
                i := i - 1;
            end loop;

                        sym.ndinstal( nmstr,
                tstring.slice(nmdef, tstring.first, i) );
            didadef := True;
            

         when 27 =>
--# line 157 "ascan.l"
            
            if not didadef then
                misc.synerr( "incomplete name definition" );
            end if;
            ENTER(0);
            linenum := linenum + 1;
            

         when 28 =>
--# line 165 "ascan.l"
             linenum := linenum + 1;
              ENTER(0);
              nmstr := vstr(yytext(1..YYLength));
              return NAME;
            

         when 29 =>
            yy_ch_buf (yy_cp) := yy_hold_char; -- undo effects of setting up yytext
            yy_cp := yy_cp - 1;
            yy_c_buf_p := yy_cp;
            YY_DO_BEFORE_ACTION; -- set up yytext again
--# line 171 "ascan.l"
            
            linenum := linenum + 1;
            ACTION_ECHO;
            MARK_END_OF_PROLOG;
            ENTER(SECT2);
            

         when 30 =>
--# line 178 "ascan.l"
             linenum := linenum + 1; ACTION_ECHO; 

   when YY_END_OF_BUFFER +SECT2PROLOG + 1 
 =>
--# line 180 "ascan.l"
 MARK_END_OF_PROLOG;
              return End_Of_Input;
            

         when 32 =>
--# line 184 "ascan.l"
             linenum := linenum + 1;
              -- allow blank lines in sect2;

            -- this rule matches indented lines which
            -- are not comments.
         when 33 =>
--# line 189 "ascan.l"
            
            misc.synerr("indented code found outside of action");
            linenum := linenum + 1;
            

         when 34 =>
--# line 194 "ascan.l"
             ENTER(SC); return ( '<' ); 

         when 35 =>
--# line 195 "ascan.l"
             return ( '^' );  

         when 36 =>
--# line 196 "ascan.l"
             ENTER(QUOTE); return ( '"' ); 

         when 37 =>
            yy_ch_buf (yy_cp) := yy_hold_char; -- undo effects of setting up yytext
            yy_cp := yy_bp + 1;
            yy_c_buf_p := yy_cp;
            YY_DO_BEFORE_ACTION; -- set up yytext again
--# line 197 "ascan.l"
             ENTER(NUM); return ( '{' ); 

         when 38 =>
--# line 198 "ascan.l"
             ENTER(BRACEERROR); 

         when 39 =>
            yy_ch_buf (yy_cp) := yy_hold_char; -- undo effects of setting up yytext
            yy_cp := yy_bp + 1;
            yy_c_buf_p := yy_cp;
            YY_DO_BEFORE_ACTION; -- set up yytext again
--# line 199 "ascan.l"
             return '$'; 

         when 40 =>
--# line 201 "ascan.l"
             continued_action := True;
              linenum := linenum + 1;
              return Newline;
            

         when 41 =>
--# line 206 "ascan.l"
             linenum := linenum + 1; ACTION_ECHO; 

         when 42 =>
--# line 208 "ascan.l"
            
            -- this rule is separate from the one below because
            -- otherwise we get variable trailing context, so
            -- we can't build the scanner using -f,F

            bracelevel := 0;
            continued_action := False;
            ENTER(ACTION);
            return Newline;
            

         when 43 =>
            yy_ch_buf (yy_cp) := yy_hold_char; -- undo effects of setting up yytext
            yy_cp := yy_cp - 1;
            yy_c_buf_p := yy_cp;
            YY_DO_BEFORE_ACTION; -- set up yytext again
--# line 219 "ascan.l"
            
            bracelevel := 0;
            continued_action := False;
            ENTER(ACTION);
            return Newline;
            

         when 44 =>
--# line 226 "ascan.l"
             linenum := linenum + 1; return Newline; 

         when 45 =>
--# line 228 "ascan.l"
             return EOF_OP; 

         when 46 =>
--# line 230 "ascan.l"
            
            sectnum := 3;
            ENTER(SECT3);
            return End_Of_Input;
            -- to stop the parser
            

         when 47 =>
--# line 237 "ascan.l"
            

            nmstr := vstr(yytext(1..YYLength));

            -- check to see if we've already encountered this ccl
                        cclval := sym.ccllookup( nmstr );
            if ( cclval /= 0 ) then
                YYLVal := cclval;
                cclreuse := cclreuse + 1;
                return PREVCCL;
            else
                -- we fudge a bit.  We know that this ccl will
                -- soon be numbered as lastccl + 1 by cclinit
                sym.cclinstal( nmstr, lastccl + 1 );

                -- push back everything but the leading bracket
                -- so the ccl can be rescanned

                PUT_BACK_STRING(nmstr, 1);

                ENTER(FIRSTCCL);
                return '[';
            end if;
            

         when 48 =>
--# line 262 "ascan.l"
            
            nmstr := vstr(yytext(1..YYLength));
            -- chop leading and trailing brace
            tmpbuf := slice(vstr(yytext(1..YYLength)),
                                2, YYLength-1);

            nmdefptr := sym.ndlookup( tmpbuf );
            if ( nmdefptr = NUL ) then
                misc.synerr( "undefined {name}" );
            else
                -- push back name surrounded by ()'s
                unput(')');
                PUT_BACK_STRING(nmdefptr, 0);
                unput('(');
            end if;
            

         when 49 =>
--# line 279 "ascan.l"
             tmpbuf := vstr(yytext(1..YYLength));
              case tstring.CHAR(tmpbuf,1) is
                when '/' => return '/';
                when '|' => return '|';
                when '*' => return '*';
                when '+' => return '+';
                when '?' => return '?';
                when '.' => return '.';
                when '(' => return '(';
                when ')' => return ')';
                when others =>
                    misc.aflexerror("error in aflex case");
              end case;
            

         when 50 =>
--# line 293 "ascan.l"
             tmpbuf := vstr(yytext(1..YYLength));
              YYLVal := CHARACTER'POS(CHAR(tmpbuf,1));
              return CHAR;
            

         when 51 =>
--# line 297 "ascan.l"
             linenum := linenum + 1; return Newline; 

         when 52 =>
--# line 300 "ascan.l"
             return ( ',' ); 

         when 53 =>
--# line 301 "ascan.l"
             ENTER(SECT2); return ( '>' ); 

         when 54 =>
            yy_ch_buf (yy_cp) := yy_hold_char; -- undo effects of setting up yytext
            yy_cp := yy_bp + 1;
            yy_c_buf_p := yy_cp;
            YY_DO_BEFORE_ACTION; -- set up yytext again
--# line 302 "ascan.l"
             ENTER(CARETISBOL); return ( '>' ); 

         when 55 =>
--# line 303 "ascan.l"
             nmstr := vstr(yytext(1..YYLength));
              return NAME;
            

         when 56 =>
--# line 306 "ascan.l"
             misc.synerr( "bad start condition name" ); 

         when 57 =>
--# line 308 "ascan.l"
             ENTER(SECT2); return '^'; 

         when 58 =>
--# line 311 "ascan.l"
             tmpbuf := vstr(yytext(1..YYLength));
              YYLVal := CHARACTER'POS(CHAR(tmpbuf,1));
              return CHAR;
            

         when 59 =>
--# line 315 "ascan.l"
             ENTER(SECT2); return '"'; 

         when 60 =>
--# line 317 "ascan.l"
            
            misc.synerr( "missing quote" );
            ENTER(SECT2);
            linenum := linenum + 1;
            return '"';
            

         when 61 =>
            yy_ch_buf (yy_cp) := yy_hold_char; -- undo effects of setting up yytext
            yy_cp := yy_bp + 1;
            yy_c_buf_p := yy_cp;
            YY_DO_BEFORE_ACTION; -- set up yytext again
--# line 325 "ascan.l"
             ENTER(CCL); return '^'; 

         when 62 =>
            yy_ch_buf (yy_cp) := yy_hold_char; -- undo effects of setting up yytext
            yy_cp := yy_bp + 1;
            yy_c_buf_p := yy_cp;
            YY_DO_BEFORE_ACTION; -- set up yytext again
--# line 326 "ascan.l"
             return '^'; 

         when 63 =>
--# line 327 "ascan.l"
             ENTER(CCL); YYLVal := CHARACTER'POS('-'); return ( CHAR ); 

         when 64 =>
--# line 328 "ascan.l"
             ENTER(CCL);
              tmpbuf := vstr(yytext(1..YYLength));
              YYLVal := CHARACTER'POS(CHAR(tmpbuf,1));
              return CHAR;
            

         when 65 =>
            yy_ch_buf (yy_cp) := yy_hold_char; -- undo effects of setting up yytext
            yy_cp := yy_bp + 1;
            yy_c_buf_p := yy_cp;
            YY_DO_BEFORE_ACTION; -- set up yytext again
--# line 334 "ascan.l"
             return '-'; 

         when 66 =>
--# line 335 "ascan.l"
             tmpbuf := vstr(yytext(1..YYLength));
              YYLVal := CHARACTER'POS(CHAR(tmpbuf,1));
              return CHAR;
            

         when 67 =>
--# line 339 "ascan.l"
             ENTER(SECT2); return ']'; 

         when 68 =>
--# line 342 "ascan.l"
            
            YYLVal := misc.myctoi( vstr(yytext(1..YYLength)) );
            return NUMBER;
            

         when 69 =>
--# line 347 "ascan.l"
             return ','; 

         when 70 =>
--# line 348 "ascan.l"
             ENTER(SECT2); return '}'; 

         when 71 =>
--# line 350 "ascan.l"
            
            misc.synerr( "bad character inside {}'s" );
            ENTER(SECT2);
            return '}';
            

         when 72 =>
--# line 356 "ascan.l"
            
            misc.synerr( "missing }" );
            ENTER(SECT2);
            linenum := linenum + 1;
            return '}';
            

         when 73 =>
--# line 364 "ascan.l"
             misc.synerr( "bad name in {}'s" ); ENTER(SECT2); 

         when 74 =>
--# line 365 "ascan.l"
             misc.synerr( "missing }" );
              linenum := linenum + 1;
              ENTER(SECT2);
            

         when 75 =>
--# line 370 "ascan.l"
             bracelevel := bracelevel + 1; 

         when 76 =>
--# line 371 "ascan.l"
             bracelevel := bracelevel - 1; 

         when 77 =>
--# line 372 "ascan.l"
             ACTION_ECHO; 

         when 78 =>
--# line 373 "ascan.l"
             ACTION_ECHO; 

         when 79 =>
--# line 374 "ascan.l"
             linenum := linenum + 1; ACTION_ECHO; 

         when 80 =>
--# line 375 "ascan.l"
             ACTION_ECHO;
                  -- character constant;
            

         when 81 =>
--# line 379 "ascan.l"
             ACTION_ECHO; ENTER(ACTION_STRING); 

         when 82 =>
--# line 381 "ascan.l"
            
            linenum := linenum + 1;
            ACTION_ECHO;
            if bracelevel = 0 then
                text_io.new_line ( temp_action_file );
                ENTER(SECT2);
                    end if;
            

         when 83 =>
--# line 389 "ascan.l"
             ACTION_ECHO; 

         when 84 =>
--# line 391 "ascan.l"
             ACTION_ECHO; 

         when 85 =>
--# line 392 "ascan.l"
             ACTION_ECHO; 

         when 86 =>
--# line 393 "ascan.l"
             linenum := linenum + 1; ACTION_ECHO; 

         when 87 =>
--# line 394 "ascan.l"
             ACTION_ECHO; ENTER(ACTION); 

         when 88 =>
--# line 395 "ascan.l"
             ACTION_ECHO; 

         when 89 =>
--# line 398 "ascan.l"
            
            YYLVal := CHARACTER'POS(misc.myesc( vstr(yytext(1..YYLength)) ));
            return ( CHAR );
            

         when 90 =>
--# line 403 "ascan.l"
            
            YYLVal := CHARACTER'POS(misc.myesc( vstr(yytext(1..YYLength)) ));
            ENTER(CCL);
            return CHAR;
            

         when 91 =>
--# line 410 "ascan.l"
             if check_yylex_here then
                return End_Of_Input;
              else
                ECHO;
              end if;
            

         when 92 =>
--# line 417 "ascan.l"
            
                if Code_Block_Active then
                   Ada.Text_IO.Close (Code_Block_File);
                   Code_Block_Active := False;
                end if;
                ENTER(0);
                return YYCODEBLOCK;
            

         when 93 =>
--# line 426 "ascan.l"
            
                --  brace_depth++;
                if Code_Block_Active then
                   Ada.Text_IO.Put (Code_Block_File, YYText);
                end if;
            

         when 94 =>
--# line 433 "ascan.l"
            
                Linenum := Linenum + 1;
                if Code_Block_Active then
                   Ada.Text_IO.New_Line (Code_Block_File);
                end if;
            

         when 95 =>
--# line 440 "ascan.l"
            
                Linenum := Linenum + 1; 
                if Code_Block_Active then
                   Ada.Text_IO.Put (Code_Block_File, YYText);
                end if;
            

   when YY_END_OF_BUFFER +CODEBLOCK_MATCH_BRACE + 1 
 =>
--# line 447 "ascan.l"

                misc.synerr ("unmatched '{' at line" & Natural'Image (Code_Block_Start));
                if Code_Block_Active then
                   Ada.Text_IO.Close (Code_Block_File);
                end if;
                ENTER(0);
                return YYCODEBLOCK;
            

         when 97 =>
--# line 456 "ascan.l"
            ECHO;
         when YY_END_OF_BUFFER + INITIAL + 1 |
              YY_END_OF_BUFFER + SECT2 + 1 |
              YY_END_OF_BUFFER + SECT3 + 1 |
              YY_END_OF_BUFFER + PICKUPDEF + 1 |
              YY_END_OF_BUFFER + SC + 1 |
              YY_END_OF_BUFFER + CARETISBOL + 1 |
              YY_END_OF_BUFFER + NUM + 1 |
              YY_END_OF_BUFFER + QUOTE + 1 |
              YY_END_OF_BUFFER + FIRSTCCL + 1 |
              YY_END_OF_BUFFER + CCL + 1 |
              YY_END_OF_BUFFER + ACTION + 1 |
              YY_END_OF_BUFFER + RECOVER + 1 |
              YY_END_OF_BUFFER + BRACEERROR + 1 |
              YY_END_OF_BUFFER + ACTION_STRING + 1 |
              YY_END_OF_BUFFER + YYDECL_STRING + 1 =>
            return End_Of_Input;

         when YY_END_OF_BUFFER =>
            --  undo the effects of YY_DO_BEFORE_ACTION
            yy_ch_buf (yy_cp) := yy_hold_char;

            yytext_ptr := yy_bp;

            case yy_get_next_buffer is
               when EOB_ACT_END_OF_FILE =>
                  if yyWrap then
                     --  note: because we've taken care in
                     --  yy_get_next_buffer() to have set up yytext,
                     --  we can now set up yy_c_buf_p so that if some
                     --  total hoser (like aflex itself) wants
                     --  to call the scanner after we return the
                     --  End_Of_Input, it'll still work - another
                     --  End_Of_Input will get returned.

                     yy_c_buf_p := yytext_ptr;

                     yy_act := YY_STATE_EOF ((yy_start - 1) / 2);

                     goto do_action;
                  else
                     --  start processing a new file
                     yy_init := True;
                     goto new_file;
                  end if;

               when EOB_ACT_RESTART_SCAN =>
                  yy_c_buf_p := yytext_ptr;
                  yy_hold_char := yy_ch_buf (yy_c_buf_p);

               when EOB_ACT_LAST_MATCH =>
                  yy_c_buf_p := yy_n_chars;
                  yy_current_state := yy_get_previous_state;
                  yy_cp := yy_c_buf_p;
                  yy_bp := yytext_ptr;
                  goto next_action;
            end case; --  case yy_get_next_buffer()

         when others =>
            Ada.Text_IO.Put ("action # ");
            Ada.Text_IO.Put (Integer'Image (yy_act));
            Ada.Text_IO.New_Line;
            raise AFLEX_INTERNAL_ERROR;
         end case; --  case (yy_act)
      end loop; --  end of loop waiting for end of file
   end YYLex;

--# line 456 "ascan.l"
   begin

      if (call_yylex) then
         toktype := YYLex;
         call_yylex := False;
         return toktype;
      end if;

      if ( eofseen ) then
         toktype := End_Of_Input;
      else
         toktype := YYLex;
      end if;

      -- this tracing code allows easy tracing of aflex runs
      if (trace) then
         Ada.Text_IO.New_Line (Standard_Error);
         Ada.Text_IO.Put (Standard_Error, "toktype = :" );
         Ada.Text_IO.Put (Standard_Error, Token'Image (toktype));
         Ada.Text_IO.Put_line (Standard_Error, ":" );
      end if;

      if ( toktype = End_Of_Input ) then
         eofseen := True;

         if sectnum = 1 then
            misc.synerr ("unexpected EOF");
            sectnum := 2;
            toktype := SECTEND;
         elsif sectnum = 2 then
            sectnum := 3;
            toktype := SECTEND;
         end if;
      end if;
    
      if trace then
         if beglin then
            Int_IO.Put (Standard_Error, num_rules + 1);
            Ada.Text_IO.Put (Standard_Error, ASCII.HT);
            beglin := False;
         end if;

         case toktype is
            when '<' | '>'|'^'|'$'|'"'|'['|']'|'{'|'}'|'|'|'('|
                 ')'|'-'|'/'|'?'|'.'|'*'|'+'|',' =>
               Ada.Text_IO.Put (Standard_Error, Token'Image (toktype));

            when NEWLINE =>
               Ada.Text_IO.New_Line (Standard_Error);
               if sectnum = 2 then
                  beglin := True;
               end if;

            when SCDECL =>
               Ada.Text_IO.Put (Standard_Error, "%s");

            when XSCDECL =>
               Ada.Text_IO.Put (Standard_Error, "%x");

            when WHITESPACE =>
               Ada.Text_IO.Put (Standard_Error, " ");

            when SECTEND =>
               Ada.Text_IO.Put_line (Standard_Error, "%%");

               --  we set beglin to be true so we'll start
               --  writing out numbers as we echo rules.  aflexscan() has
               --  already assigned sectnum

               if sectnum = 2 then
                  beglin := True;
               end if;

            when NAME =>
               Ada.Text_IO.Put (Standard_Error, ''');
               Ada.Text_IO.Put (Standard_Error, YYText);
               Ada.Text_IO.Put (Standard_Error, ''');

            when CHAR =>
               if ( (YYLVal < CHARACTER'POS(' ')) or
                  (YYLVal = CHARACTER'POS(ASCII.DEL)) ) then
                  Ada.Text_IO.Put (Standard_Error, '\');
                  Int_IO.Put (Standard_Error, YYLVal);
                  Ada.Text_IO.Put (Standard_Error, '\');
               else
                  Ada.Text_IO.Put (Standard_Error, Token'Image (toktype));
               end if;

            when NUMBER =>
               Int_IO.Put (Standard_Error, YYLVal);

            when OPTDECL =>
               Ada.Text_IO.Put (Standard_Error, "%option ");
               Ada.Text_IO.Put (Standard_Error, YYText);
               Ada.Text_IO.Put (Standard_Error, ''');

            when YYDECL =>
               Ada.Text_IO.Put (Standard_Error, "%yydecl ");
               Ada.Text_IO.Put (Standard_Error, YYText);
               Ada.Text_IO.Put (Standard_Error, ''');

            when YYCODEBLOCK =>
               Ada.Text_IO.Put (Standard_Error, "%<code> {");
               Ada.Text_IO.Put (Standard_Error, YYText);
               Ada.Text_IO.Put (Standard_Error, '}');

            when PREVCCL =>
               Ada.Text_IO.Put (Standard_Error, '[');
               Int_IO.Put (Standard_Error, YYLVal);
               Ada.Text_IO.Put (Standard_Error, ']');

            when End_Of_Input =>
               Ada.Text_IO.Put (Standard_Error, "End Marker");

            when others =>
               Ada.Text_IO.Put (Standard_Error, "Something weird:");
               Ada.Text_IO.Put_line (Standard_Error, Token'Image (toktype));
         end case;
      end if;
      return toktype;
   end get_token;

end scanner;

