
pragma Warnings (Off);
with Ada.Text_Io;
with misc_defs, misc, sym, parse_tokens, int_io;
with tstring, ascan_dfa, ascan_io;
with Template_Manager;
use misc_defs, parse_tokens, tstring;
use ascan_dfa, ascan_io;
package body scanner is

   use Ada;
   use Ada.Text_IO;

   beglin : Boolean := False;
   i, bracelevel: Integer;
   Code_Block_File   : Ada.Text_IO.File_Type;
   Code_Block_Start  : Natural;
   Code_Block_Active : Boolean := False;

   procedure Open_Code_Block (Name : in String) is
   begin
      Code_Block_Start := YYlineno + 1;
      Code_Block_Active := True;
      Ada.Text_IO.Open (Code_Block_File, Ada.Text_IO.Append_File, Name);

   exception
      when Name_Error =>
         Ada.Text_IO.Create (Code_Block_File, Ada.Text_IO.Append_File, Name);
   end Open_Code_Block;

   function get_token return Token is
      toktype : Token;
      didadef, indented_code : Boolean;
      cclval : Integer;
      nmdefptr : vstring;
      nmdef, tmpbuf : vstring;

      procedure ACTION_ECHO is
      begin
         Ada.Text_IO.Put (temp_action_file, yytext(1 .. YYLength));
      end ACTION_ECHO;

      procedure MARK_END_OF_PROLOG is
      begin
         Ada.Text_IO.Put (temp_action_file, "%%%% end of prolog");
         Ada.Text_IO.New_Line (temp_action_file);
      end MARK_END_OF_PROLOG;

      procedure PUT_BACK_STRING(str : vstring; start : Integer) is
      begin
         for i in reverse start + 1 .. tstring.len (str) loop
            unput (CHAR (str, i));
         end loop;
      end PUT_BACK_STRING;

      function check_yylex_here return Boolean is
      begin
         return ( (yytext'length >= 2) and then
                ((yytext(1) = '#') and (yytext(2) = '#')));
      end check_yylex_here;


   function YYLex return Token is
      subtype Short is Integer range -32768 .. 32767;

      --  returned upon end-of-file
      YY_END_TOK : constant Integer := 0;
      subtype yy_state_type is Integer;
      YY_END_OF_BUFFER : constant := 100;
      INITIAL : constant := 0;
      SECT2 : constant := 1;
      SECT2PROLOG : constant := 2;
      SECT3 : constant := 3;
      PICKUPDEF : constant := 4;
      SC : constant := 5;
      CARETISBOL : constant := 6;
      NUM : constant := 7;
      QUOTE : constant := 8;
      FIRSTCCL : constant := 9;
      CCL : constant := 10;
      ACTION : constant := 11;
      RECOVER : constant := 12;
      BRACEERROR : constant := 13;
      CODEBLOCK_MATCH_BRACE : constant := 14;
      ACTION_STRING : constant := 15;
      YYDECL_STRING : constant := 16;
      yy_accept : constant array (0 .. 291) of Short :=
          (0,
        0,    0,    0,    0,    0,    0,   93,   93,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,   26,   26,  100,   25,   10,   24,   22,    1,
       23,   25,   25,   25,   20,   52,   44,   45,   38,   52,
       51,   36,   52,   52,   52,   44,   34,   52,   52,   37,
       99,   32,   93,   93,   28,   27,   29,   58,   99,   54,
       55,   57,   59,   73,   74,   71,   70,   72,   60,   62,
       61,   60,   66,   65,   66,   66,   68,   68,   68,   69,
       79,   84,   83,   85,   79,   85,   80,   77,   78,   99,

       30,   76,   75,   97,   96,   99,   97,   95,   94,   86,
       88,   89,   90,   26,   10,   24,   22,    0,    0,    1,
       23,    0,    0,    2,    0,   17,    0,    7,    4,    6,
        5,    0,    0,   20,   44,   45,    0,   41,    0,    0,
        0,   91,   91,   40,   39,   40,    0,   44,   34,    0,
        0,   48,    0,    0,   32,   31,   93,   93,   28,   27,
       56,   57,   70,   92,   92,   63,   64,   67,   79,    0,
       82,    0,   79,   80,    0,   30,   97,   96,   86,   87,
       26,   21,   11,   11,    0,   17,    0,    0,    0,   18,
        0,    0,    0,    0,    0,    3,    0,   42,    0,   49,

        0,   91,   40,   40,   50,    0,    0,    0,   48,    0,
       43,   92,   79,   81,    0,   21,   11,    0,   19,    0,
       18,   18,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,   18,    0,    0,    6,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
       35,    0,   35,    0,   35,    0,    4,    0,    0,    0,
        0,    0,    9,    0,    0,    7,    0,    0,    0,   12,
        0,    0,    0,   47,    0,    8,   12,    0,   16,    0,
       13,    0,   15,    0,   16,   13,   15,    0,   14,   14,
        0

       );

      yy_ec : constant array (ASCII.NUL .. Character'Last) of Short := (0,
        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
        1,    4,    5,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    6,    1,    7,    8,    9,   10,    1,   11,   12,
       12,   12,   12,   13,   14,   15,   16,   17,   17,   17,
       17,   17,   17,   17,   17,   17,   17,    1,    1,   18,
       19,   20,   12,    1,   26,   27,   28,   29,   30,   31,
       27,   27,   32,   27,   27,   33,   27,   34,   35,   36,
       27,   37,   38,   39,   40,   41,   42,   43,   44,   27,
       21,   22,   23,   24,   25,    1,   26,   27,   28,   29,

       30,   31,   27,   27,   32,   27,   27,   33,   27,   34,
       35,   36,   27,   37,   38,   39,   40,   41,   42,   43,
       44,   27,   45,   46,   47,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,

        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1, others => 1

       );

      yy_meta : constant array (0 .. 47) of Short :=
          (0,
        1,    2,    3,    2,    4,    2,    5,    1,    1,    1,
        6,    1,    1,    7,    8,    6,    9,    1,   10,    1,
        4,   11,   12,    1,   13,   14,   14,   14,   14,   14,
       14,   14,   14,   14,   14,   14,   14,   14,   14,   14,
       14,   14,   14,   14,   15,    1,   16
       );

      yy_base : constant array (0 .. 341) of Short :=
          (0,
        0,   47,   93,  138,  835,  834,  833,  832,  114,  119,
      184,    0,  809,  808,  116,  229,  121,  124,  152,  155,
      158,  230,  276,    0,  827,  825,  104,  110,  321,  322,
      127,  232,  821,  819,  818, 1570,  234, 1570,   91,  245,
     1570,  814,  369,  802,  117, 1570,  415, 1570, 1570,  162,
     1570,  797,  790,  785,  461,  507, 1570,  790,  783, 1570,
      769,    0,  767, 1570,    0,  169, 1570, 1570, 1570, 1570,
      720,    0, 1570, 1570, 1570, 1570,  718, 1570, 1570, 1570,
     1570,  714, 1570, 1570,  709,  706, 1570,    0,  699, 1570,
        0, 1570, 1570,   90,  700, 1570,    0, 1570, 1570,  710,

     1570, 1570, 1570,    0, 1570,  705, 1570, 1570, 1570,    0,
     1570, 1570,    0,    0,  254, 1570,  163,    0,  668,  259,
     1570,  668,  673, 1570,  666,    0,  510,  513,  131,  235,
      228,  230,  666,  253,  520, 1570,  659, 1570,  631,   81,
      311, 1570,  643,    0, 1570,  553,  560,  525, 1570,  548,
      326,    0,  557,  543,    0, 1570,  540, 1570,    0,  329,
     1570,    0,  524, 1570,  523, 1570, 1570, 1570,    0,  319,
     1570,    0,  600,    0,  534, 1570,    0, 1570,    0, 1570,
        0,  521,  508,    0,  461,    0,  528,  646,  239,  344,
      326,  414,  416,  686,  450, 1570,  444, 1570,  409, 1570,

      330,  425,    0,    0, 1570,  424,  335,  420,    0,  428,
     1570,  411,    0, 1570,  728,  345,    0,  348, 1570,  651,
      352,  355,  419,  420,  512,  418,  514,  424,  532,  423,
      527,  308,  410,  267,  264,  252,  433,  563,  536,  529,
      645,  650,  653,  658,  541,  661,  657,  230,  314,  240,
     1570,  132, 1570,  123, 1570,  665,  652,  668,  669,  664,
      667,  681,  659,  671,   78,  674,  718,  753,  717,  439,
      754,  759,  762, 1570,  733,  769,  550,  774,  555,  775,
      780,  781,  786,  789,  792,  799,  804,  807,  819,  825,
     1570,  852,  868,  884,  900,  916,  932,  948,  964,  980,

      996, 1012, 1028, 1044, 1054, 1068, 1078, 1092, 1108, 1124,
     1140, 1156, 1172, 1188, 1198, 1212, 1228, 1244, 1260, 1272,
     1282, 1296, 1312, 1326, 1342, 1358,  350, 1366, 1380, 1395,
     1410, 1426, 1442, 1457, 1473, 1483, 1491, 1505, 1521, 1537,
     1553
       );

      yy_def : constant array (0 .. 341) of Short :=
          (0,
      291,  291,  292,  292,  293,  293,  294,  294,  295,  295,
      291,   11,  296,  296,  297,  297,  298,  298,  299,  299,
      300,  300,  291,   23,  301,  301,  296,  296,  302,  302,
      303,  303,  304,  304,  291,  291,  291,  291,  305,  291,
      291,  306,  291,  291,  307,  291,  291,  291,  291,  291,
      291,  291,  308,  309,  291,  310,  291,  291,  291,  291,
      311,  312,  313,  291,  314,  291,  291,  291,  291,  291,
      291,  315,  291,  291,  291,  291,  291,  291,  291,  291,
      291,  309,  291,  291,  316,  317,  291,  318,  309,  291,
      319,  291,  291,  320,  319,  291,  321,  291,  291,  322,

      291,  291,  291,  323,  291,  291,  291,  291,  291,  324,
      291,  291,  325,  326,  291,  291,  305,  327,  328,  291,
      291,  291,  306,  291,  291,  329,  330,  330,  128,  128,
      128,  128,  331,  307,  291,  291,  332,  291,  291,  308,
      308,  291,  291,  333,  291,  333,  291,  310,  291,  291,
      332,  334,  335,  311,  312,  291,  313,  291,  314,  291,
      291,  315,  291,  291,  291,  291,  291,  291,  319,  320,
      291,  320,  291,  321,  322,  291,  323,  291,  324,  291,
      326,  336,  291,  337,  338,  329,  291,  338,  128,  291,
      128,  128,  128,  128,  331,  291,  332,  291,  291,  291,

      308,  291,  333,  146,  291,  291,  335,  332,  334,  335,
      291,  291,  173,  291,  173,  336,  337,  338,  291,  338,
      338,  291,  128,  128,  128,  128,  128,  128,  128,  128,
      128,  291,  308,  339,  340,  341,  338,  128,  128,  128,
      128,  128,  128,  128,  128,  128,  128,  291,  308,  339,
      291,  340,  291,  341,  291,  128,  128,  128,  128,  330,
      128,  128,  128,  128,  291,  128,  128,  128,  291,  291,
      330,  330,  330,  291,  128,  291,  291,  291,  291,  291,
      291,  291,  291,  330,  291,  291,  291,  291,  291,  291,
        0,  291,  291,  291,  291,  291,  291,  291,  291,  291,

      291,  291,  291,  291,  291,  291,  291,  291,  291,  291,
      291,  291,  291,  291,  291,  291,  291,  291,  291,  291,
      291,  291,  291,  291,  291,  291,  291,  291,  291,  291,
      291,  291,  291,  291,  291,  291,  291,  291,  291,  291,
      291
       );

      yy_nxt : constant array (0 .. 1617) of Short :=
          (0,
       36,   37,   38,   37,   36,   37,   36,   36,   36,   36,
       36,   36,   36,   36,   36,   36,   36,   36,   36,   36,
       36,   36,   36,   36,   39,   39,   39,   39,   39,   39,
       39,   39,   39,   39,   39,   39,   39,   39,   39,   39,
       39,   39,   39,   39,   36,   36,   36,   36,   40,   41,
       40,   36,   40,   36,   42,   36,   43,   36,   36,   36,
       44,   36,   36,   36,   36,   36,   36,   36,   36,   36,
       36,   45,   45,   45,   45,   45,   45,   45,   45,   45,
       45,   45,   45,   45,   45,   45,   45,   45,   45,   45,
       45,   36,   36,   36,   47,   48,   47,  274,   47,   49,

      171,   50,  141,  200,   51,  118,  102,   51,   51,  119,
       52,  172,  102,   53,   54,   66,   67,   66,   75,   66,
       66,   67,   66,   80,   66,  255,   80,   81,   76,  111,
       81,  118,   77,  112,  253,  119,  187,   55,   51,   56,
       57,   56,   82,   56,   49,   82,   50,   58,  113,   51,
      103,   59,   51,   51,   69,   52,  103,   69,   53,   54,
       69,   60,   78,  138,  138,   84,  189,  138,   84,  192,
      160,   88,  160,   85,  160,   86,   85,  118,   86,   89,
       90,  119,   55,   51,   68,   68,   69,   68,   68,   68,
       68,   68,   68,   68,   68,   68,   70,   68,   68,   68,

       68,   68,   68,   71,   68,   68,   68,   68,   72,   72,
       72,   72,   72,   72,   72,   72,   72,   72,   72,   72,
       72,   72,   72,   72,   72,   72,   72,   72,   68,   68,
       68,   75,   69,  187,  111,  115,  116,  115,  112,  115,
      187,   76,  251,   88,  187,   77,  120,  121,  120,  265,
      120,   89,   90,  113,  255,  115,  116,  115,  122,  115,
      120,  121,  120,  189,  120,  189,  253,  118,  193,  251,
      189,  119,  122,  194,  189,   78,   91,   91,   92,   91,
       91,   91,   93,   91,   91,   91,   94,   91,   91,   95,
       91,   96,   91,   91,   91,   91,   91,   91,   91,   91,

       97,   97,   97,   97,   97,   97,   97,   97,   97,   97,
       97,   97,   97,   97,   97,   97,   97,   97,   97,   97,
       98,   91,   99,  105,  105,  106,  106,  201,  198,  171,
      160,  187,  160,  140,  160,  141,  200,  211,  248,  208,
      172,  107,  107,  107,  107,  222,  233,  222,  235,  222,
      219,  141,  200,  237,  219,  237,  222,  237,  222,  118,
      222,  189,  182,  182,  223,  108,  108,  109,  109,  125,
      125,  125,  125,  125,  125,  125,  125,  125,  126,  125,
      125,  125,  125,  125,  125,  125,  125,  125,  125,  125,
      125,  125,  125,  125,  127,  127,  127,  127,  127,  127,

      127,  127,  127,  128,  127,  127,  129,  127,  130,  127,
      127,  131,  132,  125,  125,  125,  135,  136,  135,  187,
      135,  187,  198,  187,  187,  187,  249,  164,  187,  187,
      211,  141,  200,  236,  237,  219,  237,  234,  237,  224,
      277,  142,  277,  232,  277,  241,  198,  225,  246,  189,
      238,  189,  196,  189,  189,  189,  239,  244,  189,  189,
      137,  144,  144,  219,  144,  144,  144,  144,  144,  144,
      144,  144,  144,  144,  144,  144,  144,  145,  144,  144,
      144,  144,  144,  144,  144,  146,  146,  146,  146,  146,
      146,  146,  146,  146,  146,  146,  146,  146,  146,  146,

      146,  146,  146,  146,  146,  144,  144,  144,  148,  149,
      148,  187,  148,  187,  187,  188,  187,  187,  188,  187,
      150,  135,  136,  135,  183,  135,  148,  149,  148,  187,
      148,  187,  187,  187,  187,  118,  176,  187,  150,  212,
      163,  187,  158,  242,  243,  155,  187,  189,  191,  189,
      240,  277,  151,  277,  190,  277,  285,  190,  285,  211,
      285,  207,  189,  247,  189,  137,  204,  189,  187,  204,
      151,  189,  190,  206,  257,  245,  262,  204,  204,  204,
      204,  204,  204,  204,  204,  204,  204,  204,  204,  204,
      204,  204,  204,  204,  204,  204,  204,  256,  189,  205,

      213,  213,  214,  213,  213,  213,  215,  213,  213,  213,
      215,  213,  213,  213,  213,  215,  213,  213,  213,  213,
      213,  213,  213,  213,  215,  215,  215,  215,  215,  215,
      215,  215,  215,  215,  215,  215,  215,  215,  215,  215,
      215,  215,  215,  215,  215,  213,  215,  220,  219,  220,
      187,  220,  220,  219,  220,  187,  220,  187,  187,  202,
      199,  198,  187,  187,  187,  269,  187,  269,  196,  269,
      187,  185,  187,  187,  187,  124,  187,  259,  260,  187,
      189,  133,  264,  258,  183,  189,  187,  189,  189,  261,
      221,  187,  189,  189,  189,  221,  189,  263,  266,  267,

      189,  268,  189,  189,  189,  271,  273,  178,  270,  189,
      272,  226,  176,  173,  227,  143,  189,  228,  269,  167,
      269,  189,  269,  187,  229,  165,  230,  231,  215,  215,
      143,  215,  215,  215,  163,  215,  215,  215,  187,  215,
      215,  215,  215,  161,  215,  215,  215,  215,  215,  215,
      215,  215,  275,  189,  276,  278,  276,  278,  276,  278,
      280,  270,  280,  282,  280,  282,  284,  282,  189,  158,
      276,  155,  276,  215,  276,  278,  280,  278,  280,  278,
      280,  286,  282,  286,  282,  286,  282,  287,  189,  287,
      288,  287,  288,  285,  288,  285,  153,  285,  279,  152,

      286,  143,  286,  281,  286,  287,  283,  287,  288,  287,
      288,  141,  288,  190,  139,  133,  124,  291,  279,  281,
      290,   69,  290,   69,  290,  283,  290,  101,  290,  101,
      290,   73,   73,  289,   64,   64,   62,   62,  291,  291,
      291,  291,  291,  291,  291,  291,  291,  291,  291,  291,
      291,  289,   46,   46,   46,   46,   46,   46,   46,   46,
       46,   46,   46,   46,   46,   46,   46,   46,   61,   61,
       61,   61,   61,   61,   61,   61,   61,   61,   61,   61,
       61,   61,   61,   61,   63,   63,   63,   63,   63,   63,
       63,   63,   63,   63,   63,   63,   63,   63,   63,   63,

       65,   65,   65,   65,   65,   65,   65,   65,   65,   65,
       65,   65,   65,   65,   65,   65,   69,   69,   69,   69,
       69,   69,   69,   69,   69,   69,   69,   69,   69,   69,
       69,   69,   74,   74,   74,   74,   74,   74,   74,   74,
       74,   74,   74,   74,   74,   74,   74,   74,   79,   79,
       79,   79,   79,   79,   79,   79,   79,   79,   79,   79,
       79,   79,   79,   79,   83,   83,   83,   83,   83,   83,
       83,   83,   83,   83,   83,   83,   83,   83,   83,   83,
       87,   87,   87,   87,   87,   87,   87,   87,   87,   87,
       87,   87,   87,   87,   87,   87,  100,  100,  100,  100,

      100,  100,  100,  100,  100,  100,  100,  100,  100,  100,
      100,  100,  104,  104,  104,  104,  104,  104,  104,  104,
      104,  104,  104,  104,  104,  104,  104,  104,  110,  110,
      110,  110,  110,  110,  110,  110,  110,  110,  110,  110,
      110,  110,  110,  110,  114,  114,  114,  114,  114,  114,
      114,  114,  114,  114,  114,  114,  114,  114,  114,  114,
      117,  117,  117,  117,  291,  291,  117,  117,  123,  123,
      123,  123,  123,  123,  123,  123,  123,  123,  123,  123,
      123,  123,  123,  123,  134,  134,  134,  134,  291,  291,
      134,  134,  140,  140,  291,  140,  140,  140,  140,  140,

      140,  140,  140,  291,  140,  140,  140,  140,  142,  142,
      291,  142,  142,  142,  142,  142,  142,  142,  142,  142,
      142,  142,  142,  142,  147,  147,  147,  147,  147,  147,
      147,  147,  147,  147,  147,  147,  147,  147,  147,  147,
      154,  154,  154,  154,  154,  154,  154,  154,  154,  154,
      154,  154,  154,  154,  154,  154,  156,  291,  291,  156,
      156,  156,  156,  156,  156,  156,  156,  156,  156,  156,
      156,  156,  157,  157,  157,  157,  157,  157,  157,  157,
      157,  157,  157,  157,  157,  157,  157,  157,  159,  159,
      291,  159,  159,  159,  159,  159,  159,  159,  159,  159,

      159,  159,  159,  159,  162,  291,  162,  291,  291,  291,
      162,  162,  164,  164,  291,  164,  164,  164,  164,  164,
      164,  164,  164,  164,  164,  164,  164,  164,  166,  166,
      291,  166,  166,  166,  166,  166,  166,  166,  166,  166,
      166,  166,  166,  166,  168,  168,  291,  168,  168,  168,
      168,  168,  168,  168,  168,  291,  168,  168,  168,  168,
      169,  169,  291,  169,  291,  291,  169,  169,  169,  169,
      169,  169,  170,  170,  291,  170,  170,  170,  170,  170,
      170,  170,  170,  170,  170,  170,  170,  170,  174,  291,
      174,  291,  291,  291,  174,  174,  175,  175,  175,  175,

      175,  175,  175,  175,  175,  175,  175,  175,  175,  175,
      175,  175,  177,  177,  291,  291,  177,  177,  177,  177,
      177,  177,  177,  291,  177,  177,  179,  179,  291,  179,
      291,  179,  179,  179,  179,  179,  291,  179,  179,  179,
      179,  179,  180,  180,  291,  180,  180,  180,  180,  180,
      180,  180,  180,  180,  180,  180,  180,  180,  181,  181,
      291,  181,  181,  181,  181,  181,  181,  181,  181,  181,
      181,  181,  181,  181,  184,  291,  291,  291,  184,  184,
      186,  186,  291,  186,  186,  186,  186,  186,  186,  186,
      186,  186,  186,  186,  186,  186,  189,  291,  291,  291,

      291,  291,  291,  291,  291,  291,  291,  291,  189,  189,
      195,  195,  195,  195,  195,  195,  195,  195,  195,  195,
      195,  195,  195,  195,  195,  195,  197,  197,  197,  197,
      197,  197,  197,  197,  197,  197,  197,  197,  197,  197,
      197,  197,  203,  203,  291,  203,  203,  203,  203,  203,
      203,  203,  203,  203,  203,  203,  203,  209,  209,  291,
      209,  209,  209,  209,  209,  209,  209,  209,  209,  209,
      209,  209,  209,  210,  210,  210,  210,  210,  210,  210,
      210,  210,  210,  210,  210,  210,  210,  210,  210,  216,
      216,  216,  291,  291,  291,  216,  216,  217,  291,  217,

      291,  291,  291,  217,  217,  218,  218,  218,  218,  218,
      218,  218,  218,  218,  218,  218,  218,  218,  218,  218,
      218,  250,  250,  250,  250,  250,  250,  250,  250,  250,
      250,  250,  250,  250,  250,  250,  250,  252,  252,  252,
      252,  252,  252,  252,  252,  252,  252,  252,  252,  252,
      252,  252,  252,  254,  254,  254,  254,  254,  254,  254,
      254,  254,  254,  254,  254,  254,  254,  254,  254,   35,
      291,  291,  291,  291,  291,  291,  291,  291,  291,  291,
      291,  291,  291,  291,  291,  291,  291,  291,  291,  291,
      291,  291,  291,  291,  291,  291,  291,  291,  291,  291,

      291,  291,  291,  291,  291,  291,  291,  291,  291,  291,
      291,  291,  291,  291,  291,  291,  291
       );

      yy_chk : constant array (0 .. 1617) of Short :=
          (0,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    2,    2,    2,
        2,    2,    2,    2,    2,    2,    2,    2,    2,    2,
        2,    2,    2,    2,    2,    2,    2,    2,    2,    2,
        2,    2,    2,    2,    2,    2,    2,    2,    2,    2,
        2,    2,    2,    2,    2,    2,    2,    2,    2,    2,
        2,    2,    2,    2,    3,    3,    3,  265,    3,    3,

       94,    3,  140,  140,    3,   39,   27,    3,    3,   39,
        3,   94,   28,    3,    3,    9,    9,    9,   15,    9,
       10,   10,   10,   17,   10,  254,   18,   17,   15,   31,
       18,   45,   15,   31,  252,   45,  129,    3,    3,    4,
        4,    4,   17,    4,    4,   18,    4,    4,   31,    4,
       27,    4,    4,    4,   19,    4,   28,   20,    4,    4,
       21,    4,   15,   50,   50,   19,  129,   50,   20,  129,
       66,   21,   66,   19,   66,   19,   20,  117,   20,   21,
       21,  117,    4,    4,   11,   11,   11,   11,   11,   11,
       11,   11,   11,   11,   11,   11,   11,   11,   11,   11,

       11,   11,   11,   11,   11,   11,   11,   11,   11,   11,
       11,   11,   11,   11,   11,   11,   11,   11,   11,   11,
       11,   11,   11,   11,   11,   11,   11,   11,   11,   11,
       11,   16,   22,  131,   32,   37,   37,   37,   32,   37,
      130,   16,  250,   22,  189,   16,   40,   40,   40,  248,
       40,   22,   22,   32,  236,  115,  115,  115,   40,  115,
      120,  120,  120,  131,  120,  132,  235,  134,  130,  234,
      130,  134,  120,  132,  189,   16,   23,   23,   23,   23,
       23,   23,   23,   23,   23,   23,   23,   23,   23,   23,
       23,   23,   23,   23,   23,   23,   23,   23,   23,   23,

       23,   23,   23,   23,   23,   23,   23,   23,   23,   23,
       23,   23,   23,   23,   23,   23,   23,   23,   23,   23,
       23,   23,   23,   29,   30,   29,   30,  141,  151,  170,
      160,  191,  160,  141,  160,  249,  249,  207,  232,  151,
      170,   29,   30,   29,   30,  190,  201,  190,  207,  190,
      218,  201,  201,  221,  221,  221,  222,  221,  222,  216,
      222,  191,  327,  327,  191,   29,   30,   29,   30,   43,
       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,

       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
       43,   43,   43,   43,   43,   43,   47,   47,   47,  192,
       47,  193,  208,  226,  223,  224,  233,  212,  230,  228,
      210,  233,  233,  208,  237,  237,  237,  206,  237,  192,
      270,  202,  270,  199,  270,  226,  197,  193,  230,  192,
      223,  193,  195,  226,  223,  224,  224,  228,  230,  228,
       47,   55,   55,  185,   55,   55,   55,   55,   55,   55,
       55,   55,   55,   55,   55,   55,   55,   55,   55,   55,
       55,   55,   55,   55,   55,   55,   55,   55,   55,   55,
       55,   55,   55,   55,   55,   55,   55,   55,   55,   55,

       55,   55,   55,   55,   55,   55,   55,   55,   56,   56,
       56,  127,   56,  127,  128,  127,  128,  225,  128,  227,
       56,  135,  135,  135,  183,  135,  148,  148,  148,  187,
      148,  187,  231,  187,  240,  182,  175,  229,  148,  165,
      163,  239,  157,  227,  227,  154,  245,  225,  128,  227,
      225,  277,   56,  277,  127,  277,  279,  128,  279,  153,
      279,  150,  231,  231,  240,  135,  146,  229,  238,  146,
      148,  239,  187,  147,  239,  229,  245,  146,  146,  146,
      146,  146,  146,  146,  146,  146,  146,  146,  146,  146,
      146,  146,  146,  146,  146,  146,  146,  238,  238,  146,

      173,  173,  173,  173,  173,  173,  173,  173,  173,  173,
      173,  173,  173,  173,  173,  173,  173,  173,  173,  173,
      173,  173,  173,  173,  173,  173,  173,  173,  173,  173,
      173,  173,  173,  173,  173,  173,  173,  173,  173,  173,
      173,  173,  173,  173,  173,  173,  173,  188,  188,  188,
      241,  188,  220,  220,  220,  242,  220,  257,  243,  143,
      139,  137,  247,  244,  263,  260,  246,  260,  133,  260,
      256,  125,  261,  258,  259,  123,  264,  242,  243,  266,
      241,  122,  247,  241,  119,  242,  262,  257,  243,  244,
      188,  194,  247,  244,  263,  220,  246,  246,  256,  258,

      256,  259,  261,  258,  259,  261,  264,  106,  260,  266,
      262,  194,  100,   95,  194,   89,  262,  194,  269,   86,
      269,  194,  269,  267,  194,   85,  194,  194,  215,  215,
       82,  215,  215,  215,   77,  215,  215,  215,  275,  215,
      215,  215,  215,   71,  215,  215,  215,  215,  215,  215,
      215,  215,  267,  267,  268,  271,  268,  271,  268,  271,
      272,  269,  272,  273,  272,  273,  275,  273,  275,   63,
      276,   61,  276,  215,  276,  278,  280,  278,  280,  278,
      280,  281,  282,  281,  282,  281,  282,  283,  268,  283,
      284,  283,  284,  285,  284,  285,   59,  285,  271,   58,

      286,   54,  286,  272,  286,  287,  273,  287,  288,  287,
      288,   53,  288,  276,   52,   44,   42,   35,  278,  280,
      289,   34,  289,   33,  289,  282,  290,   26,  290,   25,
      290,   14,   13,  284,    8,    7,    6,    5,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,  288,  292,  292,  292,  292,  292,  292,  292,  292,
      292,  292,  292,  292,  292,  292,  292,  292,  293,  293,
      293,  293,  293,  293,  293,  293,  293,  293,  293,  293,
      293,  293,  293,  293,  294,  294,  294,  294,  294,  294,
      294,  294,  294,  294,  294,  294,  294,  294,  294,  294,

      295,  295,  295,  295,  295,  295,  295,  295,  295,  295,
      295,  295,  295,  295,  295,  295,  296,  296,  296,  296,
      296,  296,  296,  296,  296,  296,  296,  296,  296,  296,
      296,  296,  297,  297,  297,  297,  297,  297,  297,  297,
      297,  297,  297,  297,  297,  297,  297,  297,  298,  298,
      298,  298,  298,  298,  298,  298,  298,  298,  298,  298,
      298,  298,  298,  298,  299,  299,  299,  299,  299,  299,
      299,  299,  299,  299,  299,  299,  299,  299,  299,  299,
      300,  300,  300,  300,  300,  300,  300,  300,  300,  300,
      300,  300,  300,  300,  300,  300,  301,  301,  301,  301,

      301,  301,  301,  301,  301,  301,  301,  301,  301,  301,
      301,  301,  302,  302,  302,  302,  302,  302,  302,  302,
      302,  302,  302,  302,  302,  302,  302,  302,  303,  303,
      303,  303,  303,  303,  303,  303,  303,  303,  303,  303,
      303,  303,  303,  303,  304,  304,  304,  304,  304,  304,
      304,  304,  304,  304,  304,  304,  304,  304,  304,  304,
      305,  305,  305,  305,    0,    0,  305,  305,  306,  306,
      306,  306,  306,  306,  306,  306,  306,  306,  306,  306,
      306,  306,  306,  306,  307,  307,  307,  307,    0,    0,
      307,  307,  308,  308,    0,  308,  308,  308,  308,  308,

      308,  308,  308,    0,  308,  308,  308,  308,  309,  309,
        0,  309,  309,  309,  309,  309,  309,  309,  309,  309,
      309,  309,  309,  309,  310,  310,  310,  310,  310,  310,
      310,  310,  310,  310,  310,  310,  310,  310,  310,  310,
      311,  311,  311,  311,  311,  311,  311,  311,  311,  311,
      311,  311,  311,  311,  311,  311,  312,    0,    0,  312,
      312,  312,  312,  312,  312,  312,  312,  312,  312,  312,
      312,  312,  313,  313,  313,  313,  313,  313,  313,  313,
      313,  313,  313,  313,  313,  313,  313,  313,  314,  314,
        0,  314,  314,  314,  314,  314,  314,  314,  314,  314,

      314,  314,  314,  314,  315,    0,  315,    0,    0,    0,
      315,  315,  316,  316,    0,  316,  316,  316,  316,  316,
      316,  316,  316,  316,  316,  316,  316,  316,  317,  317,
        0,  317,  317,  317,  317,  317,  317,  317,  317,  317,
      317,  317,  317,  317,  318,  318,    0,  318,  318,  318,
      318,  318,  318,  318,  318,    0,  318,  318,  318,  318,
      319,  319,    0,  319,    0,    0,  319,  319,  319,  319,
      319,  319,  320,  320,    0,  320,  320,  320,  320,  320,
      320,  320,  320,  320,  320,  320,  320,  320,  321,    0,
      321,    0,    0,    0,  321,  321,  322,  322,  322,  322,

      322,  322,  322,  322,  322,  322,  322,  322,  322,  322,
      322,  322,  323,  323,    0,    0,  323,  323,  323,  323,
      323,  323,  323,    0,  323,  323,  324,  324,    0,  324,
        0,  324,  324,  324,  324,  324,    0,  324,  324,  324,
      324,  324,  325,  325,    0,  325,  325,  325,  325,  325,
      325,  325,  325,  325,  325,  325,  325,  325,  326,  326,
        0,  326,  326,  326,  326,  326,  326,  326,  326,  326,
      326,  326,  326,  326,  328,    0,    0,    0,  328,  328,
      329,  329,    0,  329,  329,  329,  329,  329,  329,  329,
      329,  329,  329,  329,  329,  329,  330,    0,    0,    0,

        0,    0,    0,    0,    0,    0,    0,    0,  330,  330,
      331,  331,  331,  331,  331,  331,  331,  331,  331,  331,
      331,  331,  331,  331,  331,  331,  332,  332,  332,  332,
      332,  332,  332,  332,  332,  332,  332,  332,  332,  332,
      332,  332,  333,  333,    0,  333,  333,  333,  333,  333,
      333,  333,  333,  333,  333,  333,  333,  334,  334,    0,
      334,  334,  334,  334,  334,  334,  334,  334,  334,  334,
      334,  334,  334,  335,  335,  335,  335,  335,  335,  335,
      335,  335,  335,  335,  335,  335,  335,  335,  335,  336,
      336,  336,    0,    0,    0,  336,  336,  337,    0,  337,

        0,    0,    0,  337,  337,  338,  338,  338,  338,  338,
      338,  338,  338,  338,  338,  338,  338,  338,  338,  338,
      338,  339,  339,  339,  339,  339,  339,  339,  339,  339,
      339,  339,  339,  339,  339,  339,  339,  340,  340,  340,
      340,  340,  340,  340,  340,  340,  340,  340,  340,  340,
      340,  340,  340,  341,  341,  341,  341,  341,  341,  341,
      341,  341,  341,  341,  341,  341,  341,  341,  341,  291,
      291,  291,  291,  291,  291,  291,  291,  291,  291,  291,
      291,  291,  291,  291,  291,  291,  291,  291,  291,  291,
      291,  291,  291,  291,  291,  291,  291,  291,  291,  291,

      291,  291,  291,  291,  291,  291,  291,  291,  291,  291,
      291,  291,  291,  291,  291,  291,  291
       );

      yy_act : Integer;
      yy_c   : Short;
      yy_current_state : yy_state_type;

      --  copy whatever the last rule matched to the standard output
      procedure ECHO is
      begin
         if Ada.Text_IO.Is_Open (user_output_file) then
            Ada.Text_IO.Put (user_output_file, YYText);
         else
            Ada.Text_IO.Put (YYText);
         end if;
      end ECHO;

      --  enter a start condition.
      --  Using procedure requires a () after the ENTER, but makes everything
      --  much neater.

      procedure ENTER (state : Integer) is
      begin
         yy_start := 1 + 2 * state;
      end ENTER;

      --  action number for EOF rule of a given start state
      function YY_STATE_EOF (state : Integer) return Integer is
      begin
         return YY_END_OF_BUFFER + state + 1;
      end YY_STATE_EOF;

      --  return all but the first 'n' matched characters back to the input stream
      procedure yyless (n : Integer) is
      begin
         yy_ch_buf (yy_cp) := yy_hold_char; --  undo effects of setting up yytext
         yy_cp := yy_bp + n;
         yy_c_buf_p := yy_cp;
         YY_DO_BEFORE_ACTION; -- set up yytext again
      end yyless;

      --  yy_get_previous_state - get the state just before the EOB char was reached

      function yy_get_previous_state return yy_state_type is
         yy_current_state : yy_state_type;
         yy_c : Short;
         yy_bp : constant Integer := yytext_ptr;
      begin
         yy_current_state := yy_start;
         if yy_ch_buf (yy_bp - 1) = ASCII.LF then
            yy_current_state := yy_current_state + 1;
         end if;

         for yy_cp in yytext_ptr .. yy_c_buf_p - 1 loop
            yy_c := yy_ec (yy_ch_buf (yy_cp));
            if yy_accept (yy_current_state) /= 0 then
               yy_last_accepting_state := yy_current_state;
               yy_last_accepting_cpos := yy_cp;
               yy_last_yylineno := yylineno;
               yy_last_yylinecol := yylinecol;
            end if;
            while yy_chk (yy_base (yy_current_state) + yy_c) /= yy_current_state loop
               yy_current_state := yy_def (yy_current_state);
               if yy_current_state >= 292 then
                  yy_c := yy_meta (yy_c);
               end if;
            end loop;
            yy_current_state := yy_nxt (yy_base (yy_current_state) + yy_c);
         end loop;

         return yy_current_state;
      end yy_get_previous_state;

      procedure yyrestart (input_file : File_Type) is
      begin
         Open_Input (Ada.Text_IO.Name (input_file));
      end yyrestart;

   begin -- of YYLex
      <<new_file>>
      --  this is where we enter upon encountering an end-of-file and
      --  yyWrap () indicating that we should continue processing

      if yy_init then
         if yy_start = 0 then
            yy_start := 1;      -- first start state
         end if;

         --  we put in the '\n' and start reading from [1] so that an
         --  initial match-at-newline will be true.

         yy_ch_buf (0) := ASCII.LF;
         yy_n_chars := 1;

         --  we always need two end-of-buffer characters. The first causes
         --  a transition to the end-of-buffer state. The second causes
         --  a jam in that state.

         yy_ch_buf (yy_n_chars) := YY_END_OF_BUFFER_CHAR;
         yy_ch_buf (yy_n_chars + 1) := YY_END_OF_BUFFER_CHAR;

         yy_eof_has_been_seen := False;

         yytext_ptr := 1;
         yy_c_buf_p := yytext_ptr;
         yy_hold_char := yy_ch_buf (yy_c_buf_p);
         yy_init := False;
      end if; -- yy_init

      loop                -- loops until end-of-file is reached

         yy_cp := yy_c_buf_p;

         --  support of yytext
         yy_ch_buf (yy_cp) := yy_hold_char;

         --  yy_bp points to the position in yy_ch_buf of the start of the
         --  current run.
         yy_bp := yy_cp;
         yy_current_state := yy_start;
         if yy_ch_buf (yy_bp - 1) = ASCII.LF then
            yy_current_state := yy_current_state + 1;
         end if;
         loop
               yy_c := yy_ec (yy_ch_buf (yy_cp));
               if yy_accept (yy_current_state) /= 0 then
                  yy_last_accepting_state := yy_current_state;
                  yy_last_accepting_cpos := yy_cp;
                  yy_last_yylineno := yylineno;
                  yy_last_yylinecol := yylinecol;
               end if;
               while yy_chk (yy_base (yy_current_state) + yy_c) /= yy_current_state loop
                  yy_current_state := yy_def (yy_current_state);
                  if yy_current_state >= 292 then
                     yy_c := yy_meta (yy_c);
                  end if;
               end loop;
               yy_current_state := yy_nxt (yy_base (yy_current_state) + yy_c);
            if yy_ch_buf (yy_cp) = ASCII.LF then
               yylineno := yylineno + 1;
               yylinecol := 0;
            else
               yylinecol := yylinecol + 1;
            end if;
            yy_cp := yy_cp + 1;
            if yy_current_state = 291 then
                exit;
            end if;
         end loop;
         yy_cp := yy_last_accepting_cpos;
         yy_current_state := yy_last_accepting_state;
         yylineno := yy_last_yylineno;
         yylinecol := yy_last_yylinecol;

   <<next_action>>
         yy_act := yy_accept (yy_current_state);
         YY_DO_BEFORE_ACTION;

         if aflex_debug then  -- output acceptance info. for (-d) debug mode
            Ada.Text_IO.Put (Standard_Error, "  -- Aflex.YYLex accept rule #");
            Ada.Text_IO.Put (Standard_Error, Integer'Image (yy_act));
            Ada.Text_IO.Put_Line (Standard_Error, "(""" & YYText & """)");
         end if;

   <<do_action>>   -- this label is used only to access EOF actions
         case yy_act is

            when 0 => -- must backtrack
            -- undo the effects of YY_DO_BEFORE_ACTION
            yy_ch_buf (yy_cp) := yy_hold_char;
            yy_cp := yy_last_accepting_cpos;
            yylineno := yy_last_yylineno;
            yylinecol := yy_last_yylinecol;
            yy_current_state := yy_last_accepting_state;
            goto next_action;



         when 1 =>
--# line 64 "ascan.l"
             indented_code := True; 

         when 2 =>
--# line 65 "ascan.l"
             linenum := linenum + 1; ECHO;
                -- treat as a comment;
            

         when 3 =>
--# line 68 "ascan.l"
             linenum := linenum + 1; ECHO; 

         when 4 =>
--# line 69 "ascan.l"
             return SCDECL; 

         when 5 =>
--# line 70 "ascan.l"
             return XSCDECL; 

         when 6 =>
--# line 71 "ascan.l"
             return USCDECL; 

         when 7 =>
--# line 72 "ascan.l"
             return OPTDECL; 

         when 8 =>
--# line 73 "ascan.l"
             ENTER(YYDECL_STRING); return YYDECL; 

         when 9 =>
--# line 74 "ascan.l"
             return YYVAR; 

         when 10 =>
--# line 76 "ascan.l"
             return WHITESPACE; 

         when 11 =>
--# line 77 "ascan.l"
             nmstr := vstr(yytext(1..YYLength)); return OPTVAR; 

         when 12 =>
--# line 78 "ascan.l"
            
                  Open_Code_Block (Template_Manager.Get_Filename (Template_Manager.YYDFA_CODE));
                  ENTER(CODEBLOCK_MATCH_BRACE);


         when 13 =>
--# line 82 "ascan.l"
            
                  Open_Code_Block (Template_Manager.Get_Filename (Template_Manager.YYTYPE_CODE));
                  ENTER(CODEBLOCK_MATCH_BRACE);


         when 14 =>
--# line 86 "ascan.l"
            
                  Open_Code_Block (Template_Manager.Get_Filename (Template_Manager.YYACTION_CODE));
                  ENTER(CODEBLOCK_MATCH_BRACE);


         when 15 =>
--# line 90 "ascan.l"
            
                  Open_Code_Block (Template_Manager.Get_Filename (Template_Manager.YYWRAP_CODE));
                  ENTER(CODEBLOCK_MATCH_BRACE);


         when 16 =>
--# line 94 "ascan.l"
            
                  Open_Code_Block (Template_Manager.Get_Filename (Template_Manager.YYINIT_CODE));
                  ENTER(CODEBLOCK_MATCH_BRACE);


         when 17 =>
--# line 99 "ascan.l"
            
            sectnum := 2;
            misc.line_directive_out;
            ENTER(SECT2PROLOG);
            return SECTEND;
            

         when 18 =>
--# line 106 "ascan.l"
            
               misc.synerr ("unrecognized code block");
               ENTER(CODEBLOCK_MATCH_BRACE);
            

         when 19 =>
--# line 111 "ascan.l"
            
            Ada.Text_IO.Put( Standard_Error, "old-style lex command at line " );
            int_io.put( Standard_Error, linenum );
            Ada.Text_IO.Put( Standard_Error, " ignored:" );
            text_io.new_line( Standard_Error );
            Ada.Text_IO.Put( Standard_Error, ASCII.HT );
            Ada.Text_IO.Put( Standard_Error, yytext(1..YYLength) );
            linenum := linenum + 1;
            

         when 20 =>
--# line 121 "ascan.l"
            
            nmstr := vstr(yytext(1..YYLength));
            didadef := False;
            ENTER(PICKUPDEF);
            

         when 21 =>
--# line 127 "ascan.l"
             nmstr := vstr(yytext(1..YYLength));
              return UNAME;
            

         when 22 =>
--# line 131 "ascan.l"
             nmstr := vstr(yytext(1..YYLength));
              return NAME;
            

         when 23 =>
--# line 134 "ascan.l"
             linenum := linenum + 1;
              -- allows blank lines in section 1;
            

         when 24 =>
--# line 137 "ascan.l"
             linenum := linenum + 1; return Newline; 

         when 25 =>
--# line 138 "ascan.l"
             misc.synerr( "illegal character" );ENTER(RECOVER);

         when 26 =>
--# line 139 "ascan.l"
            
               nmstr := vstr(yytext(1..YYLength));
               ENTER(0);
               return NAME;
            

         when 27 =>
--# line 144 "ascan.l"
             null;
              -- separates name and definition;
            

         when 28 =>
--# line 148 "ascan.l"
            
            nmdef := vstr(yytext(1..YYLength));

            i := tstring.len( nmdef );
            while ( i >= tstring.first ) loop
                if ( (CHAR(nmdef,i) /= ' ') and
                 (CHAR(nmdef,i) /= ASCII.HT) ) then
                exit;
                end if;
                i := i - 1;
            end loop;

                        sym.ndinstal( nmstr,
                tstring.slice(nmdef, tstring.first, i) );
            didadef := True;
            

         when 29 =>
--# line 165 "ascan.l"
            
            if not didadef then
                misc.synerr( "incomplete name definition" );
            end if;
            ENTER(0);
            linenum := linenum + 1;
            

         when 30 =>
--# line 173 "ascan.l"
             linenum := linenum + 1;
              ENTER(0);
              nmstr := vstr(yytext(1..YYLength));
              return NAME;
            

         when 31 =>
            yy_ch_buf (yy_cp) := yy_hold_char; -- undo effects of setting up yytext
            yy_cp := yy_cp - 1;
            yy_c_buf_p := yy_cp;
            YY_DO_BEFORE_ACTION; -- set up yytext again
--# line 179 "ascan.l"
            
            linenum := linenum + 1;
            ACTION_ECHO;
            MARK_END_OF_PROLOG;
            ENTER(SECT2);
            

         when 32 =>
--# line 186 "ascan.l"
             linenum := linenum + 1; ACTION_ECHO; 

   when YY_END_OF_BUFFER +SECT2PROLOG + 1 
 =>
--# line 188 "ascan.l"
 MARK_END_OF_PROLOG;
              return End_Of_Input;
            

         when 34 =>
--# line 192 "ascan.l"
             linenum := linenum + 1;
              -- allow blank lines in sect2;

            -- this rule matches indented lines which
            -- are not comments.
         when 35 =>
--# line 197 "ascan.l"
            
            misc.synerr("indented code found outside of action");
            linenum := linenum + 1;
            

         when 36 =>
--# line 202 "ascan.l"
             ENTER(SC); return ( '<' ); 

         when 37 =>
--# line 203 "ascan.l"
             return ( '^' );  

         when 38 =>
--# line 204 "ascan.l"
             ENTER(QUOTE); return ( '"' ); 

         when 39 =>
            yy_ch_buf (yy_cp) := yy_hold_char; -- undo effects of setting up yytext
            yy_cp := yy_bp + 1;
            yy_c_buf_p := yy_cp;
            YY_DO_BEFORE_ACTION; -- set up yytext again
--# line 205 "ascan.l"
             ENTER(NUM); return ( '{' ); 

         when 40 =>
--# line 206 "ascan.l"
             ENTER(BRACEERROR); 

         when 41 =>
            yy_ch_buf (yy_cp) := yy_hold_char; -- undo effects of setting up yytext
            yy_cp := yy_bp + 1;
            yy_c_buf_p := yy_cp;
            YY_DO_BEFORE_ACTION; -- set up yytext again
--# line 207 "ascan.l"
             return '$'; 

         when 42 =>
--# line 209 "ascan.l"
             continued_action := True;
              linenum := linenum + 1;
              return Newline;
            

         when 43 =>
--# line 214 "ascan.l"
             linenum := linenum + 1; ACTION_ECHO; 

         when 44 =>
--# line 216 "ascan.l"
            
            -- this rule is separate from the one below because
            -- otherwise we get variable trailing context, so
            -- we can't build the scanner using -f,F

            bracelevel := 0;
            continued_action := False;
            ENTER(ACTION);
            return Newline;
            

         when 45 =>
            yy_ch_buf (yy_cp) := yy_hold_char; -- undo effects of setting up yytext
            yy_cp := yy_cp - 1;
            yy_c_buf_p := yy_cp;
            YY_DO_BEFORE_ACTION; -- set up yytext again
--# line 227 "ascan.l"
            
            bracelevel := 0;
            continued_action := False;
            ENTER(ACTION);
            return Newline;
            

         when 46 =>
--# line 234 "ascan.l"
             linenum := linenum + 1; return Newline; 

         when 47 =>
--# line 236 "ascan.l"
             return EOF_OP; 

         when 48 =>
--# line 238 "ascan.l"
            
            sectnum := 3;
            ENTER(SECT3);
            return End_Of_Input;
            -- to stop the parser
            

         when 49 =>
--# line 245 "ascan.l"
            

            nmstr := vstr(yytext(1..YYLength));

            -- check to see if we've already encountered this ccl
                        cclval := sym.ccllookup( nmstr );
            if ( cclval /= 0 ) then
                YYLVal := cclval;
                cclreuse := cclreuse + 1;
                return PREVCCL;
            else
                -- we fudge a bit.  We know that this ccl will
                -- soon be numbered as lastccl + 1 by cclinit
                sym.cclinstal( nmstr, lastccl + 1 );

                -- push back everything but the leading bracket
                -- so the ccl can be rescanned

                PUT_BACK_STRING(nmstr, 1);

                ENTER(FIRSTCCL);
                return '[';
            end if;
            

         when 50 =>
--# line 270 "ascan.l"
            
            nmstr := vstr(yytext(1..YYLength));
            -- chop leading and trailing brace
            tmpbuf := slice(vstr(yytext(1..YYLength)),
                                2, YYLength-1);

            nmdefptr := sym.ndlookup( tmpbuf );
            if ( nmdefptr = NUL ) then
                misc.synerr( "undefined {name}" );
            else
                -- push back name surrounded by ()'s
                unput(')');
                PUT_BACK_STRING(nmdefptr, 0);
                unput('(');
            end if;
            

         when 51 =>
--# line 287 "ascan.l"
             tmpbuf := vstr(yytext(1..YYLength));
              case tstring.CHAR(tmpbuf,1) is
                when '/' => return '/';
                when '|' => return '|';
                when '*' => return '*';
                when '+' => return '+';
                when '?' => return '?';
                when '.' => return '.';
                when '(' => return '(';
                when ')' => return ')';
                when others =>
                    misc.aflexerror("error in aflex case");
              end case;
            

         when 52 =>
--# line 301 "ascan.l"
             tmpbuf := vstr(yytext(1..YYLength));
              YYLVal := CHARACTER'POS(CHAR(tmpbuf,1));
              return CHAR;
            

         when 53 =>
--# line 305 "ascan.l"
             linenum := linenum + 1; return Newline; 

         when 54 =>
--# line 308 "ascan.l"
             return ( ',' ); 

         when 55 =>
--# line 309 "ascan.l"
             ENTER(SECT2); return ( '>' ); 

         when 56 =>
            yy_ch_buf (yy_cp) := yy_hold_char; -- undo effects of setting up yytext
            yy_cp := yy_bp + 1;
            yy_c_buf_p := yy_cp;
            YY_DO_BEFORE_ACTION; -- set up yytext again
--# line 310 "ascan.l"
             ENTER(CARETISBOL); return ( '>' ); 

         when 57 =>
--# line 311 "ascan.l"
             nmstr := vstr(yytext(1..YYLength));
              return NAME;
            

         when 58 =>
--# line 314 "ascan.l"
             misc.synerr( "bad start condition name" ); 

         when 59 =>
--# line 316 "ascan.l"
             ENTER(SECT2); return '^'; 

         when 60 =>
--# line 319 "ascan.l"
             tmpbuf := vstr(yytext(1..YYLength));
              YYLVal := CHARACTER'POS(CHAR(tmpbuf,1));
              return CHAR;
            

         when 61 =>
--# line 323 "ascan.l"
             ENTER(SECT2); return '"'; 

         when 62 =>
--# line 325 "ascan.l"
            
            misc.synerr( "missing quote" );
            ENTER(SECT2);
            linenum := linenum + 1;
            return '"';
            

         when 63 =>
            yy_ch_buf (yy_cp) := yy_hold_char; -- undo effects of setting up yytext
            yy_cp := yy_bp + 1;
            yy_c_buf_p := yy_cp;
            YY_DO_BEFORE_ACTION; -- set up yytext again
--# line 333 "ascan.l"
             ENTER(CCL); return '^'; 

         when 64 =>
            yy_ch_buf (yy_cp) := yy_hold_char; -- undo effects of setting up yytext
            yy_cp := yy_bp + 1;
            yy_c_buf_p := yy_cp;
            YY_DO_BEFORE_ACTION; -- set up yytext again
--# line 334 "ascan.l"
             return '^'; 

         when 65 =>
--# line 335 "ascan.l"
             ENTER(CCL); YYLVal := CHARACTER'POS('-'); return ( CHAR ); 

         when 66 =>
--# line 336 "ascan.l"
             ENTER(CCL);
              tmpbuf := vstr(yytext(1..YYLength));
              YYLVal := CHARACTER'POS(CHAR(tmpbuf,1));
              return CHAR;
            

         when 67 =>
            yy_ch_buf (yy_cp) := yy_hold_char; -- undo effects of setting up yytext
            yy_cp := yy_bp + 1;
            yy_c_buf_p := yy_cp;
            YY_DO_BEFORE_ACTION; -- set up yytext again
--# line 342 "ascan.l"
             return '-'; 

         when 68 =>
--# line 343 "ascan.l"
             tmpbuf := vstr(yytext(1..YYLength));
              YYLVal := CHARACTER'POS(CHAR(tmpbuf,1));
              return CHAR;
            

         when 69 =>
--# line 347 "ascan.l"
             ENTER(SECT2); return ']'; 

         when 70 =>
--# line 350 "ascan.l"
            
            YYLVal := misc.myctoi( vstr(yytext(1..YYLength)) );
            return NUMBER;
            

         when 71 =>
--# line 355 "ascan.l"
             return ','; 

         when 72 =>
--# line 356 "ascan.l"
             ENTER(SECT2); return '}'; 

         when 73 =>
--# line 358 "ascan.l"
            
            misc.synerr( "bad character inside {}'s" );
            ENTER(SECT2);
            return '}';
            

         when 74 =>
--# line 364 "ascan.l"
            
            misc.synerr( "missing }" );
            ENTER(SECT2);
            linenum := linenum + 1;
            return '}';
            

         when 75 =>
--# line 372 "ascan.l"
             misc.synerr( "bad name in {}'s" ); ENTER(SECT2); 

         when 76 =>
--# line 373 "ascan.l"
             misc.synerr( "missing }" );
              linenum := linenum + 1;
              ENTER(SECT2);
            

         when 77 =>
--# line 378 "ascan.l"
             bracelevel := bracelevel + 1; 

         when 78 =>
--# line 379 "ascan.l"
             bracelevel := bracelevel - 1; 

         when 79 =>
--# line 380 "ascan.l"
             ACTION_ECHO; 

         when 80 =>
--# line 381 "ascan.l"
             ACTION_ECHO; 

         when 81 =>
--# line 382 "ascan.l"
             linenum := linenum + 1; ACTION_ECHO; 

         when 82 =>
--# line 383 "ascan.l"
             ACTION_ECHO;
                  -- character constant;
            

         when 83 =>
--# line 387 "ascan.l"
             ACTION_ECHO; ENTER(ACTION_STRING); 

         when 84 =>
--# line 389 "ascan.l"
            
            linenum := linenum + 1;
            ACTION_ECHO;
            if bracelevel = 0 then
                text_io.new_line ( temp_action_file );
                ENTER(SECT2);
                    end if;
            

         when 85 =>
--# line 397 "ascan.l"
             ACTION_ECHO; 

         when 86 =>
--# line 399 "ascan.l"
             ACTION_ECHO; 

         when 87 =>
--# line 400 "ascan.l"
             ACTION_ECHO; 

         when 88 =>
--# line 401 "ascan.l"
             linenum := linenum + 1; ACTION_ECHO; 

         when 89 =>
--# line 402 "ascan.l"
             ACTION_ECHO; ENTER(ACTION); 

         when 90 =>
--# line 403 "ascan.l"
             ACTION_ECHO; 

         when 91 =>
--# line 406 "ascan.l"
            
            YYLVal := CHARACTER'POS(misc.myesc( vstr(yytext(1..YYLength)) ));
            return ( CHAR );
            

         when 92 =>
--# line 411 "ascan.l"
            
            YYLVal := CHARACTER'POS(misc.myesc( vstr(yytext(1..YYLength)) ));
            ENTER(CCL);
            return CHAR;
            

         when 93 =>
--# line 418 "ascan.l"
             if check_yylex_here then
                return End_Of_Input;
              else
                ECHO;
              end if;
            

         when 94 =>
--# line 425 "ascan.l"
            
                if Code_Block_Active then
                   Ada.Text_IO.Close (Code_Block_File);
                   Code_Block_Active := False;
                end if;
                ENTER(0);
                return YYCODEBLOCK;
            

         when 95 =>
--# line 434 "ascan.l"
            
                --  brace_depth++;
                if Code_Block_Active then
                   Ada.Text_IO.Put (Code_Block_File, YYText);
                end if;
            

         when 96 =>
--# line 441 "ascan.l"
            
                Linenum := Linenum + 1;
                if Code_Block_Active then
                   Ada.Text_IO.New_Line (Code_Block_File);
                end if;
            

         when 97 =>
--# line 448 "ascan.l"
            
                Linenum := Linenum + 1; 
                if Code_Block_Active then
                   Ada.Text_IO.Put (Code_Block_File, YYText);
                end if;
            

   when YY_END_OF_BUFFER +CODEBLOCK_MATCH_BRACE + 1 
 =>
--# line 455 "ascan.l"

                misc.synerr ("unmatched '{' at line" & Natural'Image (Code_Block_Start));
                if Code_Block_Active then
                   Ada.Text_IO.Close (Code_Block_File);
                end if;
                ENTER(0);
                return YYCODEBLOCK;
            

         when 99 =>
--# line 464 "ascan.l"
            ECHO;
         when YY_END_OF_BUFFER + INITIAL + 1 |
              YY_END_OF_BUFFER + SECT2 + 1 |
              YY_END_OF_BUFFER + SECT3 + 1 |
              YY_END_OF_BUFFER + PICKUPDEF + 1 |
              YY_END_OF_BUFFER + SC + 1 |
              YY_END_OF_BUFFER + CARETISBOL + 1 |
              YY_END_OF_BUFFER + NUM + 1 |
              YY_END_OF_BUFFER + QUOTE + 1 |
              YY_END_OF_BUFFER + FIRSTCCL + 1 |
              YY_END_OF_BUFFER + CCL + 1 |
              YY_END_OF_BUFFER + ACTION + 1 |
              YY_END_OF_BUFFER + RECOVER + 1 |
              YY_END_OF_BUFFER + BRACEERROR + 1 |
              YY_END_OF_BUFFER + ACTION_STRING + 1 |
              YY_END_OF_BUFFER + YYDECL_STRING + 1 =>
            return End_Of_Input;

         when YY_END_OF_BUFFER =>
            --  undo the effects of YY_DO_BEFORE_ACTION
            yy_ch_buf (yy_cp) := yy_hold_char;

            yytext_ptr := yy_bp;

            case yy_get_next_buffer is
               when EOB_ACT_END_OF_FILE =>
                  if yyWrap then
                     --  note: because we've taken care in
                     --  yy_get_next_buffer() to have set up yytext,
                     --  we can now set up yy_c_buf_p so that if some
                     --  total hoser (like aflex itself) wants
                     --  to call the scanner after we return the
                     --  End_Of_Input, it'll still work - another
                     --  End_Of_Input will get returned.

                     yy_c_buf_p := yytext_ptr;

                     yy_act := YY_STATE_EOF ((yy_start - 1) / 2);

                     goto do_action;
                  else
                     --  start processing a new file
                     yy_init := True;
                     goto new_file;
                  end if;

               when EOB_ACT_RESTART_SCAN =>
                  yy_c_buf_p := yytext_ptr;
                  yy_hold_char := yy_ch_buf (yy_c_buf_p);

               when EOB_ACT_LAST_MATCH =>
                  yy_c_buf_p := yy_n_chars;
                  yy_current_state := yy_get_previous_state;
                  yy_cp := yy_c_buf_p;
                  yy_bp := yytext_ptr;
                  goto next_action;
            end case; --  case yy_get_next_buffer()

         when others =>
            Ada.Text_IO.Put ("action # ");
            Ada.Text_IO.Put (Integer'Image (yy_act));
            Ada.Text_IO.New_Line;
            raise AFLEX_INTERNAL_ERROR;
         end case; --  case (yy_act)
      end loop; --  end of loop waiting for end of file
   end YYLex;

--# line 464 "ascan.l"
   begin

      if (call_yylex) then
         toktype := YYLex;
         call_yylex := False;
         return toktype;
      end if;

      if ( eofseen ) then
         toktype := End_Of_Input;
      else
         toktype := YYLex;
      end if;

      -- this tracing code allows easy tracing of aflex runs
      if (trace) then
         Ada.Text_IO.New_Line (Standard_Error);
         Ada.Text_IO.Put (Standard_Error, "toktype = :" );
         Ada.Text_IO.Put (Standard_Error, Token'Image (toktype));
         Ada.Text_IO.Put_line (Standard_Error, ":" );
      end if;

      if ( toktype = End_Of_Input ) then
         eofseen := True;

         if sectnum = 1 then
            misc.synerr ("unexpected EOF");
            sectnum := 2;
            toktype := SECTEND;
         elsif sectnum = 2 then
            sectnum := 3;
            toktype := SECTEND;
         end if;
      end if;
    
      if trace then
         if beglin then
            Int_IO.Put (Standard_Error, num_rules + 1);
            Ada.Text_IO.Put (Standard_Error, ASCII.HT);
            beglin := False;
         end if;

         case toktype is
            when '<' | '>'|'^'|'$'|'"'|'['|']'|'{'|'}'|'|'|'('|
                 ')'|'-'|'/'|'?'|'.'|'*'|'+'|',' =>
               Ada.Text_IO.Put (Standard_Error, Token'Image (toktype));

            when NEWLINE =>
               Ada.Text_IO.New_Line (Standard_Error);
               if sectnum = 2 then
                  beglin := True;
               end if;

            when SCDECL =>
               Ada.Text_IO.Put (Standard_Error, "%s");

            when XSCDECL =>
               Ada.Text_IO.Put (Standard_Error, "%x");

            when WHITESPACE =>
               Ada.Text_IO.Put (Standard_Error, " ");

            when SECTEND =>
               Ada.Text_IO.Put_line (Standard_Error, "%%");

               --  we set beglin to be true so we'll start
               --  writing out numbers as we echo rules.  aflexscan() has
               --  already assigned sectnum

               if sectnum = 2 then
                  beglin := True;
               end if;

            when NAME =>
               Ada.Text_IO.Put (Standard_Error, ''');
               Ada.Text_IO.Put (Standard_Error, YYText);
               Ada.Text_IO.Put (Standard_Error, ''');

            when CHAR =>
               if ( (YYLVal < CHARACTER'POS(' ')) or
                  (YYLVal = CHARACTER'POS(ASCII.DEL)) ) then
                  Ada.Text_IO.Put (Standard_Error, '\');
                  Int_IO.Put (Standard_Error, YYLVal);
                  Ada.Text_IO.Put (Standard_Error, '\');
               else
                  Ada.Text_IO.Put (Standard_Error, Token'Image (toktype));
               end if;

            when NUMBER =>
               Int_IO.Put (Standard_Error, YYLVal);

            when OPTDECL =>
               Ada.Text_IO.Put (Standard_Error, "%option ");
               Ada.Text_IO.Put (Standard_Error, YYText);
               Ada.Text_IO.Put (Standard_Error, ''');

            when YYDECL =>
               Ada.Text_IO.Put (Standard_Error, "%yydecl ");
               Ada.Text_IO.Put (Standard_Error, YYText);
               Ada.Text_IO.Put (Standard_Error, ''');

            when YYCODEBLOCK =>
               Ada.Text_IO.Put (Standard_Error, "%<code> {");
               Ada.Text_IO.Put (Standard_Error, YYText);
               Ada.Text_IO.Put (Standard_Error, '}');

            when PREVCCL =>
               Ada.Text_IO.Put (Standard_Error, '[');
               Int_IO.Put (Standard_Error, YYLVal);
               Ada.Text_IO.Put (Standard_Error, ']');

            when End_Of_Input =>
               Ada.Text_IO.Put (Standard_Error, "End Marker");

            when others =>
               Ada.Text_IO.Put (Standard_Error, "Something weird:");
               Ada.Text_IO.Put_line (Standard_Error, Token'Image (toktype));
         end case;
      end if;
      return toktype;
   end get_token;

end scanner;

