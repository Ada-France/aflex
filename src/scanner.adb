
pragma Warnings (Off);
with Ada.Text_Io;
with misc_defs, misc, sym, parse_tokens, int_io;
with tstring, ascan_dfa, ascan_io;
with Template_Manager;
use misc_defs, parse_tokens, tstring;
use ascan_dfa, ascan_io;
package body scanner is

   use Ada;
   use Ada.Text_IO;

   beglin : Boolean := False;
   i, bracelevel: Integer;
   Code_Block_File   : Ada.Text_IO.File_Type;
   Code_Block_Start  : Natural;
   Code_Block_Active : Boolean := False;

   procedure Open_Code_Block (Name : in String) is
   begin
      Code_Block_Start := YYlineno + 1;
      Code_Block_Active := True;
      Ada.Text_IO.Open (Code_Block_File, Ada.Text_IO.Append_File, Name);

   exception
      when Name_Error =>
         Ada.Text_IO.Create (Code_Block_File, Ada.Text_IO.Append_File, Name);
   end Open_Code_Block;

   function get_token return Token is
      toktype : Token;
      didadef, indented_code : Boolean;
      cclval : Integer;
      nmdefptr : vstring;
      nmdef, tmpbuf : vstring;

      procedure ACTION_ECHO is
      begin
         Ada.Text_IO.Put (temp_action_file, yytext(1 .. YYLength));
      end ACTION_ECHO;

      procedure MARK_END_OF_PROLOG is
      begin
         Ada.Text_IO.Put (temp_action_file, "%%%% end of prolog");
         Ada.Text_IO.New_Line (temp_action_file);
      end MARK_END_OF_PROLOG;

      procedure PUT_BACK_STRING(str : vstring; start : Integer) is
      begin
         for i in reverse start + 1 .. tstring.len (str) loop
            unput (CHAR (str, i));
         end loop;
      end PUT_BACK_STRING;

      function check_yylex_here return Boolean is
      begin
         return ( (yytext'length >= 2) and then
                ((yytext(1) = '#') and (yytext(2) = '#')));
      end check_yylex_here;


   function YYLex return Token is
      subtype Short is Integer range -32768 .. 32767;

      --  returned upon end-of-file
      YY_END_TOK : constant Integer := 0;
      subtype yy_state_type is Integer;
      YY_END_OF_BUFFER : constant := 99;
      INITIAL : constant := 0;
      SECT2 : constant := 1;
      SECT2PROLOG : constant := 2;
      SECT3 : constant := 3;
      PICKUPDEF : constant := 4;
      SC : constant := 5;
      CARETISBOL : constant := 6;
      NUM : constant := 7;
      QUOTE : constant := 8;
      FIRSTCCL : constant := 9;
      CCL : constant := 10;
      ACTION : constant := 11;
      RECOVER : constant := 12;
      BRACEERROR : constant := 13;
      CODEBLOCK_MATCH_BRACE : constant := 14;
      ACTION_STRING : constant := 15;
      YYDECL_STRING : constant := 16;
      yy_accept : constant array (0 .. 284) of Short :=
          (0,
        0,    0,    0,    0,    0,    0,   92,   92,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,   25,   25,   99,   24,   10,   23,   21,    1,
       22,   24,   24,   24,   19,   51,   43,   44,   37,   51,
       50,   35,   51,   51,   51,   43,   33,   51,   51,   36,
       98,   31,   92,   92,   27,   26,   28,   57,   98,   53,
       54,   56,   58,   72,   73,   70,   69,   71,   59,   61,
       60,   59,   65,   64,   65,   65,   67,   67,   67,   68,
       78,   83,   82,   84,   78,   84,   79,   76,   77,   98,

       29,   75,   74,   96,   95,   98,   96,   94,   93,   85,
       87,   88,   89,   25,   10,   23,   21,    0,    0,    1,
       22,    0,    0,    2,    0,   16,    0,    7,    4,    6,
        5,    0,    0,   19,   43,   44,    0,   40,    0,    0,
        0,   90,   90,   39,   38,   39,    0,   43,   33,    0,
        0,   47,    0,    0,   31,   30,   92,   92,   27,   26,
       55,   56,   69,   91,   91,   62,   63,   66,   78,    0,
       81,    0,   78,   79,    0,   29,   96,   95,   85,   86,
       25,   20,   11,    0,   16,    0,    0,    0,   17,    0,
        0,    0,    0,    0,    3,    0,   41,    0,   48,    0,

       90,   39,   39,   49,    0,    0,    0,   47,    0,   42,
       91,   78,   80,    0,   20,    0,   18,    0,   17,   17,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,   17,    0,    0,    6,    0,    0,
        0,    0,    0,    0,    0,    0,    0,   34,    0,   34,
        0,   34,    0,    4,    0,    0,    0,    0,    9,    0,
        0,    7,    0,    0,    0,    0,    0,   46,    0,    8,
        0,   15,    0,   12,    0,   14,    0,   15,   12,   14,
        0,   13,   13,    0
       );

      yy_ec : constant array (ASCII.NUL .. Character'Last) of Short := (0,
        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
        1,    4,    5,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    6,    1,    7,    8,    9,   10,    1,   11,   12,
       12,   12,   12,   13,   14,   15,   16,   17,   17,   17,
       17,   17,   17,   17,   17,   17,   17,    1,    1,   18,
       19,   20,   12,    1,   26,   27,   28,   29,   30,   31,
       27,   27,   32,   27,   27,   33,   27,   34,   35,   36,
       27,   37,   38,   39,   40,   41,   42,   43,   44,   27,
       21,   22,   23,   24,   25,    1,   26,   27,   28,   29,

       30,   31,   27,   27,   32,   27,   27,   33,   27,   34,
       35,   36,   27,   37,   38,   39,   40,   41,   42,   43,
       44,   27,   45,   46,   47,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,

        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1, others => 1

       );

      yy_meta : constant array (0 .. 47) of Short :=
          (0,
        1,    2,    3,    2,    4,    2,    5,    1,    1,    1,
        6,    1,    1,    7,    8,    6,    7,    1,    9,    1,
        4,   10,   11,    1,   12,   13,   13,   13,   13,   13,
       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
       13,   13,   13,   13,   14,    1,   15
       );

      yy_base : constant array (0 .. 332) of Short :=
          (0,
        0,   47,   93,  138,  817,  815,  814,  812,  114,  119,
      184,    0,  790,  789,  116,  229,  121,  124,  152,  155,
      158,  230,  276,    0,  809,  808,  104,  110,  321,  322,
      127,  232,  805,  804,  806, 1485,  234, 1485,   91,  245,
     1485,  802,  369,  790,  117, 1485,  415, 1485, 1485,  162,
     1485,  784,  779,  783,  461,  507, 1485,  789,  782, 1485,
      791,    0,  769, 1485,    0,  169, 1485, 1485, 1485, 1485,
      737,    0, 1485, 1485, 1485, 1485,  727, 1485, 1485, 1485,
     1485,  722, 1485, 1485,  714,  712, 1485,    0,  707, 1485,
        0, 1485, 1485,   90,  706, 1485,    0, 1485, 1485,  711,

     1485, 1485, 1485,    0, 1485,  705, 1485, 1485, 1485,    0,
     1485, 1485,    0,    0,  254, 1485,  163,    0,  668,  259,
     1485,  668,  673, 1485,  665,    0,  510,  513,  131,  235,
      228,  230,  663,  253,  520, 1485,  659, 1485,  630,   81,
      311, 1485,  582,    0, 1485,  553,  584,  525, 1485,  548,
      326,    0,  557,  543,    0, 1485,  541, 1485,    0,  329,
     1485,    0,  526, 1485,  524, 1485, 1485, 1485,    0,  319,
     1485,    0,  600,    0,  534, 1485,    0, 1485,    0, 1485,
        0,  521,  508,  461,    0,  528,  646,  239,  344,  326,
      414,  416,  686,  446, 1485,  444, 1485,  409, 1485,  330,

      425,    0,    0, 1485,  424,  335,  420,    0,  428, 1485,
      411,    0, 1485,  728,  345,  348, 1485,  651,  352,  355,
      419,  420,  512,  418,  423,  424,  532,  514,  527,  308,
      410,  267,  264,  252,  433,  539,  645,  529,  650,  541,
      658,  536,  661,  652,  230,  314,  240, 1485,  132, 1485,
      123, 1485,  659,  663,  668,  669,  667,  671,  673,  674,
       78,  677,  681,  717,  666,  752,  753, 1485,  729,  758,
      764,  439,  765,  550,  771,  555,  774,  657,  777,  780,
      783,  786,  789, 1485,  828,  843,  858,  873,  888,  903,
      918,  933,  948,  963,  978,  993, 1008, 1017, 1030, 1039,

     1052, 1067, 1082, 1097, 1112, 1127, 1142, 1151, 1164, 1179,
     1194, 1209, 1220, 1229, 1242, 1257, 1270, 1285, 1300,  351,
     1315, 1329, 1343, 1358, 1373, 1387, 1402, 1411, 1424, 1439,
     1454, 1469
       );

      yy_def : constant array (0 .. 332) of Short :=
          (0,
      284,  284,  285,  285,  286,  286,  287,  287,  288,  288,
      284,   11,  289,  289,  290,  290,  291,  291,  292,  292,
      293,  293,  284,   23,  294,  294,  289,  289,  295,  295,
      296,  296,  297,  297,  284,  284,  284,  284,  298,  284,
      284,  299,  284,  284,  300,  284,  284,  284,  284,  284,
      284,  284,  301,  302,  284,  303,  284,  284,  284,  284,
      304,  305,  306,  284,  307,  284,  284,  284,  284,  284,
      284,  308,  284,  284,  284,  284,  284,  284,  284,  284,
      284,  302,  284,  284,  309,  310,  284,  311,  302,  284,
      312,  284,  284,  313,  312,  284,  314,  284,  284,  315,

      284,  284,  284,  316,  284,  284,  284,  284,  284,  317,
      284,  284,  318,  319,  284,  284,  298,  320,  284,  284,
      284,  284,  299,  284,  284,  321,  322,  322,  128,  128,
      128,  128,  323,  300,  284,  284,  324,  284,  284,  301,
      301,  284,  284,  325,  284,  325,  284,  303,  284,  284,
      324,  326,  327,  304,  305,  284,  306,  284,  307,  284,
      284,  308,  284,  284,  284,  284,  284,  284,  312,  313,
      284,  313,  284,  314,  315,  284,  316,  284,  317,  284,
      319,  328,  284,  329,  321,  284,  329,  128,  284,  128,
      128,  128,  128,  323,  284,  324,  284,  284,  284,  301,

      284,  325,  146,  284,  284,  327,  324,  326,  327,  284,
      284,  173,  284,  173,  328,  329,  284,  329,  329,  284,
      128,  128,  128,  128,  128,  128,  128,  128,  128,  284,
      301,  330,  331,  332,  329,  128,  128,  128,  128,  128,
      128,  128,  128,  128,  284,  301,  330,  284,  331,  284,
      332,  284,  128,  128,  128,  128,  128,  128,  128,  128,
      284,  128,  128,  128,  322,  322,  322,  284,  128,  284,
      284,  284,  284,  284,  284,  284,  322,  284,  284,  284,
      284,  284,  284,    0,  284,  284,  284,  284,  284,  284,
      284,  284,  284,  284,  284,  284,  284,  284,  284,  284,

      284,  284,  284,  284,  284,  284,  284,  284,  284,  284,
      284,  284,  284,  284,  284,  284,  284,  284,  284,  284,
      284,  284,  284,  284,  284,  284,  284,  284,  284,  284,
      284,  284
       );

      yy_nxt : constant array (0 .. 1532) of Short :=
          (0,
       36,   37,   38,   37,   36,   37,   36,   36,   36,   36,
       36,   36,   36,   36,   36,   36,   36,   36,   36,   36,
       36,   36,   36,   36,   39,   39,   39,   39,   39,   39,
       39,   39,   39,   39,   39,   39,   39,   39,   39,   39,
       39,   39,   39,   39,   36,   36,   36,   36,   40,   41,
       40,   36,   40,   36,   42,   36,   43,   36,   36,   36,
       44,   36,   36,   36,   36,   36,   36,   36,   36,   36,
       36,   45,   45,   45,   45,   45,   45,   45,   45,   45,
       45,   45,   45,   45,   45,   45,   45,   45,   45,   45,
       45,   36,   36,   36,   47,   48,   47,  268,   47,   49,

      171,   50,  141,  199,   51,  118,  102,   51,   51,  119,
       52,  172,  102,   53,   54,   66,   67,   66,   75,   66,
       66,   67,   66,   80,   66,  252,   80,   81,   76,  111,
       81,  118,   77,  112,  250,  119,  186,   55,   51,   56,
       57,   56,   82,   56,   49,   82,   50,   58,  113,   51,
      103,   59,   51,   51,   69,   52,  103,   69,   53,   54,
       69,   60,   78,  138,  138,   84,  188,  138,   84,  191,
      160,   88,  160,   85,  160,   86,   85,  118,   86,   89,
       90,  119,   55,   51,   68,   68,   69,   68,   68,   68,
       68,   68,   68,   68,   68,   68,   70,   68,   68,   68,

       68,   68,   68,   71,   68,   68,   68,   68,   72,   72,
       72,   72,   72,   72,   72,   72,   72,   72,   72,   72,
       72,   72,   72,   72,   72,   72,   72,   72,   68,   68,
       68,   75,   69,  186,  111,  115,  116,  115,  112,  115,
      186,   76,  248,   88,  186,   77,  120,  121,  120,  261,
      120,   89,   90,  113,  252,  115,  116,  115,  122,  115,
      120,  121,  120,  188,  120,  188,  250,  118,  192,  248,
      188,  119,  122,  193,  188,   78,   91,   91,   92,   91,
       91,   91,   93,   91,   91,   91,   94,   91,   91,   95,
       91,   96,   91,   91,   91,   91,   91,   91,   91,   91,

       97,   97,   97,   97,   97,   97,   97,   97,   97,   97,
       97,   97,   97,   97,   97,   97,   97,   97,   97,   97,
       98,   91,   99,  105,  105,  106,  106,  200,  197,  171,
      160,  186,  160,  140,  160,  141,  199,  210,  245,  207,
      172,  107,  107,  107,  107,  220,  231,  220,  233,  220,
      217,  141,  199,  235,  217,  235,  220,  235,  220,  118,
      220,  188,  182,  182,  221,  108,  108,  109,  109,  125,
      125,  125,  125,  125,  125,  125,  125,  125,  126,  125,
      125,  125,  125,  125,  125,  125,  125,  125,  125,  125,
      125,  125,  125,  125,  127,  127,  127,  127,  127,  127,

      127,  127,  127,  128,  127,  127,  129,  127,  130,  127,
      127,  131,  132,  125,  125,  125,  135,  136,  135,  186,
      135,  186,  197,  186,  186,  186,  246,  164,  186,  186,
      210,  141,  199,  234,  235,  217,  235,  232,  235,  222,
      278,  142,  278,  230,  278,  239,  197,  223,  195,  188,
      236,  188,  240,  188,  188,  188,  237,  241,  188,  188,
      137,  144,  144,  217,  144,  144,  144,  144,  144,  144,
      144,  144,  144,  144,  144,  144,  144,  145,  144,  144,
      144,  144,  144,  144,  144,  146,  146,  146,  146,  146,
      146,  146,  146,  146,  146,  146,  146,  146,  146,  146,

      146,  146,  146,  146,  146,  144,  144,  144,  148,  149,
      148,  186,  148,  186,  186,  187,  186,  186,  187,  186,
      150,  135,  136,  135,  183,  135,  148,  149,  148,  186,
      148,  186,  186,  186,  186,  118,  176,  186,  150,  243,
      211,  186,  163,  158,  186,  155,  186,  188,  190,  188,
      238,  279,  151,  279,  189,  279,  280,  189,  280,  210,
      280,  206,  188,  244,  188,  137,  203,  188,  256,  203,
      151,  258,  189,  253,  188,  242,  188,  203,  203,  203,
      203,  203,  203,  203,  203,  203,  203,  203,  203,  203,
      203,  203,  203,  203,  203,  203,  203,  205,  201,  204,

      212,  212,  213,  212,  212,  212,  214,  212,  212,  212,
      214,  212,  212,  212,  212,  214,  212,  212,  212,  212,
      212,  212,  212,  212,  214,  214,  214,  214,  214,  214,
      214,  214,  214,  214,  214,  214,  214,  214,  214,  214,
      214,  214,  214,  214,  214,  212,  214,  218,  217,  218,
      186,  218,  218,  217,  218,  186,  218,  186,  278,  198,
      278,  197,  278,  186,  186,  195,  186,  271,  186,  271,
      184,  271,  186,  186,  186,  124,  186,  260,  186,  186,
      188,  133,  186,  254,  183,  188,  186,  188,  255,  257,
      219,  186,  262,  188,  188,  219,  188,  259,  188,  263,

      266,  264,  188,  188,  188,  265,  188,  178,  188,  267,
      272,  224,  188,  176,  225,  269,  188,  226,  270,  173,
      270,  188,  270,  143,  227,  167,  228,  229,  214,  214,
      165,  214,  214,  214,  186,  214,  214,  214,  143,  214,
      214,  214,  214,  163,  214,  214,  214,  214,  214,  214,
      214,  214,  188,  273,  275,  273,  275,  273,  275,  270,
      161,  270,  277,  270,  188,  271,  273,  271,  273,  271,
      273,  158,  275,  214,  275,  281,  275,  281,  279,  281,
      279,  280,  279,  280,  281,  280,  281,  283,  281,  283,
      283,  283,  283,  155,  283,  153,  274,  276,  152,  143,

      141,  139,  189,  133,  124,  284,   69,   69,  272,  274,
      101,  101,   73,   73,   64,  276,   64,   62,  282,   62,
      284,  284,  284,  284,  284,  284,  284,  282,   46,   46,
       46,   46,   46,   46,   46,   46,   46,   46,   46,   46,
       46,   46,   46,   61,   61,   61,   61,   61,   61,   61,
       61,   61,   61,   61,   61,   61,   61,   61,   63,   63,
       63,   63,   63,   63,   63,   63,   63,   63,   63,   63,
       63,   63,   63,   65,   65,   65,   65,   65,   65,   65,
       65,   65,   65,   65,   65,   65,   65,   65,   69,   69,
       69,   69,   69,   69,   69,   69,   69,   69,   69,   69,

       69,   69,   69,   74,   74,   74,   74,   74,   74,   74,
       74,   74,   74,   74,   74,   74,   74,   74,   79,   79,
       79,   79,   79,   79,   79,   79,   79,   79,   79,   79,
       79,   79,   79,   83,   83,   83,   83,   83,   83,   83,
       83,   83,   83,   83,   83,   83,   83,   83,   87,   87,
       87,   87,   87,   87,   87,   87,   87,   87,   87,   87,
       87,   87,   87,  100,  100,  100,  100,  100,  100,  100,
      100,  100,  100,  100,  100,  100,  100,  100,  104,  104,
      104,  104,  104,  104,  104,  104,  104,  104,  104,  104,
      104,  104,  104,  110,  110,  110,  110,  110,  110,  110,

      110,  110,  110,  110,  110,  110,  110,  110,  114,  114,
      114,  114,  114,  114,  114,  114,  114,  114,  114,  114,
      114,  114,  114,  117,  117,  117,  284,  284,  117,  117,
      123,  123,  123,  123,  123,  123,  123,  123,  123,  123,
      123,  123,  123,  123,  123,  134,  134,  134,  284,  284,
      134,  134,  140,  140,  284,  140,  140,  140,  140,  140,
      140,  140,  284,  140,  140,  140,  140,  142,  142,  284,
      142,  142,  142,  142,  142,  142,  142,  142,  142,  142,
      142,  142,  147,  147,  147,  147,  147,  147,  147,  147,
      147,  147,  147,  147,  147,  147,  147,  154,  154,  154,

      154,  154,  154,  154,  154,  154,  154,  154,  154,  154,
      154,  154,  156,  284,  284,  156,  156,  156,  156,  156,
      156,  156,  156,  156,  156,  156,  156,  157,  157,  157,
      157,  157,  157,  157,  157,  157,  157,  157,  157,  157,
      157,  157,  159,  159,  284,  159,  159,  159,  159,  159,
      159,  159,  159,  159,  159,  159,  159,  162,  284,  284,
      284,  284,  162,  162,  164,  164,  284,  164,  164,  164,
      164,  164,  164,  164,  164,  164,  164,  164,  164,  166,
      166,  284,  166,  166,  166,  166,  166,  166,  166,  166,
      166,  166,  166,  166,  168,  168,  284,  168,  168,  168,

      168,  168,  168,  168,  284,  168,  168,  168,  168,  169,
      169,  284,  169,  284,  284,  169,  169,  169,  169,  169,
      170,  170,  284,  170,  170,  170,  170,  170,  170,  170,
      170,  170,  170,  170,  170,  174,  284,  284,  284,  284,
      174,  174,  175,  175,  175,  175,  175,  175,  175,  175,
      175,  175,  175,  175,  175,  175,  175,  177,  177,  284,
      284,  177,  177,  177,  177,  177,  177,  284,  177,  177,
      179,  179,  284,  179,  284,  179,  179,  179,  179,  284,
      179,  179,  179,  179,  179,  180,  180,  284,  180,  180,
      180,  180,  180,  180,  180,  180,  180,  180,  180,  180,

      181,  181,  284,  181,  181,  181,  181,  181,  181,  181,
      181,  181,  181,  181,  181,  185,  185,  284,  185,  185,
      185,  185,  185,  185,  185,  185,  185,  185,  185,  185,
      188,  284,  284,  284,  284,  284,  284,  284,  284,  284,
      284,  188,  188,  194,  194,  194,  194,  194,  194,  194,
      194,  194,  194,  194,  194,  194,  194,  194,  196,  196,
      196,  196,  196,  196,  196,  196,  196,  196,  196,  196,
      196,  196,  196,  202,  202,  284,  202,  202,  202,  202,
      202,  202,  202,  202,  202,  202,  202,  208,  208,  284,
      208,  208,  208,  208,  208,  208,  208,  208,  208,  208,

      208,  208,  209,  209,  209,  209,  209,  209,  209,  209,
      209,  209,  209,  209,  209,  209,  209,  215,  215,  284,
      284,  284,  215,  215,  216,  216,  216,  216,  216,  216,
      216,  216,  216,  216,  216,  216,  216,  216,  216,  247,
      247,  247,  247,  247,  247,  247,  247,  247,  247,  247,
      247,  247,  247,  247,  249,  249,  249,  249,  249,  249,
      249,  249,  249,  249,  249,  249,  249,  249,  249,  251,
      251,  251,  251,  251,  251,  251,  251,  251,  251,  251,
      251,  251,  251,  251,   35,  284,  284,  284,  284,  284,
      284,  284,  284,  284,  284,  284,  284,  284,  284,  284,

      284,  284,  284,  284,  284,  284,  284,  284,  284,  284,
      284,  284,  284,  284,  284,  284,  284,  284,  284,  284,
      284,  284,  284,  284,  284,  284,  284,  284,  284,  284,
      284,  284
       );

      yy_chk : constant array (0 .. 1532) of Short :=
          (0,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    2,    2,    2,
        2,    2,    2,    2,    2,    2,    2,    2,    2,    2,
        2,    2,    2,    2,    2,    2,    2,    2,    2,    2,
        2,    2,    2,    2,    2,    2,    2,    2,    2,    2,
        2,    2,    2,    2,    2,    2,    2,    2,    2,    2,
        2,    2,    2,    2,    3,    3,    3,  261,    3,    3,

       94,    3,  140,  140,    3,   39,   27,    3,    3,   39,
        3,   94,   28,    3,    3,    9,    9,    9,   15,    9,
       10,   10,   10,   17,   10,  251,   18,   17,   15,   31,
       18,   45,   15,   31,  249,   45,  129,    3,    3,    4,
        4,    4,   17,    4,    4,   18,    4,    4,   31,    4,
       27,    4,    4,    4,   19,    4,   28,   20,    4,    4,
       21,    4,   15,   50,   50,   19,  129,   50,   20,  129,
       66,   21,   66,   19,   66,   19,   20,  117,   20,   21,
       21,  117,    4,    4,   11,   11,   11,   11,   11,   11,
       11,   11,   11,   11,   11,   11,   11,   11,   11,   11,

       11,   11,   11,   11,   11,   11,   11,   11,   11,   11,
       11,   11,   11,   11,   11,   11,   11,   11,   11,   11,
       11,   11,   11,   11,   11,   11,   11,   11,   11,   11,
       11,   16,   22,  131,   32,   37,   37,   37,   32,   37,
      130,   16,  247,   22,  188,   16,   40,   40,   40,  245,
       40,   22,   22,   32,  234,  115,  115,  115,   40,  115,
      120,  120,  120,  131,  120,  132,  233,  134,  130,  232,
      130,  134,  120,  132,  188,   16,   23,   23,   23,   23,
       23,   23,   23,   23,   23,   23,   23,   23,   23,   23,
       23,   23,   23,   23,   23,   23,   23,   23,   23,   23,

       23,   23,   23,   23,   23,   23,   23,   23,   23,   23,
       23,   23,   23,   23,   23,   23,   23,   23,   23,   23,
       23,   23,   23,   29,   30,   29,   30,  141,  151,  170,
      160,  190,  160,  141,  160,  246,  246,  206,  230,  151,
      170,   29,   30,   29,   30,  189,  200,  189,  206,  189,
      216,  200,  200,  219,  219,  219,  220,  219,  220,  215,
      220,  190,  320,  320,  190,   29,   30,   29,   30,   43,
       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,

       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
       43,   43,   43,   43,   43,   43,   47,   47,   47,  191,
       47,  192,  207,  224,  221,  222,  231,  211,  225,  226,
      209,  231,  231,  207,  235,  235,  235,  205,  235,  191,
      272,  201,  272,  198,  272,  224,  196,  192,  194,  191,
      221,  192,  225,  224,  221,  222,  222,  226,  225,  226,
       47,   55,   55,  184,   55,   55,   55,   55,   55,   55,
       55,   55,   55,   55,   55,   55,   55,   55,   55,   55,
       55,   55,   55,   55,   55,   55,   55,   55,   55,   55,
       55,   55,   55,   55,   55,   55,   55,   55,   55,   55,

       55,   55,   55,   55,   55,   55,   55,   55,   56,   56,
       56,  127,   56,  127,  128,  127,  128,  223,  128,  228,
       56,  135,  135,  135,  183,  135,  148,  148,  148,  186,
      148,  186,  229,  186,  238,  182,  175,  227,  148,  228,
      165,  242,  163,  157,  236,  154,  240,  223,  128,  228,
      223,  274,   56,  274,  127,  274,  276,  128,  276,  153,
      276,  150,  229,  229,  238,  135,  146,  227,  240,  146,
      148,  242,  186,  236,  236,  227,  240,  146,  146,  146,
      146,  146,  146,  146,  146,  146,  146,  146,  146,  146,
      146,  146,  146,  146,  146,  146,  146,  147,  143,  146,

      173,  173,  173,  173,  173,  173,  173,  173,  173,  173,
      173,  173,  173,  173,  173,  173,  173,  173,  173,  173,
      173,  173,  173,  173,  173,  173,  173,  173,  173,  173,
      173,  173,  173,  173,  173,  173,  173,  173,  173,  173,
      173,  173,  173,  173,  173,  173,  173,  187,  187,  187,
      237,  187,  218,  218,  218,  239,  218,  244,  278,  139,
      278,  137,  278,  241,  253,  133,  243,  265,  254,  265,
      125,  265,  257,  255,  256,  123,  258,  244,  259,  260,
      237,  122,  262,  237,  119,  239,  263,  244,  239,  241,
      187,  193,  253,  241,  253,  218,  243,  243,  254,  255,

      258,  256,  257,  255,  256,  257,  258,  106,  259,  260,
      265,  193,  262,  100,  193,  263,  263,  193,  264,   95,
      264,  193,  264,   89,  193,   86,  193,  193,  214,  214,
       85,  214,  214,  214,  269,  214,  214,  214,   82,  214,
      214,  214,  214,   77,  214,  214,  214,  214,  214,  214,
      214,  214,  264,  266,  267,  266,  267,  266,  267,  270,
       71,  270,  269,  270,  269,  271,  273,  271,  273,  271,
      273,   63,  275,  214,  275,  277,  275,  277,  279,  277,
      279,  280,  279,  280,  281,  280,  281,  282,  281,  282,
      283,  282,  283,   61,  283,   59,  266,  267,   58,   54,

       53,   52,  270,   44,   42,   35,   34,   33,  271,  273,
       26,   25,   14,   13,    8,  275,    7,    6,  277,    5,
        0,    0,    0,    0,    0,    0,    0,  281,  285,  285,
      285,  285,  285,  285,  285,  285,  285,  285,  285,  285,
      285,  285,  285,  286,  286,  286,  286,  286,  286,  286,
      286,  286,  286,  286,  286,  286,  286,  286,  287,  287,
      287,  287,  287,  287,  287,  287,  287,  287,  287,  287,
      287,  287,  287,  288,  288,  288,  288,  288,  288,  288,
      288,  288,  288,  288,  288,  288,  288,  288,  289,  289,
      289,  289,  289,  289,  289,  289,  289,  289,  289,  289,

      289,  289,  289,  290,  290,  290,  290,  290,  290,  290,
      290,  290,  290,  290,  290,  290,  290,  290,  291,  291,
      291,  291,  291,  291,  291,  291,  291,  291,  291,  291,
      291,  291,  291,  292,  292,  292,  292,  292,  292,  292,
      292,  292,  292,  292,  292,  292,  292,  292,  293,  293,
      293,  293,  293,  293,  293,  293,  293,  293,  293,  293,
      293,  293,  293,  294,  294,  294,  294,  294,  294,  294,
      294,  294,  294,  294,  294,  294,  294,  294,  295,  295,
      295,  295,  295,  295,  295,  295,  295,  295,  295,  295,
      295,  295,  295,  296,  296,  296,  296,  296,  296,  296,

      296,  296,  296,  296,  296,  296,  296,  296,  297,  297,
      297,  297,  297,  297,  297,  297,  297,  297,  297,  297,
      297,  297,  297,  298,  298,  298,    0,    0,  298,  298,
      299,  299,  299,  299,  299,  299,  299,  299,  299,  299,
      299,  299,  299,  299,  299,  300,  300,  300,    0,    0,
      300,  300,  301,  301,    0,  301,  301,  301,  301,  301,
      301,  301,    0,  301,  301,  301,  301,  302,  302,    0,
      302,  302,  302,  302,  302,  302,  302,  302,  302,  302,
      302,  302,  303,  303,  303,  303,  303,  303,  303,  303,
      303,  303,  303,  303,  303,  303,  303,  304,  304,  304,

      304,  304,  304,  304,  304,  304,  304,  304,  304,  304,
      304,  304,  305,    0,    0,  305,  305,  305,  305,  305,
      305,  305,  305,  305,  305,  305,  305,  306,  306,  306,
      306,  306,  306,  306,  306,  306,  306,  306,  306,  306,
      306,  306,  307,  307,    0,  307,  307,  307,  307,  307,
      307,  307,  307,  307,  307,  307,  307,  308,    0,    0,
        0,    0,  308,  308,  309,  309,    0,  309,  309,  309,
      309,  309,  309,  309,  309,  309,  309,  309,  309,  310,
      310,    0,  310,  310,  310,  310,  310,  310,  310,  310,
      310,  310,  310,  310,  311,  311,    0,  311,  311,  311,

      311,  311,  311,  311,    0,  311,  311,  311,  311,  312,
      312,    0,  312,    0,    0,  312,  312,  312,  312,  312,
      313,  313,    0,  313,  313,  313,  313,  313,  313,  313,
      313,  313,  313,  313,  313,  314,    0,    0,    0,    0,
      314,  314,  315,  315,  315,  315,  315,  315,  315,  315,
      315,  315,  315,  315,  315,  315,  315,  316,  316,    0,
        0,  316,  316,  316,  316,  316,  316,    0,  316,  316,
      317,  317,    0,  317,    0,  317,  317,  317,  317,    0,
      317,  317,  317,  317,  317,  318,  318,    0,  318,  318,
      318,  318,  318,  318,  318,  318,  318,  318,  318,  318,

      319,  319,    0,  319,  319,  319,  319,  319,  319,  319,
      319,  319,  319,  319,  319,  321,  321,    0,  321,  321,
      321,  321,  321,  321,  321,  321,  321,  321,  321,  321,
      322,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,  322,  322,  323,  323,  323,  323,  323,  323,  323,
      323,  323,  323,  323,  323,  323,  323,  323,  324,  324,
      324,  324,  324,  324,  324,  324,  324,  324,  324,  324,
      324,  324,  324,  325,  325,    0,  325,  325,  325,  325,
      325,  325,  325,  325,  325,  325,  325,  326,  326,    0,
      326,  326,  326,  326,  326,  326,  326,  326,  326,  326,

      326,  326,  327,  327,  327,  327,  327,  327,  327,  327,
      327,  327,  327,  327,  327,  327,  327,  328,  328,    0,
        0,    0,  328,  328,  329,  329,  329,  329,  329,  329,
      329,  329,  329,  329,  329,  329,  329,  329,  329,  330,
      330,  330,  330,  330,  330,  330,  330,  330,  330,  330,
      330,  330,  330,  330,  331,  331,  331,  331,  331,  331,
      331,  331,  331,  331,  331,  331,  331,  331,  331,  332,
      332,  332,  332,  332,  332,  332,  332,  332,  332,  332,
      332,  332,  332,  332,  284,  284,  284,  284,  284,  284,
      284,  284,  284,  284,  284,  284,  284,  284,  284,  284,

      284,  284,  284,  284,  284,  284,  284,  284,  284,  284,
      284,  284,  284,  284,  284,  284,  284,  284,  284,  284,
      284,  284,  284,  284,  284,  284,  284,  284,  284,  284,
      284,  284
       );

      yy_act : Integer;
      yy_c   : Short;
      yy_current_state : yy_state_type;

      --  copy whatever the last rule matched to the standard output
      procedure ECHO is
      begin
         if Ada.Text_IO.Is_Open (user_output_file) then
            Ada.Text_IO.Put (user_output_file, YYText);
         else
            Ada.Text_IO.Put (YYText);
         end if;
      end ECHO;

      --  enter a start condition.
      --  Using procedure requires a () after the ENTER, but makes everything
      --  much neater.

      procedure ENTER (state : Integer) is
      begin
         yy_start := 1 + 2 * state;
      end ENTER;

      --  action number for EOF rule of a given start state
      function YY_STATE_EOF (state : Integer) return Integer is
      begin
         return YY_END_OF_BUFFER + state + 1;
      end YY_STATE_EOF;

      --  return all but the first 'n' matched characters back to the input stream
      procedure yyless (n : Integer) is
      begin
         yy_ch_buf (yy_cp) := yy_hold_char; --  undo effects of setting up yytext
         yy_cp := yy_bp + n;
         yy_c_buf_p := yy_cp;
         YY_DO_BEFORE_ACTION; -- set up yytext again
      end yyless;

      --  yy_get_previous_state - get the state just before the EOB char was reached

      function yy_get_previous_state return yy_state_type is
         yy_current_state : yy_state_type;
         yy_c : Short;
         yy_bp : constant Integer := yytext_ptr;
      begin
         yy_current_state := yy_start;
         if yy_ch_buf (yy_bp - 1) = ASCII.LF then
            yy_current_state := yy_current_state + 1;
         end if;

         for yy_cp in yytext_ptr .. yy_c_buf_p - 1 loop
            yy_c := yy_ec (yy_ch_buf (yy_cp));
            if yy_accept (yy_current_state) /= 0 then
               yy_last_accepting_state := yy_current_state;
               yy_last_accepting_cpos := yy_cp;
               yy_last_yylineno := yylineno;
               yy_last_yylinecol := yylinecol;
            end if;
            while yy_chk (yy_base (yy_current_state) + yy_c) /= yy_current_state loop
               yy_current_state := yy_def (yy_current_state);
               if yy_current_state >= 285 then
                  yy_c := yy_meta (yy_c);
               end if;
            end loop;
            yy_current_state := yy_nxt (yy_base (yy_current_state) + yy_c);
         end loop;

         return yy_current_state;
      end yy_get_previous_state;

      procedure yyrestart (input_file : File_Type) is
      begin
         Open_Input (Ada.Text_IO.Name (input_file));
      end yyrestart;

   begin -- of YYLex
      <<new_file>>
      --  this is where we enter upon encountering an end-of-file and
      --  yyWrap () indicating that we should continue processing

      if yy_init then
         if yy_start = 0 then
            yy_start := 1;      -- first start state
         end if;

         --  we put in the '\n' and start reading from [1] so that an
         --  initial match-at-newline will be true.

         yy_ch_buf (0) := ASCII.LF;
         yy_n_chars := 1;

         --  we always need two end-of-buffer characters. The first causes
         --  a transition to the end-of-buffer state. The second causes
         --  a jam in that state.

         yy_ch_buf (yy_n_chars) := YY_END_OF_BUFFER_CHAR;
         yy_ch_buf (yy_n_chars + 1) := YY_END_OF_BUFFER_CHAR;

         yy_eof_has_been_seen := False;

         yytext_ptr := 1;
         yy_c_buf_p := yytext_ptr;
         yy_hold_char := yy_ch_buf (yy_c_buf_p);
         yy_init := False;
      end if; -- yy_init

      loop                -- loops until end-of-file is reached

         yy_cp := yy_c_buf_p;

         --  support of yytext
         yy_ch_buf (yy_cp) := yy_hold_char;

         --  yy_bp points to the position in yy_ch_buf of the start of the
         --  current run.
         yy_bp := yy_cp;
         yy_current_state := yy_start;
         if yy_ch_buf (yy_bp - 1) = ASCII.LF then
            yy_current_state := yy_current_state + 1;
         end if;
         loop
               yy_c := yy_ec (yy_ch_buf (yy_cp));
               if yy_accept (yy_current_state) /= 0 then
                  yy_last_accepting_state := yy_current_state;
                  yy_last_accepting_cpos := yy_cp;
                  yy_last_yylineno := yylineno;
                  yy_last_yylinecol := yylinecol;
               end if;
               while yy_chk (yy_base (yy_current_state) + yy_c) /= yy_current_state loop
                  yy_current_state := yy_def (yy_current_state);
                  if yy_current_state >= 285 then
                     yy_c := yy_meta (yy_c);
                  end if;
               end loop;
               yy_current_state := yy_nxt (yy_base (yy_current_state) + yy_c);
            if yy_ch_buf (yy_cp) = ASCII.LF then
               yylineno := yylineno + 1;
               yylinecol := 0;
            else
               yylinecol := yylinecol + 1;
            end if;
            yy_cp := yy_cp + 1;
            if yy_current_state = 284 then
                exit;
            end if;
         end loop;
         yy_cp := yy_last_accepting_cpos;
         yy_current_state := yy_last_accepting_state;
         yylineno := yy_last_yylineno;
         yylinecol := yy_last_yylinecol;

   <<next_action>>
         yy_act := yy_accept (yy_current_state);
         YY_DO_BEFORE_ACTION;

         if aflex_debug then  -- output acceptance info. for (-d) debug mode
            Ada.Text_IO.Put (Standard_Error, "  -- Aflex.YYLex accept rule #");
            Ada.Text_IO.Put (Standard_Error, Integer'Image (yy_act));
            Ada.Text_IO.Put_Line (Standard_Error, "(""" & YYText & """)");
         end if;

   <<do_action>>   -- this label is used only to access EOF actions
         case yy_act is

            when 0 => -- must backtrack
            -- undo the effects of YY_DO_BEFORE_ACTION
            yy_ch_buf (yy_cp) := yy_hold_char;
            yy_cp := yy_last_accepting_cpos;
            yylineno := yy_last_yylineno;
            yylinecol := yy_last_yylinecol;
            yy_current_state := yy_last_accepting_state;
            goto next_action;



         when 1 =>
--# line 64 "ascan.l"
             indented_code := True; 

         when 2 =>
--# line 65 "ascan.l"
             linenum := linenum + 1; ECHO;
                -- treat as a comment;
            

         when 3 =>
--# line 68 "ascan.l"
             linenum := linenum + 1; ECHO; 

         when 4 =>
--# line 69 "ascan.l"
             return SCDECL; 

         when 5 =>
--# line 70 "ascan.l"
             return XSCDECL; 

         when 6 =>
--# line 71 "ascan.l"
             return USCDECL; 

         when 7 =>
--# line 72 "ascan.l"
             return OPTDECL; 

         when 8 =>
--# line 73 "ascan.l"
             ENTER(YYDECL_STRING); return YYDECL; 

         when 9 =>
--# line 74 "ascan.l"
             return YYVAR; 

         when 10 =>
--# line 76 "ascan.l"
             return WHITESPACE; 

         when 11 =>
--# line 77 "ascan.l"
             nmstr := vstr(yytext(1..YYLength)); return OPTVAR; 

         when 12 =>
--# line 78 "ascan.l"
            
                  Open_Code_Block (Template_Manager.Get_Filename (Template_Manager.YYTYPE_CODE));
                  ENTER(CODEBLOCK_MATCH_BRACE);


         when 13 =>
--# line 82 "ascan.l"
            
                  Open_Code_Block (Template_Manager.Get_Filename (Template_Manager.YYACTION_CODE));
                  ENTER(CODEBLOCK_MATCH_BRACE);


         when 14 =>
--# line 86 "ascan.l"
            
                  Open_Code_Block (Template_Manager.Get_Filename (Template_Manager.YYWRAP_CODE));
                  ENTER(CODEBLOCK_MATCH_BRACE);


         when 15 =>
--# line 90 "ascan.l"
            
                  Open_Code_Block (Template_Manager.Get_Filename (Template_Manager.YYINIT_CODE));
                  ENTER(CODEBLOCK_MATCH_BRACE);


         when 16 =>
--# line 95 "ascan.l"
            
            sectnum := 2;
            misc.line_directive_out;
            ENTER(SECT2PROLOG);
            return SECTEND;
            

         when 17 =>
--# line 102 "ascan.l"
            
               misc.synerr ("unrecognized code block");
               ENTER(CODEBLOCK_MATCH_BRACE);
            

         when 18 =>
--# line 107 "ascan.l"
            
            Ada.Text_IO.Put( Standard_Error, "old-style lex command at line " );
            int_io.put( Standard_Error, linenum );
            Ada.Text_IO.Put( Standard_Error, " ignored:" );
            text_io.new_line( Standard_Error );
            Ada.Text_IO.Put( Standard_Error, ASCII.HT );
            Ada.Text_IO.Put( Standard_Error, yytext(1..YYLength) );
            linenum := linenum + 1;
            

         when 19 =>
--# line 117 "ascan.l"
            
            nmstr := vstr(yytext(1..YYLength));
            didadef := False;
            ENTER(PICKUPDEF);
            

         when 20 =>
--# line 123 "ascan.l"
             nmstr := vstr(yytext(1..YYLength));
              return UNAME;
            

         when 21 =>
--# line 127 "ascan.l"
             nmstr := vstr(yytext(1..YYLength));
              return NAME;
            

         when 22 =>
--# line 130 "ascan.l"
             linenum := linenum + 1;
              -- allows blank lines in section 1;
            

         when 23 =>
--# line 133 "ascan.l"
             linenum := linenum + 1; return Newline; 

         when 24 =>
--# line 134 "ascan.l"
             misc.synerr( "illegal character" );ENTER(RECOVER);

         when 25 =>
--# line 135 "ascan.l"
            
               nmstr := vstr(yytext(1..YYLength));
               ENTER(0);
               return NAME;
            

         when 26 =>
--# line 140 "ascan.l"
             null;
              -- separates name and definition;
            

         when 27 =>
--# line 144 "ascan.l"
            
            nmdef := vstr(yytext(1..YYLength));

            i := tstring.len( nmdef );
            while ( i >= tstring.first ) loop
                if ( (CHAR(nmdef,i) /= ' ') and
                 (CHAR(nmdef,i) /= ASCII.HT) ) then
                exit;
                end if;
                i := i - 1;
            end loop;

                        sym.ndinstal( nmstr,
                tstring.slice(nmdef, tstring.first, i) );
            didadef := True;
            

         when 28 =>
--# line 161 "ascan.l"
            
            if not didadef then
                misc.synerr( "incomplete name definition" );
            end if;
            ENTER(0);
            linenum := linenum + 1;
            

         when 29 =>
--# line 169 "ascan.l"
             linenum := linenum + 1;
              ENTER(0);
              nmstr := vstr(yytext(1..YYLength));
              return NAME;
            

         when 30 =>
            yy_ch_buf (yy_cp) := yy_hold_char; -- undo effects of setting up yytext
            yy_cp := yy_cp - 1;
            yy_c_buf_p := yy_cp;
            YY_DO_BEFORE_ACTION; -- set up yytext again
--# line 175 "ascan.l"
            
            linenum := linenum + 1;
            ACTION_ECHO;
            MARK_END_OF_PROLOG;
            ENTER(SECT2);
            

         when 31 =>
--# line 182 "ascan.l"
             linenum := linenum + 1; ACTION_ECHO; 

   when YY_END_OF_BUFFER +SECT2PROLOG + 1 
 =>
--# line 184 "ascan.l"
 MARK_END_OF_PROLOG;
              return End_Of_Input;
            

         when 33 =>
--# line 188 "ascan.l"
             linenum := linenum + 1;
              -- allow blank lines in sect2;

            -- this rule matches indented lines which
            -- are not comments.
         when 34 =>
--# line 193 "ascan.l"
            
            misc.synerr("indented code found outside of action");
            linenum := linenum + 1;
            

         when 35 =>
--# line 198 "ascan.l"
             ENTER(SC); return ( '<' ); 

         when 36 =>
--# line 199 "ascan.l"
             return ( '^' );  

         when 37 =>
--# line 200 "ascan.l"
             ENTER(QUOTE); return ( '"' ); 

         when 38 =>
            yy_ch_buf (yy_cp) := yy_hold_char; -- undo effects of setting up yytext
            yy_cp := yy_bp + 1;
            yy_c_buf_p := yy_cp;
            YY_DO_BEFORE_ACTION; -- set up yytext again
--# line 201 "ascan.l"
             ENTER(NUM); return ( '{' ); 

         when 39 =>
--# line 202 "ascan.l"
             ENTER(BRACEERROR); 

         when 40 =>
            yy_ch_buf (yy_cp) := yy_hold_char; -- undo effects of setting up yytext
            yy_cp := yy_bp + 1;
            yy_c_buf_p := yy_cp;
            YY_DO_BEFORE_ACTION; -- set up yytext again
--# line 203 "ascan.l"
             return '$'; 

         when 41 =>
--# line 205 "ascan.l"
             continued_action := True;
              linenum := linenum + 1;
              return Newline;
            

         when 42 =>
--# line 210 "ascan.l"
             linenum := linenum + 1; ACTION_ECHO; 

         when 43 =>
--# line 212 "ascan.l"
            
            -- this rule is separate from the one below because
            -- otherwise we get variable trailing context, so
            -- we can't build the scanner using -f,F

            bracelevel := 0;
            continued_action := False;
            ENTER(ACTION);
            return Newline;
            

         when 44 =>
            yy_ch_buf (yy_cp) := yy_hold_char; -- undo effects of setting up yytext
            yy_cp := yy_cp - 1;
            yy_c_buf_p := yy_cp;
            YY_DO_BEFORE_ACTION; -- set up yytext again
--# line 223 "ascan.l"
            
            bracelevel := 0;
            continued_action := False;
            ENTER(ACTION);
            return Newline;
            

         when 45 =>
--# line 230 "ascan.l"
             linenum := linenum + 1; return Newline; 

         when 46 =>
--# line 232 "ascan.l"
             return EOF_OP; 

         when 47 =>
--# line 234 "ascan.l"
            
            sectnum := 3;
            ENTER(SECT3);
            return End_Of_Input;
            -- to stop the parser
            

         when 48 =>
--# line 241 "ascan.l"
            

            nmstr := vstr(yytext(1..YYLength));

            -- check to see if we've already encountered this ccl
                        cclval := sym.ccllookup( nmstr );
            if ( cclval /= 0 ) then
                YYLVal := cclval;
                cclreuse := cclreuse + 1;
                return PREVCCL;
            else
                -- we fudge a bit.  We know that this ccl will
                -- soon be numbered as lastccl + 1 by cclinit
                sym.cclinstal( nmstr, lastccl + 1 );

                -- push back everything but the leading bracket
                -- so the ccl can be rescanned

                PUT_BACK_STRING(nmstr, 1);

                ENTER(FIRSTCCL);
                return '[';
            end if;
            

         when 49 =>
--# line 266 "ascan.l"
            
            nmstr := vstr(yytext(1..YYLength));
            -- chop leading and trailing brace
            tmpbuf := slice(vstr(yytext(1..YYLength)),
                                2, YYLength-1);

            nmdefptr := sym.ndlookup( tmpbuf );
            if ( nmdefptr = NUL ) then
                misc.synerr( "undefined {name}" );
            else
                -- push back name surrounded by ()'s
                unput(')');
                PUT_BACK_STRING(nmdefptr, 0);
                unput('(');
            end if;
            

         when 50 =>
--# line 283 "ascan.l"
             tmpbuf := vstr(yytext(1..YYLength));
              case tstring.CHAR(tmpbuf,1) is
                when '/' => return '/';
                when '|' => return '|';
                when '*' => return '*';
                when '+' => return '+';
                when '?' => return '?';
                when '.' => return '.';
                when '(' => return '(';
                when ')' => return ')';
                when others =>
                    misc.aflexerror("error in aflex case");
              end case;
            

         when 51 =>
--# line 297 "ascan.l"
             tmpbuf := vstr(yytext(1..YYLength));
              YYLVal := CHARACTER'POS(CHAR(tmpbuf,1));
              return CHAR;
            

         when 52 =>
--# line 301 "ascan.l"
             linenum := linenum + 1; return Newline; 

         when 53 =>
--# line 304 "ascan.l"
             return ( ',' ); 

         when 54 =>
--# line 305 "ascan.l"
             ENTER(SECT2); return ( '>' ); 

         when 55 =>
            yy_ch_buf (yy_cp) := yy_hold_char; -- undo effects of setting up yytext
            yy_cp := yy_bp + 1;
            yy_c_buf_p := yy_cp;
            YY_DO_BEFORE_ACTION; -- set up yytext again
--# line 306 "ascan.l"
             ENTER(CARETISBOL); return ( '>' ); 

         when 56 =>
--# line 307 "ascan.l"
             nmstr := vstr(yytext(1..YYLength));
              return NAME;
            

         when 57 =>
--# line 310 "ascan.l"
             misc.synerr( "bad start condition name" ); 

         when 58 =>
--# line 312 "ascan.l"
             ENTER(SECT2); return '^'; 

         when 59 =>
--# line 315 "ascan.l"
             tmpbuf := vstr(yytext(1..YYLength));
              YYLVal := CHARACTER'POS(CHAR(tmpbuf,1));
              return CHAR;
            

         when 60 =>
--# line 319 "ascan.l"
             ENTER(SECT2); return '"'; 

         when 61 =>
--# line 321 "ascan.l"
            
            misc.synerr( "missing quote" );
            ENTER(SECT2);
            linenum := linenum + 1;
            return '"';
            

         when 62 =>
            yy_ch_buf (yy_cp) := yy_hold_char; -- undo effects of setting up yytext
            yy_cp := yy_bp + 1;
            yy_c_buf_p := yy_cp;
            YY_DO_BEFORE_ACTION; -- set up yytext again
--# line 329 "ascan.l"
             ENTER(CCL); return '^'; 

         when 63 =>
            yy_ch_buf (yy_cp) := yy_hold_char; -- undo effects of setting up yytext
            yy_cp := yy_bp + 1;
            yy_c_buf_p := yy_cp;
            YY_DO_BEFORE_ACTION; -- set up yytext again
--# line 330 "ascan.l"
             return '^'; 

         when 64 =>
--# line 331 "ascan.l"
             ENTER(CCL); YYLVal := CHARACTER'POS('-'); return ( CHAR ); 

         when 65 =>
--# line 332 "ascan.l"
             ENTER(CCL);
              tmpbuf := vstr(yytext(1..YYLength));
              YYLVal := CHARACTER'POS(CHAR(tmpbuf,1));
              return CHAR;
            

         when 66 =>
            yy_ch_buf (yy_cp) := yy_hold_char; -- undo effects of setting up yytext
            yy_cp := yy_bp + 1;
            yy_c_buf_p := yy_cp;
            YY_DO_BEFORE_ACTION; -- set up yytext again
--# line 338 "ascan.l"
             return '-'; 

         when 67 =>
--# line 339 "ascan.l"
             tmpbuf := vstr(yytext(1..YYLength));
              YYLVal := CHARACTER'POS(CHAR(tmpbuf,1));
              return CHAR;
            

         when 68 =>
--# line 343 "ascan.l"
             ENTER(SECT2); return ']'; 

         when 69 =>
--# line 346 "ascan.l"
            
            YYLVal := misc.myctoi( vstr(yytext(1..YYLength)) );
            return NUMBER;
            

         when 70 =>
--# line 351 "ascan.l"
             return ','; 

         when 71 =>
--# line 352 "ascan.l"
             ENTER(SECT2); return '}'; 

         when 72 =>
--# line 354 "ascan.l"
            
            misc.synerr( "bad character inside {}'s" );
            ENTER(SECT2);
            return '}';
            

         when 73 =>
--# line 360 "ascan.l"
            
            misc.synerr( "missing }" );
            ENTER(SECT2);
            linenum := linenum + 1;
            return '}';
            

         when 74 =>
--# line 368 "ascan.l"
             misc.synerr( "bad name in {}'s" ); ENTER(SECT2); 

         when 75 =>
--# line 369 "ascan.l"
             misc.synerr( "missing }" );
              linenum := linenum + 1;
              ENTER(SECT2);
            

         when 76 =>
--# line 374 "ascan.l"
             bracelevel := bracelevel + 1; 

         when 77 =>
--# line 375 "ascan.l"
             bracelevel := bracelevel - 1; 

         when 78 =>
--# line 376 "ascan.l"
             ACTION_ECHO; 

         when 79 =>
--# line 377 "ascan.l"
             ACTION_ECHO; 

         when 80 =>
--# line 378 "ascan.l"
             linenum := linenum + 1; ACTION_ECHO; 

         when 81 =>
--# line 379 "ascan.l"
             ACTION_ECHO;
                  -- character constant;
            

         when 82 =>
--# line 383 "ascan.l"
             ACTION_ECHO; ENTER(ACTION_STRING); 

         when 83 =>
--# line 385 "ascan.l"
            
            linenum := linenum + 1;
            ACTION_ECHO;
            if bracelevel = 0 then
                text_io.new_line ( temp_action_file );
                ENTER(SECT2);
                    end if;
            

         when 84 =>
--# line 393 "ascan.l"
             ACTION_ECHO; 

         when 85 =>
--# line 395 "ascan.l"
             ACTION_ECHO; 

         when 86 =>
--# line 396 "ascan.l"
             ACTION_ECHO; 

         when 87 =>
--# line 397 "ascan.l"
             linenum := linenum + 1; ACTION_ECHO; 

         when 88 =>
--# line 398 "ascan.l"
             ACTION_ECHO; ENTER(ACTION); 

         when 89 =>
--# line 399 "ascan.l"
             ACTION_ECHO; 

         when 90 =>
--# line 402 "ascan.l"
            
            YYLVal := CHARACTER'POS(misc.myesc( vstr(yytext(1..YYLength)) ));
            return ( CHAR );
            

         when 91 =>
--# line 407 "ascan.l"
            
            YYLVal := CHARACTER'POS(misc.myesc( vstr(yytext(1..YYLength)) ));
            ENTER(CCL);
            return CHAR;
            

         when 92 =>
--# line 414 "ascan.l"
             if check_yylex_here then
                return End_Of_Input;
              else
                ECHO;
              end if;
            

         when 93 =>
--# line 421 "ascan.l"
            
                if Code_Block_Active then
                   Ada.Text_IO.Close (Code_Block_File);
                   Code_Block_Active := False;
                end if;
                ENTER(0);
                return YYCODEBLOCK;
            

         when 94 =>
--# line 430 "ascan.l"
            
                --  brace_depth++;
                if Code_Block_Active then
                   Ada.Text_IO.Put (Code_Block_File, YYText);
                end if;
            

         when 95 =>
--# line 437 "ascan.l"
            
                Linenum := Linenum + 1;
                if Code_Block_Active then
                   Ada.Text_IO.New_Line (Code_Block_File);
                end if;
            

         when 96 =>
--# line 444 "ascan.l"
            
                Linenum := Linenum + 1; 
                if Code_Block_Active then
                   Ada.Text_IO.Put (Code_Block_File, YYText);
                end if;
            

   when YY_END_OF_BUFFER +CODEBLOCK_MATCH_BRACE + 1 
 =>
--# line 451 "ascan.l"

                misc.synerr ("unmatched '{' at line" & Natural'Image (Code_Block_Start));
                if Code_Block_Active then
                   Ada.Text_IO.Close (Code_Block_File);
                end if;
                ENTER(0);
                return YYCODEBLOCK;
            

         when 98 =>
--# line 460 "ascan.l"
            ECHO;
         when YY_END_OF_BUFFER + INITIAL + 1 |
              YY_END_OF_BUFFER + SECT2 + 1 |
              YY_END_OF_BUFFER + SECT3 + 1 |
              YY_END_OF_BUFFER + PICKUPDEF + 1 |
              YY_END_OF_BUFFER + SC + 1 |
              YY_END_OF_BUFFER + CARETISBOL + 1 |
              YY_END_OF_BUFFER + NUM + 1 |
              YY_END_OF_BUFFER + QUOTE + 1 |
              YY_END_OF_BUFFER + FIRSTCCL + 1 |
              YY_END_OF_BUFFER + CCL + 1 |
              YY_END_OF_BUFFER + ACTION + 1 |
              YY_END_OF_BUFFER + RECOVER + 1 |
              YY_END_OF_BUFFER + BRACEERROR + 1 |
              YY_END_OF_BUFFER + ACTION_STRING + 1 |
              YY_END_OF_BUFFER + YYDECL_STRING + 1 =>
            return End_Of_Input;

         when YY_END_OF_BUFFER =>
            --  undo the effects of YY_DO_BEFORE_ACTION
            yy_ch_buf (yy_cp) := yy_hold_char;

            yytext_ptr := yy_bp;

            case yy_get_next_buffer is
               when EOB_ACT_END_OF_FILE =>
                  if yyWrap then
                     --  note: because we've taken care in
                     --  yy_get_next_buffer() to have set up yytext,
                     --  we can now set up yy_c_buf_p so that if some
                     --  total hoser (like aflex itself) wants
                     --  to call the scanner after we return the
                     --  End_Of_Input, it'll still work - another
                     --  End_Of_Input will get returned.

                     yy_c_buf_p := yytext_ptr;

                     yy_act := YY_STATE_EOF ((yy_start - 1) / 2);

                     goto do_action;
                  else
                     --  start processing a new file
                     yy_init := True;
                     goto new_file;
                  end if;

               when EOB_ACT_RESTART_SCAN =>
                  yy_c_buf_p := yytext_ptr;
                  yy_hold_char := yy_ch_buf (yy_c_buf_p);

               when EOB_ACT_LAST_MATCH =>
                  yy_c_buf_p := yy_n_chars;
                  yy_current_state := yy_get_previous_state;
                  yy_cp := yy_c_buf_p;
                  yy_bp := yytext_ptr;
                  goto next_action;
            end case; --  case yy_get_next_buffer()

         when others =>
            Ada.Text_IO.Put ("action # ");
            Ada.Text_IO.Put (Integer'Image (yy_act));
            Ada.Text_IO.New_Line;
            raise AFLEX_INTERNAL_ERROR;
         end case; --  case (yy_act)
      end loop; --  end of loop waiting for end of file
   end YYLex;

--# line 460 "ascan.l"
   begin

      if (call_yylex) then
         toktype := YYLex;
         call_yylex := False;
         return toktype;
      end if;

      if ( eofseen ) then
         toktype := End_Of_Input;
      else
         toktype := YYLex;
      end if;

      -- this tracing code allows easy tracing of aflex runs
      if (trace) then
         Ada.Text_IO.New_Line (Standard_Error);
         Ada.Text_IO.Put (Standard_Error, "toktype = :" );
         Ada.Text_IO.Put (Standard_Error, Token'Image (toktype));
         Ada.Text_IO.Put_line (Standard_Error, ":" );
      end if;

      if ( toktype = End_Of_Input ) then
         eofseen := True;

         if sectnum = 1 then
            misc.synerr ("unexpected EOF");
            sectnum := 2;
            toktype := SECTEND;
         elsif sectnum = 2 then
            sectnum := 3;
            toktype := SECTEND;
         end if;
      end if;
    
      if trace then
         if beglin then
            Int_IO.Put (Standard_Error, num_rules + 1);
            Ada.Text_IO.Put (Standard_Error, ASCII.HT);
            beglin := False;
         end if;

         case toktype is
            when '<' | '>'|'^'|'$'|'"'|'['|']'|'{'|'}'|'|'|'('|
                 ')'|'-'|'/'|'?'|'.'|'*'|'+'|',' =>
               Ada.Text_IO.Put (Standard_Error, Token'Image (toktype));

            when NEWLINE =>
               Ada.Text_IO.New_Line (Standard_Error);
               if sectnum = 2 then
                  beglin := True;
               end if;

            when SCDECL =>
               Ada.Text_IO.Put (Standard_Error, "%s");

            when XSCDECL =>
               Ada.Text_IO.Put (Standard_Error, "%x");

            when WHITESPACE =>
               Ada.Text_IO.Put (Standard_Error, " ");

            when SECTEND =>
               Ada.Text_IO.Put_line (Standard_Error, "%%");

               --  we set beglin to be true so we'll start
               --  writing out numbers as we echo rules.  aflexscan() has
               --  already assigned sectnum

               if sectnum = 2 then
                  beglin := True;
               end if;

            when NAME =>
               Ada.Text_IO.Put (Standard_Error, ''');
               Ada.Text_IO.Put (Standard_Error, YYText);
               Ada.Text_IO.Put (Standard_Error, ''');

            when CHAR =>
               if ( (YYLVal < CHARACTER'POS(' ')) or
                  (YYLVal = CHARACTER'POS(ASCII.DEL)) ) then
                  Ada.Text_IO.Put (Standard_Error, '\');
                  Int_IO.Put (Standard_Error, YYLVal);
                  Ada.Text_IO.Put (Standard_Error, '\');
               else
                  Ada.Text_IO.Put (Standard_Error, Token'Image (toktype));
               end if;

            when NUMBER =>
               Int_IO.Put (Standard_Error, YYLVal);

            when OPTDECL =>
               Ada.Text_IO.Put (Standard_Error, "%option ");
               Ada.Text_IO.Put (Standard_Error, YYText);
               Ada.Text_IO.Put (Standard_Error, ''');

            when YYDECL =>
               Ada.Text_IO.Put (Standard_Error, "%yydecl ");
               Ada.Text_IO.Put (Standard_Error, YYText);
               Ada.Text_IO.Put (Standard_Error, ''');

            when YYCODEBLOCK =>
               Ada.Text_IO.Put (Standard_Error, "%<code> {");
               Ada.Text_IO.Put (Standard_Error, YYText);
               Ada.Text_IO.Put (Standard_Error, '}');

            when PREVCCL =>
               Ada.Text_IO.Put (Standard_Error, '[');
               Int_IO.Put (Standard_Error, YYLVal);
               Ada.Text_IO.Put (Standard_Error, ']');

            when End_Of_Input =>
               Ada.Text_IO.Put (Standard_Error, "End Marker");

            when others =>
               Ada.Text_IO.Put (Standard_Error, "Something weird:");
               Ada.Text_IO.Put_line (Standard_Error, Token'Image (toktype));
         end case;
      end if;
      return toktype;
   end get_token;

end scanner;

