
with Parse_Tokens, Parse_Goto, Parse_Shift_Reduce, Text_IO;
with NFA, ccl, misc, misc_defs, sym, ecs, aflex_scanner;
with tstring, int_io, main_body;
use aflex_scanner;
package body parser is
   -- build_eof_action - build the "<<EOF>>" action for the active start
   --                    conditions

   use text_io, misc_defs;

   procedure build_eof_action is
   begin
      text_io.put( temp_action_file, "   when " );
      for i in 1 .. actvp loop
         if ( sceof(actvsc(i)) ) then
            text_io.put(Standard_Error,
                        "multiple <<EOF>> rules for start condition ");
            tstring.put( Standard_Error, scname(actvsc(i)));
            main_body.aflexend(1);
         else
            sceof(actvsc(i)) := true;
            text_io.put( temp_action_file, "YY_END_OF_BUFFER +" );
            tstring.put( temp_action_file,  scname(actvsc(i)) );
            text_io.put_line( temp_action_file, " + 1 " );
            if (i /= actvp) then
               text_io.put_line( temp_action_file, " |" );
            else
               text_io.put_line( temp_action_file, " =>" );
            end if;
         end if;
      end loop;
      misc.line_directive_out( temp_action_file );
   end build_eof_action;

--  yyerror - eat up an error message from the parser
-- 
--  synopsis
--     char msg[];
--     yyerror( msg );

   procedure yyerror( msg : string ) is
   begin
      null;
   end yyerror;

--  Warning: This file is automatically generated by AYACC.
--           It is useless to modify it. Change the ".Y" & ".L" files instead.


   procedure YYParse is

      --  Rename User Defined Packages to Internal Names.
      package yy_goto_tables renames
         Parse_Goto;
      package yy_shift_reduce_tables renames
         Parse_Shift_Reduce;
      package yy_tokens renames
         Parse_Tokens;

      use yy_tokens, yy_goto_tables, yy_shift_reduce_tables;
      procedure handle_error;

      subtype goto_row is yy_goto_tables.Row;
      subtype reduce_row is yy_shift_reduce_tables.Row;

      package yy is

         --  the size of the value and state stacks
         --  Affects error 'Stack size exceeded on state_stack'
         stack_size : constant Natural := 300;

         --  subtype rule         is Natural;
         subtype parse_state is Natural;
         --  subtype nonterminal  is Integer;

         --  encryption constants
         default           : constant := -1;
         first_shift_entry : constant := 0;
         accept_code       : constant := -3001;
         error_code        : constant := -3000;

         --  stack data used by the parser
         tos                : Natural := 0;
         value_stack        : array (0 .. stack_size) of yy_tokens.YYSType;
         state_stack        : array (0 .. stack_size) of parse_state;

         --  current input symbol and action the parser is on
         action             : Integer;
         rule_id            : Rule;
         input_symbol       : yy_tokens.Token := Error;

         --  error recovery flag
         error_flag : Natural := 0;
         --  indicates  3 - (number of valid shifts after an error occurs)

         look_ahead : Boolean := True;
         index      : reduce_row;

         --  Is Debugging option on or off
         debug : constant Boolean := False;

      end yy;

      procedure shift_debug (state_id : yy.parse_state; lexeme : yy_tokens.Token);
      procedure reduce_debug (rule_id : Rule; state_id : yy.parse_state);

      function goto_state
         (state : yy.parse_state;
          sym   : Nonterminal) return yy.parse_state;

      function parse_action
         (state : yy.parse_state;
          t     : yy_tokens.Token) return Integer;

      pragma Inline (goto_state, parse_action);

      function goto_state (state : yy.parse_state;
                           sym   : Nonterminal) return yy.parse_state is
         index : goto_row;
      begin
         index := Goto_Offset (state);
         while Goto_Matrix (index).Nonterm /= sym loop
            index := index + 1;
         end loop;
         return Integer (Goto_Matrix (index).Newstate);
      end goto_state;


      function parse_action (state : yy.parse_state;
                             t     : yy_tokens.Token) return Integer is
         index   : reduce_row;
         tok_pos : Integer;
         default : constant Integer := -1;
      begin
         tok_pos := yy_tokens.Token'Pos (t);
         index   := Shift_Reduce_Offset (state);
         while Integer (Shift_Reduce_Matrix (index).T) /= tok_pos
           and then Integer (Shift_Reduce_Matrix (index).T) /= default
         loop
            index := index + 1;
         end loop;
         return Integer (Shift_Reduce_Matrix (index).Act);
      end parse_action;

      --  error recovery stuff

      procedure handle_error is
         temp_action : Integer;
      begin

         if yy.error_flag = 3 then --  no shift yet, clobber input.
            if yy.debug then
               Text_IO.Put_Line ("  -- Ayacc.YYParse: Error Recovery Clobbers "
                                 & yy_tokens.Token'Image (yy.input_symbol));
            end if;
            if yy.input_symbol = yy_tokens.End_Of_Input then  -- don't discard,
               if yy.debug then
                  Text_IO.Put_Line ("  -- Ayacc.YYParse: Can't discard END_OF_INPUT, quiting...");
               end if;
               raise yy_tokens.Syntax_Error;
            end if;

            yy.look_ahead := True;   --  get next token
            return;                  --  and try again...
         end if;

         if yy.error_flag = 0 then --  brand new error
            yyerror ("Syntax Error");
         end if;

         yy.error_flag := 3;

         --  find state on stack where error is a valid shift --

         if yy.debug then
            Text_IO.Put_Line ("  -- Ayacc.YYParse: Looking for state with error as valid shift");
         end if;

         loop
            if yy.debug then
               Text_IO.Put_Line ("  -- Ayacc.YYParse: Examining State "
                                 & yy.parse_state'Image (yy.state_stack (yy.tos)));
            end if;
            temp_action := parse_action (yy.state_stack (yy.tos), Error);

            if temp_action >= yy.first_shift_entry then
               if yy.tos = yy.stack_size then
                  Text_IO.Put_Line ("  -- Ayacc.YYParse: Stack size exceeded on state_stack");
                  raise yy_tokens.Syntax_Error;
               end if;
               yy.tos                  := yy.tos + 1;
               yy.state_stack (yy.tos) := temp_action;
               exit;
            end if;

            if yy.tos /= 0 then
               yy.tos := yy.tos - 1;
            end if;

            if yy.tos = 0 then
               if yy.debug then
                  Text_IO.Put_Line
                     ("  -- Ayacc.YYParse: Error recovery popped entire stack, aborting...");
               end if;
               raise yy_tokens.Syntax_Error;
            end if;
         end loop;

         if yy.debug then
            Text_IO.Put_Line ("  -- Ayacc.YYParse: Shifted error token in state "
                              & yy.parse_state'Image (yy.state_stack (yy.tos)));
         end if;

      end handle_error;

      --  print debugging information for a shift operation
      procedure shift_debug (state_id : yy.parse_state; lexeme : yy_tokens.Token) is
      begin
         Text_IO.Put_Line ("  -- Ayacc.YYParse: Shift "
                           & yy.parse_state'Image (state_id) & " on input symbol "
                           & yy_tokens.Token'Image (lexeme));
      end shift_debug;

      --  print debugging information for a reduce operation
      procedure reduce_debug (rule_id : Rule; state_id : yy.parse_state) is
      begin
         Text_IO.Put_Line ("  -- Ayacc.YYParse: Reduce by rule "
                           & Rule'Image (rule_id) & " goto state "
                           & yy.parse_state'Image (state_id));
      end reduce_debug;


   begin
      --  initialize by pushing state 0 and getting the first input symbol
      yy.state_stack (yy.tos) := 0;


      loop
         yy.index := Shift_Reduce_Offset (yy.state_stack (yy.tos));
         if Integer (Shift_Reduce_Matrix (yy.index).T) = yy.default then
            yy.action := Integer (Shift_Reduce_Matrix (yy.index).Act);
         else
            if yy.look_ahead then
               yy.look_ahead := False;

               yy.input_symbol := YYLex;
            end if;
            yy.action := parse_action (yy.state_stack (yy.tos), yy.input_symbol);
         end if;


         if yy.action >= yy.first_shift_entry then  --  SHIFT

            if yy.debug then
               shift_debug (yy.action, yy.input_symbol);
            end if;

            --  Enter new state
            if yy.tos = yy.stack_size then
               Text_IO.Put_Line (" Stack size exceeded on state_stack");
               raise yy_tokens.Syntax_Error;
            end if;
            yy.tos                  := yy.tos + 1;
            yy.state_stack (yy.tos) := yy.action;
            yy.value_stack (yy.tos) := YYLVal;

            if yy.error_flag > 0 then  --  indicate a valid shift
               yy.error_flag := yy.error_flag - 1;
            end if;

            --  Advance lookahead
            yy.look_ahead := True;

         elsif yy.action = yy.error_code then       -- ERROR

            handle_error;

         elsif yy.action = yy.accept_code then
            if yy.debug then
               Text_IO.Put_Line ("  --  Ayacc.YYParse: Accepting Grammar...");
            end if;
            exit;

         else --  Reduce Action

            --  Convert action into a rule
            yy.rule_id := Rule (-1 * yy.action);

            --  Execute User Action
            --  user_action(yy.rule_id);

            case yy.rule_id is
               pragma Style_Checks (Off);

when 1 => -- #line 48
 -- add default rule

            pat := ccl.cclinit;
            ccl.cclnegate( pat );

            def_rule := nfa.mkstate( -pat );

            nfa.finish_rule( def_rule, false, 0, 0 );

            for i in 1 .. lastsc loop
                scset(i) := nfa.mkbranch( scset(i), def_rule );
            end loop;

            if ( spprdflt ) then
                Text_IO.Put (temp_action_file,
                        "raise AFLEX_SCANNER_JAMMED;");
            else
                Text_IO.Put (temp_action_file, "ECHO");

            text_io.put_line( temp_action_file, ";" );
            end if;


when 2 => -- #line 73

            -- initialize for processing rules

                   -- create default DFA start condition
            sym.scinstal( tstring.vstr("INITIAL"), false );


when 4 => -- #line 83

            misc.set_unitname (nmstr);


when 5 => -- #line 87

            misc.set_option (nmstr);


when 7 => -- #line 92
 misc.synerr( "unknown error processing section 1" );

when 11 => -- #line 103

             -- these productions are separate from the s1object
             -- rule because the semantics must be done before
             -- we parse the remainder of an s1object


            xcluflg := false;


when 12 => -- #line 113
 xcluflg := true;

when 13 => -- #line 117
 sym.scinstal( nmstr, xcluflg );

when 14 => -- #line 120
 sym.scinstal( nmstr, xcluflg );

when 15 => -- #line 123
 misc.synerr( "bad start condition list" );

when 18 => -- #line 131

            -- initialize for a parse of one rule
            trlcontxt := false;
            variable_trail_rule := false;
            varlength := false;
            trailcnt := 0;
            headcnt := 0;
            rulelen := 0;
            current_state_enum := STATE_NORMAL;
            previous_continued_action := continued_action;
            nfa.new_rule;


when 19 => -- #line 146

            pat := nfa.link_machines( yy.value_stack (yy.tos-1), yy.value_stack (yy.tos) );
            nfa.finish_rule( pat, variable_trail_rule,
                     headcnt, trailcnt );

            for i in 1 .. actvp loop
                scbol(actvsc(i)) :=
                nfa.mkbranch( scbol(actvsc(i)), pat );
            end loop;

            if ( not bol_needed ) then
                bol_needed := true;

                if ( performance_report ) then
                text_io.put( Standard_Error,
            "'^' operator results in sub-optimal performance");
                    text_io.new_line(Standard_Error);
                            end if;
            end if;


when 20 => -- #line 168

            pat := nfa.link_machines( yy.value_stack (yy.tos-1), yy.value_stack (yy.tos) );
            nfa.finish_rule( pat, variable_trail_rule,
                     headcnt, trailcnt );

            for i in 1 .. actvp loop
                scset(actvsc(i)) :=
                nfa.mkbranch( scset(actvsc(i)), pat );
            end loop;


when 21 => -- #line 179

            pat := nfa.link_machines( yy.value_stack (yy.tos-1), yy.value_stack (yy.tos) );
            nfa.finish_rule( pat, variable_trail_rule,
                     headcnt, trailcnt );

            -- add to all non-exclusive start conditions,
            -- including the default (0) start condition

            for i in 1 .. lastsc loop
                if ( not scxclu(i) ) then
                scbol(i) := nfa.mkbranch( scbol(i), pat );
                end if;
            end loop;

            if ( not bol_needed ) then
                bol_needed := true;

                if ( performance_report ) then
                text_io.put( Standard_Error,
            "'^' operator results in sub-optimal performance");
                    text_io.new_line(Standard_Error);
                end if;
            end if;


when 22 => -- #line 204

            pat := nfa.link_machines( yy.value_stack (yy.tos-1), yy.value_stack (yy.tos) );
            nfa.finish_rule( pat, variable_trail_rule,
                     headcnt, trailcnt );

            for i in 1 .. lastsc loop
                if ( not scxclu(i) ) then
                scset(i) := nfa.mkbranch( scset(i), pat );
                end if;
            end loop;


when 23 => -- #line 217
 build_eof_action;

when 24 => -- #line 220

            -- this EOF applies only to the INITIAL start cond.
            actvp := 1;
            actvsc(actvp) := 1;
            build_eof_action;


when 25 => -- #line 228
 misc.synerr( "unrecognized rule" );

when 27 => -- #line 235

            scnum := sym.sclookup( nmstr );
            if (scnum = 0 ) then
                    text_io.put( Standard_Error,
                     "undeclared start condition ");
                    tstring.put( Standard_Error, nmstr );
                main_body.aflexend( 1 );
            else
              actvp := actvp + 1;
                actvsc(actvp) := scnum;
            end if;


when 28 => -- #line 249

            scnum := sym.sclookup( nmstr );
            if (scnum = 0 ) then
                    text_io.put( Standard_Error,
                    "undeclared start condition ");
                    tstring.put( Standard_Error,     nmstr );
                main_body.aflexend ( 1 );
            else
                actvp := 1;
                actvsc(actvp) := scnum;
            end if;


when 29 => -- #line 263
 misc.synerr( "bad start condition list" );

when 30 => -- #line 267

            if trlcontxt then
                misc.synerr( "trailing context used twice" );
                YYVal := nfa.mkstate( SYM_EPSILON );
            else
                trlcontxt := true;

                if ( not varlength ) then
                headcnt := rulelen;
                end if;

                rulelen := rulelen + 1;
                trailcnt := 1;

                eps := nfa.mkstate( SYM_EPSILON );
                YYVal := nfa.link_machines( eps,
                      nfa.mkstate( CHARACTER'POS(ASCII.LF) ) );
                        end if;


when 31 => -- #line 288

                YYVal := nfa.mkstate( SYM_EPSILON );

            if ( trlcontxt ) then
                if ( varlength and (headcnt = 0) ) then
                -- both head and trail are variable-length
                variable_trail_rule := true;
                else
                trailcnt := rulelen;
                end if;
                        end if;


when 32 => -- #line 303

            varlength := true;

            YYVal := nfa.mkor( yy.value_stack (yy.tos-2), yy.value_stack (yy.tos) );


when 33 => -- #line 310

            if ( transchar(lastst(yy.value_stack (yy.tos))) /= SYM_EPSILON ) then
                -- provide final transition \now/ so it
                -- will be marked as a trailing context
                -- state

                yy.value_stack (yy.tos) := nfa.link_machines( yy.value_stack (yy.tos), nfa.mkstate( SYM_EPSILON ) );
            end if;

            nfa.mark_beginning_as_normal( yy.value_stack (yy.tos) );
            current_state_enum := STATE_NORMAL;

            if ( previous_continued_action ) then
                -- we need to treat this as variable trailing
                -- context so that the backup does not happen
                -- in the action but before the action switch
                -- statement.  If the backup happens in the
                -- action, then the rules "falling into" this
                -- one's action will *also* do the backup,
                -- erroneously.

                    if ( (not varlength) or  headcnt /= 0 ) then
                     text_io.put( Standard_Error,
                              "alex: warning - trailing context rule at line");
                                     int_io.put(Standard_Error, linenum);
                     text_io.put( Standard_Error,
                           "made variable because of preceding '|' action" );
                                     int_io.put(Standard_Error, linenum);
                                end if;

                -- mark as variable
                varlength := true;
                headcnt := 0;
                        end if;

            if ( varlength and (headcnt = 0) ) then
                -- variable trailing context rule
                -- mark the first part of the rule as the accepting
                -- "head" part of a trailing context rule

                -- by the way, we didn't do this at the beginning
                -- of this production because back then
                -- current_state_enum was set up for a trail
                -- rule, and add_accept() can create a new
                -- state ...

                nfa.add_accept( yy.value_stack (yy.tos-1),
                                   misc.set_yy_trailing_head_mask(num_rules) );
                        end if;

            YYVal := nfa.link_machines( yy.value_stack (yy.tos-1), yy.value_stack (yy.tos) );


when 34 => -- #line 364
 YYVal := yy.value_stack (yy.tos);

when 35 => -- #line 369

            -- this rule is separate from the others for "re" so
            -- that the reduction will occur before the trailing
            -- series is parsed

            if ( trlcontxt ) then
                misc.synerr( "trailing context used twice" );
            else
                trlcontxt := true;
            end if;

            if ( varlength ) then
                -- we hope the trailing context is fixed-length
                varlength := false;
            else
                headcnt := rulelen;
            end if;

            rulelen := 0;

            current_state_enum := STATE_TRAILING_CONTEXT;
            YYVal := yy.value_stack (yy.tos-1);


when 36 => -- #line 395

            -- this is where concatenation of adjacent patterns
            -- gets done

            YYVal := nfa.link_machines( yy.value_stack (yy.tos-1), yy.value_stack (yy.tos) );


when 37 => -- #line 403
 YYVal := yy.value_stack (yy.tos);

when 38 => -- #line 407

            varlength := true;

            YYVal := nfa.mkclos( yy.value_stack (yy.tos-1) );


when 39 => -- #line 414

            varlength := true;

            YYVal := nfa.mkposcl( yy.value_stack (yy.tos-1) );


when 40 => -- #line 421

            varlength := true;

            YYVal := nfa.mkopt( yy.value_stack (yy.tos-1) );


when 41 => -- #line 428

            varlength := true;

            if ( (yy.value_stack (yy.tos-3) > yy.value_stack (yy.tos-1)) or (yy.value_stack (yy.tos-3) < 0) ) then
                misc.synerr( "bad iteration values" );
                YYVal := yy.value_stack (yy.tos-5);
            else
                if ( yy.value_stack (yy.tos-3) = 0 ) then
                YYVal := nfa.mkopt( nfa.mkrep( yy.value_stack (yy.tos-5), yy.value_stack (yy.tos-3), yy.value_stack (yy.tos-1) ) );
                else
                YYVal := nfa.mkrep( yy.value_stack (yy.tos-5), yy.value_stack (yy.tos-3), yy.value_stack (yy.tos-1) );
                end if;
                        end if;


when 42 => -- #line 444

            varlength := true;

            if ( yy.value_stack (yy.tos-2) <= 0 ) then
                misc.synerr( "iteration value must be positive" );
                YYVal := yy.value_stack (yy.tos-4);
            else
                YYVal := nfa.mkrep( yy.value_stack (yy.tos-4), yy.value_stack (yy.tos-2), INFINITY );
            end if;


when 43 => -- #line 456

            -- the singleton could be something like "(foo)",
            -- in which case we have no idea what its length
            -- is, so we punt here.

            varlength := true;

            if ( yy.value_stack (yy.tos-1) <= 0 ) then
                misc.synerr( "iteration value must be positive" );
                YYVal := yy.value_stack (yy.tos-3);
            else
                YYVal := nfa.link_machines( yy.value_stack (yy.tos-3), nfa.copysingl( yy.value_stack (yy.tos-3), yy.value_stack (yy.tos-1) - 1 ) );
            end if;


when 44 => -- #line 472

            if ( not madeany ) then
                -- create the '.' character class
                anyccl := ccl.cclinit;
                ccl.ccladd( anyccl, ASCII.LF );
                ccl.cclnegate( anyccl );

                if ( useecs ) then
                ecs.mkeccl(
               ccltbl(cclmap(anyccl)..cclmap(anyccl) + ccllen(anyccl)),
                    ccllen(anyccl), nextecm,
                    ecgroup, CSIZE );
                end if;
                madeany := true;
                        end if;

            rulelen := rulelen + 1;

            YYVal := nfa.mkstate( -anyccl );


when 45 => -- #line 494

            if ( not cclsorted ) then
                -- sort characters for fast searching.  We use a
                -- shell sort since this list could be large.

--                misc.cshell( ccltbl + cclmap($1), ccllen($1) );
              misc.cshell( ccltbl(cclmap(yy.value_stack (yy.tos))..cclmap(yy.value_stack (yy.tos)) + ccllen(yy.value_stack (yy.tos))),
                   ccllen(yy.value_stack (yy.tos)) );
            end if;

            if ( useecs ) then
            ecs.mkeccl( ccltbl(cclmap(yy.value_stack (yy.tos))..cclmap(yy.value_stack (yy.tos)) + ccllen(yy.value_stack (yy.tos))),
                ccllen(yy.value_stack (yy.tos)),nextecm, ecgroup, CSIZE );
            end if;

            rulelen := rulelen + 1;

            YYVal := nfa.mkstate( -yy.value_stack (yy.tos) );


when 46 => -- #line 515

            rulelen := rulelen + 1;

            YYVal := nfa.mkstate( -yy.value_stack (yy.tos) );


when 47 => -- #line 522
 YYVal := yy.value_stack (yy.tos-1);

when 48 => -- #line 525
 YYVal := yy.value_stack (yy.tos-1);

when 49 => -- #line 528

            rulelen := rulelen + 1;

            if ( yy.value_stack (yy.tos) = CHARACTER'POS(ASCII.NUL) ) then
                misc.synerr( "null in rule" );
            end if;

            if ( caseins and (yy.value_stack (yy.tos) >= CHARACTER'POS('A')) and (yy.value_stack (yy.tos) <= CHARACTER'POS('Z')) ) then
                yy.value_stack (yy.tos) := misc.clower( yy.value_stack (yy.tos) );
            end if;

            YYVal := nfa.mkstate( yy.value_stack (yy.tos) );


when 50 => -- #line 544
 YYVal := yy.value_stack (yy.tos-1);

when 51 => -- #line 547

            -- *Sigh* - to be compatible Unix lex, negated ccls
            -- match newlines
            ccl.cclnegate( yy.value_stack (yy.tos-1) );
            YYVal := yy.value_stack (yy.tos-1);


when 52 => -- #line 556

            if ( yy.value_stack (yy.tos-2) > yy.value_stack (yy.tos) ) then
                misc.synerr( "negative range in character class" );
            else
                if ( caseins ) then
                if ( (yy.value_stack (yy.tos-2) >= CHARACTER'POS('A')) and (yy.value_stack (yy.tos-2) <= CHARACTER'POS('Z')) ) then
                    yy.value_stack (yy.tos-2) := misc.clower( yy.value_stack (yy.tos-2) );
                end if;
                if ( (yy.value_stack (yy.tos) >= CHARACTER'POS('A')) and (yy.value_stack (yy.tos) <= CHARACTER'POS('Z')) ) then
                    yy.value_stack (yy.tos) := misc.clower( yy.value_stack (yy.tos) );
                end if;
                            end if;

                for i in yy.value_stack (yy.tos-2) .. yy.value_stack (yy.tos) loop
                    ccl.ccladd( yy.value_stack (yy.tos-3), CHARACTER'VAL(i) );
                            end loop;

                -- keep track if this ccl is staying in
                -- alphabetical order

                cclsorted := cclsorted and (yy.value_stack (yy.tos-2) > lastchar);
                lastchar := yy.value_stack (yy.tos);
                        end if;

            YYVal := yy.value_stack (yy.tos-3);


when 53 => -- #line 584

            if ( caseins ) then
                if ( (yy.value_stack (yy.tos) >= CHARACTER'POS('A')) and (yy.value_stack (yy.tos) <= CHARACTER'POS('Z')) ) then
                yy.value_stack (yy.tos) := misc.clower( yy.value_stack (yy.tos) );
                            end if;
            end if;
            ccl.ccladd( yy.value_stack (yy.tos-1), CHARACTER'VAL(yy.value_stack (yy.tos)) );
            cclsorted := cclsorted and (yy.value_stack (yy.tos) > lastchar);
            lastchar := yy.value_stack (yy.tos);
            YYVal := yy.value_stack (yy.tos-1);


when 54 => -- #line 597

            cclsorted := true;
            lastchar := 0;
            YYVal := ccl.cclinit;


when 55 => -- #line 605

            if ( caseins ) then
                if ( (yy.value_stack (yy.tos) >= CHARACTER'POS('A')) and (yy.value_stack (yy.tos) <= CHARACTER'POS('Z')) ) then
                yy.value_stack (yy.tos) := misc.clower( yy.value_stack (yy.tos) );
                end if;
            end if;

            rulelen := rulelen + 1;

            YYVal := nfa.link_machines( yy.value_stack (yy.tos-1), nfa.mkstate( yy.value_stack (yy.tos) ) );


when 56 => -- #line 618
 YYVal := nfa.mkstate( SYM_EPSILON );

               pragma Style_Checks (On);

               when others => null;
            end case;

            --  Pop RHS states and goto next state
            yy.tos := yy.tos - Rule_Length (yy.rule_id) + 1;
            if yy.tos > yy.stack_size then
               Text_IO.Put_Line (" Stack size exceeded on state_stack");
               raise yy_tokens.Syntax_Error;
            end if;
            yy.state_stack (yy.tos) := goto_state (yy.state_stack (yy.tos - 1),
                                                   Get_LHS_Rule (yy.rule_id));

            yy.value_stack (yy.tos) := YYVal;

            if yy.debug then
               reduce_debug (yy.rule_id,
                  goto_state (yy.state_stack (yy.tos - 1),
                              Get_LHS_Rule (yy.rule_id)));
            end if;

         end if;

      end loop;

   end YYParse;

end parser;
