--  Warning: This lexical scanner is automatically generated by AFLEX.
--           It is useless to modify it. Change the ".Y" & ".L" files instead.
--  Template: templates/body-reentrant-lex.adb
%if minimalist
%else
with Ada.Text_IO; use Ada.Text_IO;
%end
%%1 user

%yydecl
      subtype Short is Integer range -32768 .. 32767;
      yy_act : Integer;
      yy_c   : Short;

      --  returned upon end-of-file
      YY_END_TOK : constant Integer := 0;
      subtype yy_state_type is Integer;
      yy_current_state : yy_state_type;

      yylinecol : Integer renames ${YYVAR}.dfa.yylinecol;
      yylineno  : Integer renames ${YYVAR}.dfa.yylineno;
      yy_last_yylinecol : Integer renames ${YYVAR}.dfa.yy_last_yylinecol;
      yy_last_yylineno  : Integer renames ${YYVAR}.dfa.yy_last_yylineno;
      yy_eof_has_been_seen : Boolean renames ${YYVAR}.yy_eof_has_been_seen;
      aflex_debug : Boolean renames ${YYVAR}.dfa.aflex_debug;
      yy_init  : Boolean renames ${YYVAR}.dfa.yy_init;
      yy_c_buf_p  : Index renames ${YYVAR}.dfa.yy_c_buf_p;
      yy_start : yy_state_type renames ${YYVAR}.dfa.yy_start;
      yy_cp    : Index renames ${YYVAR}.dfa.yy_cp;
      yy_bp    : Index renames ${YYVAR}.dfa.yy_bp;
      yytext_ptr   : Index renames ${YYVAR}.dfa.yytext_ptr;
      yy_last_accepting_state : Lexer_DFA.yy_state_type renames ${YYVAR}.dfa.yy_last_accepting_state;
      yy_last_accepting_cpos  : Index renames ${YYVAR}.dfa.yy_last_accepting_cpos;
      yy_hold_char  : Character renames ${YYVAR}.dfa.yy_hold_char;
      yy_ch_buf     : Lexer_DFA.ch_buf_type renames ${YYVAR}.dfa.yy_ch_buf;
      yy_n_chars    : Index renames ${YYVAR}.yy_n_chars;
      YYLVal : YYSType renames ${YYVAR}.YYLVal;
      YYVal  : YYSType renames ${YYVAR}.YYVal;

      function yy_get_next_buffer return Lexer_IO.eob_action_type
        is (Lexer_IO.yy_get_next_buffer (${YYVAR}));

      function YYText return String
        is (Lexer_DFA.YYText (${YYVAR}.dfa));

      procedure YY_DO_BEFORE_ACTION is
      begin
        Lexer_DFA.YY_DO_BEFORE_ACTION (${YYVAR}.dfa);
      end YY_DO_BEFORE_ACTION;

%%2 tables

      --  copy whatever the last rule matched to the standard output
%if echo
      procedure ECHO is
      begin
         if Ada.Text_IO.Is_Open (user_output_file) then
            Ada.Text_IO.Put (user_output_file, YYText);
         else
            Ada.Text_IO.Put (YYText);
         end if;
      end ECHO;
%end

      --  enter a start condition.
      --  Using procedure requires a () after the ENTER, but makes everything
      --  much neater.

      procedure ENTER (state : Integer) is
      begin
         yy_start := 1 + 2 * state;
      end ENTER;

      --  action number for EOF rule of a given start state
      function YY_STATE_EOF (state : Integer) return Integer is
      begin
         return YY_END_OF_BUFFER + state + 1;
      end YY_STATE_EOF;

      --  return all but the first 'n' matched characters back to the input stream
      procedure yyless (n : Integer) is
      begin
         yy_ch_buf (yy_cp) := yy_hold_char; --  undo effects of setting up yytext
         yy_cp := yy_bp + n;
         yy_c_buf_p := yy_cp;
         YY_DO_BEFORE_ACTION; -- set up yytext again
      end yyless;
%if yyaction
      --  redefine this if you have something you want each time.
      procedure YY_USER_ACTION is
      begin
%yyaction
      end YY_USER_ACTION;
%end
      --  yy_get_previous_state - get the state just before the EOB char was reached

      function yy_get_previous_state return yy_state_type is
         yy_current_state : yy_state_type;
         yy_c : Short;
%%3 ybp
         --  yy_bp : constant Integer := yytext_ptr;
      begin
%%3 startstate

         for yy_cp in yytext_ptr .. yy_c_buf_p - 1 loop
%%4 nextstate
         end loop;

         return yy_current_state;
      end yy_get_previous_state;

      procedure yyrestart (input_file : File_Type) is
      begin
         Open_Input (${YYVAR}, Ada.Text_IO.Name (input_file));
      end yyrestart;

   begin -- of ${YYLEX}
%if yywrap
      <<new_file>>
      --  this is where we enter upon encountering an end-of-file and
      --  yyWrap () indicating that we should continue processing
%end

      if yy_init then
%yyinit
         if yy_start = 0 then
            yy_start := 1;      -- first start state
         end if;

         --  we put in the '\n' and start reading from [1] so that an
         --  initial match-at-newline will be true.

         yy_ch_buf (0) := ASCII.LF;
         yy_n_chars := 1;

         --  we always need two end-of-buffer characters. The first causes
         --  a transition to the end-of-buffer state. The second causes
         --  a jam in that state.

         yy_ch_buf (yy_n_chars) := YY_END_OF_BUFFER_CHAR;
         yy_ch_buf (yy_n_chars + 1) := YY_END_OF_BUFFER_CHAR;

         yy_eof_has_been_seen := False;

         yytext_ptr := 1;
         yy_c_buf_p := yytext_ptr;
         yy_hold_char := yy_ch_buf (yy_c_buf_p);
         yy_init := False;
%if error
         --   Initialization
         tok_begin_line := 1;
         tok_end_line := 1;
         tok_begin_col := 0;
         tok_end_col := 0;
         token_at_end_of_line := False;
         line_number_of_saved_tok_line1 := 0;
         line_number_of_saved_tok_line2 := 0;
%end
      end if; -- yy_init

      loop                -- loops until end-of-file is reached
%if error
         --    if last matched token is end_of_line, we must
         --    update the token_end_line and reset tok_end_col.
         if Token_At_End_Of_Line then
            Tok_End_Line := Tok_End_Line + 1;
            Tok_End_Col := 0;
            Token_At_End_Of_Line := False;
         end if;
%end

         yy_cp := yy_c_buf_p;

         --  support of yytext
         yy_ch_buf (yy_cp) := yy_hold_char;

         --  yy_bp points to the position in yy_ch_buf of the start of the
         --  current run.
%%5 action

   <<next_action>>
%%6 action
         YY_DO_BEFORE_ACTION;
%if yyaction
         YY_USER_ACTION;
%end

         if aflex_debug then  -- output acceptance info. for (-d) debug mode
            Ada.Text_IO.Put (Standard_Error, "  -- Aflex.YYLex accept rule #");
            Ada.Text_IO.Put (Standard_Error, Integer'Image (yy_act));
            Ada.Text_IO.Put_Line (Standard_Error, "(""" & YYText & """)");
         end if;
%if error
         --   Update tok_begin_line, tok_end_line, tok_begin_col and tok_end_col
         --   after matching the token.
         if yy_act /= YY_END_OF_BUFFER and then yy_act /= 0 then
            -- Token are matched only when yy_act is not yy_end_of_buffer or 0.
            Tok_Begin_Line := Tok_End_Line;
            Tok_Begin_Col := Tok_End_Col + 1;
            Tok_End_Col := Tok_Begin_Col + yy_cp - yy_bp - 1;
            if yy_ch_buf ( yy_bp ) = ASCII.LF then
               Token_At_End_Of_Line := True;
            end if;
         end if;
%end

   <<do_action>>   -- this label is used only to access EOF actions
         case yy_act is

%%7 action

         when YY_END_OF_BUFFER =>
            --  undo the effects of YY_DO_BEFORE_ACTION
            yy_ch_buf (yy_cp) := yy_hold_char;

            yytext_ptr := yy_bp;

            case yy_get_next_buffer is
               when EOB_ACT_END_OF_FILE =>
%if yywrap
                  if yyWrap (${YYVAR}) then
                     --  note: because we've taken care in
                     --  yy_get_next_buffer() to have set up yytext,
                     --  we can now set up yy_c_buf_p so that if some
                     --  total hoser (like aflex itself) wants
                     --  to call the scanner after we return the
                     --  End_Of_Input, it'll still work - another
                     --  End_Of_Input will get returned.

                     yy_c_buf_p := yytext_ptr;

                     yy_act := YY_STATE_EOF ((yy_start - 1) / 2);

                     goto do_action;
                  else
                     --  start processing a new file
                     yy_init := True;
                     goto new_file;
                  end if;
%else
                  --  note: because we've taken care in
                  --  yy_get_next_buffer() to have set up yytext,
                  --  we can now set up yy_c_buf_p so that if some
                  --  total hoser (like aflex itself) wants
                  --  to call the scanner after we return the
                  --  End_Of_Input, it'll still work - another
                  --  End_Of_Input will get returned.

                  yy_c_buf_p := yytext_ptr;

                  yy_act := YY_STATE_EOF ((yy_start - 1) / 2);

                  goto do_action;
%end

               when EOB_ACT_RESTART_SCAN =>
                  yy_c_buf_p := yytext_ptr;
                  yy_hold_char := yy_ch_buf (yy_c_buf_p);

               when EOB_ACT_LAST_MATCH =>
                  yy_c_buf_p := yy_n_chars;
                  yy_current_state := yy_get_previous_state;
                  yy_cp := yy_c_buf_p;
                  yy_bp := yytext_ptr;
                  goto next_action;

            end case; --  case yy_get_next_buffer()

         when others =>
            Ada.Text_IO.Put ("action # ");
            Ada.Text_IO.Put (Integer'Image (yy_act));
            Ada.Text_IO.New_Line;
            raise AFLEX_INTERNAL_ERROR;

         end case; --  case (yy_act)
      end loop; --  end of loop waiting for end of file
   end ${YYLEX};

%%8 user
