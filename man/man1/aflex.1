.TH AFLEX 1 "May 2023" "Version 1.6"
.SH NAME
aflex - fast lexical analyzer generator for Ada
.SH SYNOPSIS
.B aflex
[
.B -bdfimpstvEILPTR -Sskeleton_file
] [ 
.I filename
]
.SH DESCRIPTION
.I aflex
is a version of the Unix tool 
.I lex
, but it is written in Ada and generates scanners in Ada.
It is upwardly compatible with the UCI tool alex, but is
much faster and generates smaller scanners.
.SH OPTIONS
Command line options are given in a different format than in the
old UCI alex.  Aflex options are as follows
.TP
.B -t
Write the scanner output to the standard output rather than to a file.
The default name of the scanner file for base.l is base.a  Note that this
option is not as useful with aflex because in addition to the scanner
file there are files for the externally visible dfa functions
(base_dfa.a) and the external IO functions (base_io.a)
.TP
.B -b
Generate backtracking information to
.I aflex.backtrack.
This is a list of scanner states which require backtracking
and the input characters on which they do so.  By adding rules one
can remove backtracking states.  If all backtracking states
are eliminated and
.B -f
is used, the generated scanner will run faster (see the
.B -p
flag).  Only users who wish to squeeze every last cycle out of their
scanners need worry about this option.
.TP
.B -d
makes the generated scanner run in
.I debug
mode.  Whenever a pattern is recognized the scanner will
write to
.I stderr
a line of the form:
.nf

    --accepting rule #n

.fi
Rules are numbered sequentially with the first one being 1.  Rule #0
is executed when the scanner backtracks; Rule #(n+1) (where
.I n
is the number of rules) indicates the default action; Rule #(n+2) indicates
that the input buffer is empty and needs to be refilled and then the scan
restarted.  Rules beyond (n+2) are end-of-file actions.
.TP
.B -f
has the same effect as lex's -f flag (do not compress the scanner
tables); the mnemonic changes from
.I fast compilation
to (take your pick)
.I full table
or
.I fast scanner.
The actual compilation takes
.I longer,
since aflex is I/O bound writing out the big table.
The compilation of the Ada file containing the scanner is also likely
to take a long time because of the large arrays generated.
.TP
.B -i
instructs aflex to generate a
.I case-insensitive
scanner.  The case of letters given in the aflex input patterns will
be ignored, and the rules will be matched regardless of case.  The
matched text given in
.I yytext
will have the preserved case (i.e., it will not be folded).
.TP
.B -m
minimalist with clause.  When the
.B -m
option is passed, the
.I Ada.Text_IO
package, the DFA and IO packages are not with'ed from the main
generated lexer.
.TP
.B -p
generates a performance report to stderr.  The report
consists of comments regarding features of the aflex input file
which will cause a loss of performance in the resulting scanner.
Note that the use of
the
.B ^
operator
and the
.B -I
flag entail minor performance penalties.
.TP
.B -s
causes the
.I default rule
(that unmatched scanner input is echoed to
.I stdout)
to be suppressed.  If the scanner encounters input that does not
match any of its rules, it aborts with an error.  This option is
useful for finding holes in a scanner's rule set.
.TP
.B -v
has the same meaning as for lex (print to
.I stderr
a summary of statistics of the generated scanner).  Many more statistics
are printed, though, and the summary spans several lines.  Most
of the statistics are meaningless to the casual aflex user, but the
first line identifies the version of aflex, which is useful for figuring
out where you stand with respect to patches and new releases.
.TP
.B -E
instructs aflex to generate additional information about each token,
including line and column numbers.  This is needed for the advanced
automatic error option correction in ayacc.
.TP
.B -I
instructs aflex to generate an
.I interactive
scanner.  Normally, scanners generated by aflex always look ahead one
character before deciding that a rule has been matched.  At the cost of
some scanning overhead, aflex will generate a scanner which only looks ahead
when needed.  Such scanners are called
.I interactive
because if you want to write a scanner for an interactive system such as a
command shell, you will probably want the user's input to be terminated
with a newline, and without
.B -I
the user will have to type a character in addition to the newline in order
to have the newline recognized.  This leads to dreadful interactive
performance.
.IP
If all this seems to confusing, here's the general rule: if a human will
be typing in input to your scanner, use
.B -I,
otherwise don't; if you don't care about how fast your scanners run and
don't want to make any assumptions about the input to your scanner,
always use
.B -I.
.IP
Note,
.B -I
cannot be used in conjunction with
.I full
i.e., the
.B -f
flag.
.TP
.B -L
instructs aflex to not generate
.B #line
directives (see below).
.TP
.B -P
instructs aflex to generate a private Ada package for the DFA and IO packages.
This option is useful to prevent access to the lexer package variables
and can be used when the main scanner package is also declared as a private Ada package
in the input source file.
.TP
.B -R
generate a reentrant Ada scanner.
.TP
.B -T
makes aflex run in
.I trace
mode.  It will generate a lot of messages to stdout concerning
the form of the input and the resultant non-deterministic and deterministic
finite automatons.  This option is mostly for use in maintaining aflex.
.TP
.B -Sskeleton_file
overrides the default internal skeleton from which aflex constructs
its scanners.  You'll probably never need this option unless you are doing
aflex maintenance or development.
.\"
.SH SCANNER OPTIONS
.I aflex
supports the
.I flex
option directive in the input file but with only one name per line.  The syntax is
.RS 5

%option \fIname\fP
.RE
.PP
The following options are supported:
.TP
case-sensitive or casefull
Generate a case sensitive scanner (this is the default).
.TP
case-insensitive or caseless
Generate a case insensitive scanner (similar to
.B -i
option)
.TP
interactive
Generate an interactive scanner (similar to
.B -I
option).
.TP
full
.TP
yylineno
Enable the generaton of
.I yylineno
and
.I yylinecol
variables in the scanner to track the symbol current line and column.
.TP
nounput or unput
Disable or enable the generation of the
.I Unput
and
.I yyunput
function in the
.I _IO
package.  If you don't use the
.I yyunput
no
.I Unput
procedure, you should be able to use the
.I nounput
option.
.\"
.TP
noinput or input
Enable or disable the generation of the
.I Input
function in the
.I _IO
package.
.\"
.TP
nooutput or output
Enable or disable the generation of the
.I Output
support in the
.I _IO
package.
.TP
noyywrap or yywrap
Enable or disable the use and generation of the
.I yywrap
procedure to switch to another buffer or file when the end of a file is reached.
.TP
debug
Enable the debug mode in the scanner (similar to the
.B -d
option).
.TP
reentrant
Generate a reentrant scanner (similar to the
.B -R
option).  When a reentrant scanner is generated, two limited
Ada type record are generated in the
.I _DFA
and
.I _IO
packages to keep track of the current scanner state and the generated scanner
does not use global variables.  The
.I YYLex
function must be called with a context parameter with the type
.I Context_Type
defined in the
.I _IO
package.  The name of context variable can be configured by using the
.I %yyvar
directive.
.TP
bufsize=NNN
Controls the size of the read buffer used by the scanner.  The default value
.I 75000
has been increased over time to handle large content in the
.I YYText
variable.  This option allows to control the buffer size.
.\"
.PP
For the reentrant scanner, two specific directives are added to control the
.I YYLex
function declaration and the name of variable that represents the reentrant
context.
.RS 5

   %yy\fIname\fP \fIcontent\fP
.RE
.\"
.TP
yydecl
This name controls the declaration section of the
.I YYLex
function body.  The reentrant scanner assumes that the
.I YYLex
function has at least one parameter of type
.I Lexer_IO.Context_Type
that describes the scanner context.  This context will be passed to some generated
operation.
.\"
.TP
yyvar
This name controls the name of variable representing the scanner context
passed to the
.I YYLex
function.  The default name is
.IR Context .
.\"
.SH SCANNER CODE BLOCKS
.I aflex
supports code block injection in the generated scanner at various places.
This code injection is similar to the code injection provided by
.IR flex (1)
but dedicated to Ada.  The code block can appear in the declaration section
and uses the following syntax:
.RS 5

   %yy\fIname\fP {
      -- Put your Ada code here
   }
.RE
.PP
The following code blocks are supported:
.\"
.TP
yytype
This code block is injected in the declaration section of the
.I YYLex
function body.  It allows you
to declare variables, types, local function and procedues that are available
to the scanner rules.
.\"
.TP
yyinit
This code block shall contain Ada statements which are executed the first time the
.I YYLex
function is called.  It can be used to setup an initial state for the scanner.
.\"
.TP
yyaction
When this code block is defined,
.I aflex
will generate the
.I YY_USER_ACTION
procedure that is called before executing each action.  It should contain
Ada statements that are executed in the body of the generated procedure.
.TP
yywrap
When defined, this describes the Ada statements which are used for the generated
.I yywrap
function.  The Ada statements must return a boolean value.
The
.I yywrap
function is called when an end-of-file is reached to decide whether the scanner must stop
or continue to scan with a next file.  The Ada statements shall return
.I true
when the scanner must stop and
.I false
to proceed with the next input.  When this code block is not defined, the default
.I yywrap
function will return
.I true .
.\"
.SH INCOMPATIBILITIES WITH LEX
.I aflex
is fully compatible with
.I lex
with the following exceptions:
.\"
.IP \(bu 4
Source file format:
.sp
The input specification file for 
.I aflex
must use the following format.
.RS 5
 definitions section
 %%
 rules section
 %%
 user defined section
 ##
 user defined section
.RE
.\"
.IP \(bu 4
lex's
.B %r
(Ratfor scanners) and
.B %t
(translation table) options
are not supported.
.\"
.IP \(bu 4
The do-nothing
.I -n
flag is not supported.
.\"
.IP \(bu 4
When definitions are expanded, aflex encloses them in parentheses.
With lex, the following
.RS 5

    NAME    [A-Z][A-Z0-9]*
    %%
    foo{NAME}?      Ada.Text_IO.Put_Line ("Found it");
    %%

.RE
will not match the string "foo" because when the macro
is expanded the rule is equivalent to "foo[A-Z][A-Z0-9]*?"
and the precedence is such that the '?' is associated with
"[A-Z0-9]*".  With aflex, the rule will be expanded to
"foo([A-z][A-Z0-9]*)?" and so the string "foo" will match.
Note that because of this, the
.B ^, $, <s>,
and
.B /
operators cannot be used in a definition.
.\"
.IP \(bu 4
Input can be controlled by redefining the
.B YY_INPUT
function.
YY_INPUT's calling sequence is "YY_INPUT(buf,result,max_size)".  Its
action is to place up to max_size characters in the character buffer "buf"
and return in the integer variable "result" either the
number of characters read or the constant YY_NULL
to indicate EOF.  The default YY_INPUT reads from
Standard_Input.
.sp
You also can add in things like counting keeping track of the
input line number this way; but don't expect your scanner to
go very fast.
.\"
.IP \(bu 4
Yytext is a function returning a
.BR String .
.\"
.IP \(bu 4
aflex reads only one input file, while lex's input is made
up of the concatenation of its input files.
.\"
.IP \(bu 4
The
.B %unit
directive is an optional statement to define the name of the generated Ada package.
.\"
.IP \(bu 4
The following lex constructs are not supported
.RS 5
- REJECT
.sp
- %T 	-- character set tables
.sp
- %x	-- changes to internal array sizes (see below)
.sp
.RE
.SH ENHANCEMENTS
.\"
.IP \(bu 4
.I Exclusive start-conditions
can be declared by using
.B %x
instead of
.B %s.
These start-conditions have the property that when they are active,
.I no other rules are active.
Thus a set of rules governed by the same exclusive start condition
describe a scanner which is independent of any of the other rules in
the aflex input.  This feature makes it easy to specify "mini-scanners"
which scan portions of the input that are syntactically different
from the rest (e.g., comments).
.I End-of-file rules.
The special rule "<<EOF>>" indicates
actions which are to be taken when an end-of-file is
encountered and
.I yywrap
returns non-zero (i.e., indicates
no further files to process).  The action can either
.I Ada.Text_IO.Set_Input
to a new file to process, in which case the
action should finish with
.I YY_NEW_FILE
(this is a branch, so subsequent code in the action won't
be executed), or it should finish with a
.I return
statement.  <<EOF>> rules may not be used with other
patterns; they may only be qualified with a list of start
conditions.  If an unqualified <<EOF>> rule is given, it
applies only to the INITIAL start condition, and
.I not
to
.B %s
start conditions.
These rules are useful for catching things like unclosed comments.
An example:
.RS 5

    %x quote
    %%
    ...
    <quote><<EOF>>   {
	     error( "unterminated quote" );
	     }
    <<EOF>>          {
	     set_input( next_file );
	     YY_NEW_FILE;
	     }

.RE
.\"
.IP \(bu 4
aflex dynamically resizes its internal tables, so directives like "%a 3000"
are not needed when specifying large scanners.
.\"
.IP \(bu 4
aflex generates
.B --#line
comments mapping lines in the output to
their origin in the input file.
.\"
.IP \(bu 4
All actions must be enclosed by curly braces.
.\"
.IP \(bu 4
Comments may be put in the first section of the input by preceding
them with '#'.
.\"
.IP \(bu 4
Ada style comments are supported instead of C style comments.
.\"
.IP \(bu 4
All template files are internalized.  The reentrant scanner uses specific templates.
.\"
.IP \(bu 4
The input source file must end with a ".l" extension.
.\"
.IP \(bu 4
The Ada package name used for the generated DFA and IO files can be customized by
using the
.B %unit
statement at begining of the lex file.  By default, aflex will use the
scanner file name to build the package name.  The package name will be the
scanner file name with the possible '-' changed into '.'.  The
.B %unit
allows to override this and specify the Ada package name to use.
.\"
.SH FILES
.TP
.IR filename _io.ads
.TP
.IR filename _io.adb
.TP
.IR filename _dfa.ads
.TP
.IR filename _dfa.adb
The names of the files containing the generated scanner, IO,
and DFA packages are based on the basename of the input file.
For example if the input file is called scan.l then the
scanner file is called \fIscan.ada\fR, the DFA package is in \fIscan_dfa.ads\fR, and
\fIscan_io.ads\fR is the IO package file.  All of these file names may be changed
by modifying the external_file_manager package (see the porting notes
for more information.)
.TP
.I aflex.backtrack
backtracking information for
.B -b
.SH "SEE ALSO"
.BR lex (1)
.BR ayacc (1)
.LP
M. E. Lesk and E. Schmidt,
.I LEX - Lexical Analyzer Generator.
Technical Report Computing Science Technical Report, 39, Bell Telephone
Laboratories, Murray Hill, NJ, 1975.
.LP
Military Standard Ada Programming Language
	(ANSI/MIL-STD-1815A-1983),
American National Standards Institute, January 1983.
.LP
T. Nguyen and K. Forester,
.I Alex - An Ada Lexical Analysis Generator
Arcadia Document UCI-88-17,
University of California, Irvine, 1988
.LP
D. Taback and D. Tolani,
.I Ayacc User's Manual,
Arcadia Document UCI-85-10,
University of California, Irvine, 1986
.SH AUTHOR
John Self.  Based on the tool flex written and designed by
Vern Paxson.  It reimplements the functionality of the tool alex
designed by Thieu Q. Nguyen.
.SH DIAGNOSTICS
.LP
.I aflex scanner jammed -
a scanner compiled with
.B -s
has encountered an input string which wasn't matched by
any of its rules.
.LP
.LP
.I old-style lex command ignored -
the aflex input contains a lex command (e.g., "%n 1000") which
is being ignored.
.SH BUGS
.LP
Some trailing context
patterns cannot be properly matched and generate
warning messages ("Dangerous trailing context").  These are
patterns where the ending of the
first part of the rule matches the beginning of the second
part, such as "zx*/xy*", where the 'x*' matches the 'x' at
the beginning of the trailing context.  (Lex doesn't get these
patterns right either.)
.LP
.I variable
trailing context (where both the leading and trailing parts do not have
a fixed length) entails a substantial performance loss.
.LP
For some trailing context rules, parts which are actually fixed-length are
not recognized as such, leading to the abovementioned performance loss.
In particular, parts using '|' or {n} are always considered variable-length.
.LP
Nulls are not allowed in aflex inputs or in the inputs to
scanners generated by aflex.  Their presence generates fatal
errors.
.LP
Pushing back definitions enclosed in ()'s can result in nasty,
difficult-to-understand problems like:
.RS 5

	{DIG}  [0-9] -- a digit

.RE
In which the pushed-back text is "([0-9] -- a digit)".
.LP
Due to both buffering of input and read-ahead, you cannot intermix
calls to
.I Ada.Text_IO
routines, such as, for example,
.I Ada.Text_IO.Get
with aflex rules and expect it to work.  Call
.I input
instead.
.LP
There are still more features that could be implemented (especially REJECT) 
Also the speed of the compressed scanners could be improved.
.LP
The utility needs more complete documentation.
